W292 [*] No newline at end of file
 --> src\__init__.py:1:35
  |
1 | # This file makes 'src' a package.
  |                                   ^
  |
help: Add trailing newline

E501 Line too long (113 > 100)
 --> src\core\annex.py:5:101
  |
3 | The Annexation Protocol (Heimdall's Watch)
4 | Identity: O.D.I.N.
5 | Purpose: Scan the territory, identify weakness (non-compliance), and propose a battle plan (ANNEXATION_PLAN.qmd).
  |                                                                                                     ^^^^^^^^^^^^^
6 | Wardens: Linscott (Tests), Mimir (Quality), Empire (Contracts), Edda (Docs).
7 | """
  |

F401 [*] `os` imported but unused
  --> src\core\annex.py:10:8
   |
 9 | import ast
10 | import os
   |        ^^
11 | import subprocess
12 | import sys
   |
help: Remove unused import: `os`

F401 [*] `subprocess` imported but unused
  --> src\core\annex.py:11:8
   |
 9 | import ast
10 | import os
11 | import subprocess
   |        ^^^^^^^^^^
12 | import sys
13 | from datetime import datetime
   |
help: Remove unused import: `subprocess`

ANN201 Missing return type annotation for public function `scan`
  --> src\core\annex.py:27:9
   |
25 |         self.edda_tasks = []
26 |
27 |     def scan(self):
   |         ^^^^
28 |         """Conducts a full comprehensive audit of the territory."""
29 |         from src.core.ui import HUD
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\core\annex.py:31:1
   |
29 |         from src.core.ui import HUD
30 |         HUD.persona_log("INFO", f"Scanning realm: {self.root}")
31 |         
   | ^^^^^^^^
32 |         # 1. Scan Code (Linscott & Torvalds)
33 |         for py_file in self.root.rglob("*.py"):
   |
help: Remove whitespace from blank line

F401 [*] `src.core.edda.EddaWeaver` imported but unused
  --> src\core\annex.py:39:35
   |
38 |         # 2. Scan Documentation (Edda)
39 |         from src.core.edda import EddaWeaver
   |                                   ^^^^^^^^^^
40 |         # We can re-use Edda logic or just replicate the scan for speed
41 |         # Replicating for now to keep loose coupling
   |
help: Remove unused import: `src.core.edda.EddaWeaver`

W293 [*] Blank line contains whitespace
  --> src\core\annex.py:48:1
   |
46 |             if ".agent/workflows" in str(md_file.as_posix()):
47 |                 continue
48 |                 
   | ^^^^^^^^^^^^^^^^
49 |             self.edda_tasks.append(md_file)
   |
help: Remove whitespace from blank line

SIM103 Return the condition `path.name == "__init__.py"` directly
  --> src\core\annex.py:69:9
   |
67 |               return True
68 |           # [O.D.I.N.] Init files are structural, rarely logic-bearing.
69 | /         if path.name == "__init__.py":
70 | |             return True
71 | |         return False
   | |____________________^
72 |
73 |       def _audit_code(self, source: Path):
   |
help: Replace with `return path.name == "__init__.py"`

ANN202 Missing return type annotation for private function `_audit_code`
  --> src\core\annex.py:73:9
   |
71 |         return False
72 |
73 |     def _audit_code(self, source: Path):
   |         ^^^^^^^^^^^
74 |         """
75 |         Checks for Linscott (Test) and Torvalds (Quality) compliance.
   |
help: Add return type annotation: `None`

W293 Blank line contains whitespace
  --> src\core\annex.py:76:1
   |
74 |         """
75 |         Checks for Linscott (Test) and Torvalds (Quality) compliance.
76 |         
   | ^^^^^^^^
77 |         This method verifies the existence of companion tests and performs
78 |         basic static analysis for common code quality issues like bare excepts.
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\annex.py:81:1
   |
79 |         """
80 |         rel_path = source.relative_to(self.root)
81 |         
   | ^^^^^^^^
82 |         # A. Linscott Standard: Where is the test?
83 |         test_path = self.root / "tests" / f"test_{source.stem}.py"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\annex.py:86:1
   |
84 |         # [O.D.I.N.] Also check Empire TDD path
85 |         empire_test_path = self.root / "tests" / "empire_tests" / f"test_{source.stem}_empire.py"
86 |         
   | ^^^^^^^^
87 |         if not test_path.exists() and not empire_test_path.exists():
88 |             # Try recursive mirror: src/foo.py -> tests/src/test_foo.py
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:112:1
    |
110 |                         "severity": "HIGH"
111 |                     })
112 |                 
    | ^^^^^^^^^^^^^^^^
113 |                 # Check for potential hardcoded secrets (Basic heuristic)
114 |                 if isinstance(node, ast.Assign):
    |
help: Remove whitespace from blank line

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\core\annex.py:116:25
    |
114 |   â€¦     if isinstance(node, ast.Assign):
115 |   â€¦         for target in node.targets:
116 | / â€¦             if isinstance(target, ast.Name) and any(s in target.id.lower() for s in ("key", "secret", "token", "password")):
117 | | â€¦                 if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str) and len(node.value.value) > 10:
    | |_______________________________________________________________________________________________________________________________^
118 |   â€¦                     self.breaches.append({
119 |   â€¦                         "type": "HEIMDALL_BREACH",
    |
help: Combine `if` statements using `and`

E501 Line too long (136 > 100)
   --> src\core\annex.py:116:101
    |
114 | â€¦     if isinstance(node, ast.Assign):
115 | â€¦         for target in node.targets:
116 | â€¦             if isinstance(target, ast.Name) and any(s in target.id.lower() for s in ("key", "secret", "token", "password")):
    |                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 | â€¦                 if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str) and len(node.value.value) > 10:
118 | â€¦                     self.breaches.append({
    |

E501 Line too long (137 > 100)
   --> src\core\annex.py:117:101
    |
115 | â€¦     for target in node.targets:
116 | â€¦         if isinstance(target, ast.Name) and any(s in target.id.lower() for s in ("key", "secret", "token", "password")):
117 | â€¦             if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str) and len(node.value.value) > 10:
    |                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 | â€¦                 self.breaches.append({
119 | â€¦                     "type": "HEIMDALL_BREACH",
    |

E501 Line too long (109 > 100)
   --> src\core\annex.py:121:101
    |
119 | â€¦                         "type": "HEIMDALL_BREACH",
120 | â€¦                         "file": rel_path.as_posix(),
121 | â€¦                         "action": f"Potential secret exposed: {target.id} at line {node.lineno}",
    |                                                                                           ^^^^^^^^^
122 | â€¦                         "severity": "CRITICAL"
123 | â€¦                     })
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\annex.py:124:9
    |
122 |                                       "severity": "CRITICAL"
123 |                                   })
124 | /         except Exception:
125 | |             pass # Parser error already a breach implicitly
    | |________________^
126 |
127 |       def _generate_plan(self):
    |

ANN202 Missing return type annotation for private function `_generate_plan`
   --> src\core\annex.py:127:9
    |
125 |             pass # Parser error already a breach implicitly
126 |
127 |     def _generate_plan(self):
    |         ^^^^^^^^^^^^^^
128 |         """Weaves the findings into a QMD battle plan, preserving existing checkmarks."""
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:129:1
    |
127 |     def _generate_plan(self):
128 |         """Weaves the findings into a QMD battle plan, preserving existing checkmarks."""
129 |         
    | ^^^^^^^^
130 |         # 1. Capture existing checkmarks
131 |         checked_files = set()
    |
help: Remove whitespace from blank line

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\annex.py:139:13
    |
137 |                   checked_matches = re.findall(r"- \[x\] \*\*\[.*?\]\*\* `(.*?)`", existing_content)
138 |                   checked_files = set(checked_matches)
139 | /             except Exception:
140 | |                 pass
    | |____________________^
141 |
142 |           timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    |

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:143:1
    |
142 |         timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
143 |         
    | ^^^^^^^^
144 |         plan = [
145 |             "---",
    |
help: Remove whitespace from blank line

E501 Line too long (104 > 100)
   --> src\core\annex.py:155:101
    |
153 |             "> [!IMPORTANT]",
154 |             "> **The Runes Have Been Cast.**",
155 |             "> Review the identified weaknesses below. To execute this plan, run: `c* annex --execute`",
    |                                                                                                     ^^^^
156 |             "",
157 |             "## ðŸ›¡ï¸ Linscott Standard (Test Verification)",
    |

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:161:1
    |
159 |             ""
160 |         ]
161 |         
    | ^^^^^^^^
162 |         linscott_breaches = [b for b in self.breaches if b["type"] == "LINSCOTT_BREACH"]
163 |         if linscott_breaches:
    |
help: Remove whitespace from blank line

E501 Line too long (104 > 100)
   --> src\core\annex.py:166:101
    |
164 |             for b in linscott_breaches:
165 |                 status = "x" if b['file'] in checked_files else " "
166 |                 plan.append(f"- [{status}] **[MISSING TEST]** `{b['file']}` â†’ Scaffold `{b['action']}`")
    |                                                                                                     ^^^^
167 |         else:
168 |             plan.append("*(No breaches detected. The defense is solid.)*")
    |

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:173:1
    |
171 |         plan.append("## ðŸ§ Torvalds Protocol (Code Quality)")
172 |         plan.append("Structural integrity mandates. No bare excepts. Strict typing.")
173 |         
    | ^^^^^^^^
174 |         mimir_breaches = [b for b in self.breaches if b["type"] == "MIMIR_BREACH"]
175 |         if mimir_breaches:
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\annex.py:177:71
    |
175 |         if mimir_breaches:
176 |             for b in mimir_breaches:
177 |                 # For Mimir, we check if filename is in checked_files. 
    |                                                                       ^
178 |                 # Better: use a composite key if needed, but filename works for basic state.
179 |                 status = "x" if b['file'] in checked_files else " "
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:183:1
    |
181 |         else:
182 |             plan.append("*(No breaches detected. Code is clean.)*")
183 |             
    | ^^^^^^^^^^^^
184 |         plan.append("")
185 |         plan.append("## ðŸ“œ The Edda (Documentation)")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:187:1
    |
185 |         plan.append("## ðŸ“œ The Edda (Documentation)")
186 |         plan.append("Legacy markdown must be transmuted to Quarto. Workflows are preserved.")
187 |         
    | ^^^^^^^^
188 |         if self.edda_tasks:
189 |             for doc in self.edda_tasks:
    |
help: Remove whitespace from blank line

E501 Line too long (110 > 100)
   --> src\core\annex.py:192:101
    |
190 |                 rel = doc.relative_to(self.root).as_posix()
191 |                 status = "x" if rel in checked_files else " "
192 |                 plan.append(f"- [{status}] **[TRANSMUTE]** `{rel}` â†’ `{doc.stem}.qmd` (Original Quarantined)")
    |                                                                                                     ^^^^^^^^^^
193 |         else:
194 |             plan.append("*(No legacy scrolls found.)*")
    |

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:202:1
    |
200 |         plan.append("1. **Approve**: Mark items as `[x]` to confirm.")
201 |         plan.append("2. **Execute**: Run the annexation command.")
202 |         
    | ^^^^^^^^
203 |         from src.core.ui import HUD
204 |         self.plan_path.write_text("\n".join(plan), encoding="utf-8")
    |
help: Remove whitespace from blank line

E501 Line too long (143 > 100)
   --> src\core\annex.py:206:101
    |
204 | â€¦ing="utf-8")
205 | â€¦lf.plan_path}")
206 | â€¦tt={len(linscott_breaches)}, Mimir={len(mimir_breaches)}, Edda={len(self.edda_tasks)}")
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
207 | â€¦
208 | â€¦========================
    |

ANN201 Missing return type annotation for public function `main`
   --> src\core\annex.py:212:5
    |
210 | # ==============================================================================
211 |
212 | def main():
    |     ^^^^
213 |     """Command-line entry point for the Annexation Protocol."""
214 |     from src.core.ui import HUD
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\core\annex.py:218:1
    |
216 |         HUD.log("WARN", "Usage: annex.py --scan [ROOT]")
217 |         sys.exit(1)
218 |         
    | ^^^^^^^^
219 |     cmd = sys.argv[1]
220 |     if cmd == "--scan":
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\core\annex.py:227:11
    |
226 | if __name__ == "__main__":
227 |     main()
    |           ^
    |
help: Add trailing newline

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src\core\cstar_dispatcher.py:5:1
  |
3 | import sys
4 | from pathlib import Path
5 | from typing import Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | # Bootstrap
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src\core\cstar_dispatcher.py:5:1
  |
3 | import sys
4 | from pathlib import Path
5 | from typing import Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | # Bootstrap
  |

E402 Module level import not at top of file
  --> src\core\cstar_dispatcher.py:12:1
   |
10 | bootstrap()
11 |
12 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | class CorvusDispatcher:
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\core\cstar_dispatcher.py:12:1
   |
10 | bootstrap()
11 |
12 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | class CorvusDispatcher:
   |
help: Organize imports

UP045 [*] Use `X | None` for type annotations
  --> src\core\cstar_dispatcher.py:18:30
   |
16 |     Main CLI Dispatcher for the Corvus Star framework.
17 |     """
18 |     def __init__(self, root: Optional[Path] = None) -> None:
   |                              ^^^^^^^^^^^^^^
19 |         self.project_root = root or PROJECT_ROOT
20 |         self.venv_python = self.project_root / ".venv" / "Scripts" / "python.exe"
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\cstar_dispatcher.py:29:32
   |
27 |         HUD.PERSONA = (self.config.get("persona") or "ALFRED").upper()
28 |
29 |     def _discover_all(self) -> Dict[str, str]:
   |                                ^^^^
30 |         """Scans all dynamic locations for available commands."""
31 |         commands = {}
   |
help: Replace with `dict`

E501 Line too long (101 > 100)
  --> src\core\cstar_dispatcher.py:64:101
   |
62 |         commands = self._discover_all()
63 |         scripts = sorted(c for c, p in commands.items() if p.endswith(".py"))
64 |         workflows = sorted(c for c, p in commands.items() if p.endswith(".md") or p.endswith(".qmd"))
   |                                                                                                     ^
65 |
66 |         if scripts:
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\core\cstar_dispatcher.py:76:25
   |
74 |         HUD.box_bottom()
75 |
76 |     def run(self, args: List[str]) -> None:
   |                         ^^^^
77 |         """Parses and dispatches the command dynamically."""
78 |         if not args:
   |
help: Replace with `list`

W293 [*] Blank line contains whitespace
   --> src\core\cstar_dispatcher.py:103:1
    |
101 |             if not set_persona_script.exists():
102 |                 set_persona_script = self.project_root / "scripts" / "set_persona.py"
103 |                 
    | ^^^^^^^^^^^^^^^^
104 |             env = os.environ.copy()
105 |             env["PYTHONPATH"] = str(self.project_root)
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\core\cstar_dispatcher.py:106:13
    |
104 |             env = os.environ.copy()
105 |             env["PYTHONPATH"] = str(self.project_root)
106 |             subprocess.run([str(self.venv_python), str(set_persona_script), persona], env=env)
    |             ^^^^^^^^^^^^^^
107 |             return
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\core\cstar_dispatcher.py:116:17
    |
114 |                 env = os.environ.copy()
115 |                 env["PYTHONPATH"] = str(self.project_root)
116 |                 subprocess.run([str(self.venv_python), cmd_path] + cmd_args, env=env)
    |                 ^^^^^^^^^^^^^^
117 |                 return
118 |             else: # Workflow
    |

RUF005 Consider `[str(self.venv_python), cmd_path, *cmd_args]` instead of concatenation
   --> src\core\cstar_dispatcher.py:116:32
    |
114 |                 env = os.environ.copy()
115 |                 env["PYTHONPATH"] = str(self.project_root)
116 |                 subprocess.run([str(self.venv_python), cmd_path] + cmd_args, env=env)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 |                 return
118 |             else: # Workflow
    |
help: Replace with `[str(self.venv_python), cmd_path, *cmd_args]`

S603 `subprocess` call: check for execution of untrusted input
   --> src\core\cstar_dispatcher.py:123:25
    |
121 |                 if shutil.which("quarto"):
122 |                     try:
123 |                         subprocess.run(["quarto", "render", cmd_path], check=True)
    |                         ^^^^^^^^^^^^^^
124 |                     except Exception as e:
125 |                          HUD.persona_log("FAIL", f"Workflow execution failed: {e}")
    |

S607 Starting a process with a partial executable path
   --> src\core\cstar_dispatcher.py:123:40
    |
121 |                 if shutil.which("quarto"):
122 |                     try:
123 |                         subprocess.run(["quarto", "render", cmd_path], check=True)
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |                     except Exception as e:
125 |                          HUD.persona_log("FAIL", f"Workflow execution failed: {e}")
    |

W292 [*] No newline at end of file
   --> src\core\cstar_dispatcher.py:141:11
    |
140 | if __name__ == "__main__":
141 |     main()
    |           ^
    |
help: Add trailing newline

F401 [*] `os` imported but unused
 --> src\core\edda.py:3:8
  |
1 | import argparse
2 | import ast
3 | import os
  |        ^^
4 | import re
5 | import shutil
  |
help: Remove unused import: `os`

F401 [*] `sys` imported but unused
 --> src\core\edda.py:6:8
  |
4 | import re
5 | import shutil
6 | import sys
  |        ^^^
7 | from datetime import datetime
8 | from pathlib import Path
  |
help: Remove unused import: `sys`

F401 [*] `datetime.datetime` imported but unused
 --> src\core\edda.py:7:22
  |
5 | import shutil
6 | import sys
7 | from datetime import datetime
  |                      ^^^^^^^^
8 | from pathlib import Path
9 | from typing import Optional
  |
help: Remove unused import: `datetime.datetime`

W293 [*] Blank line contains whitespace
  --> src\core\edda.py:33:1
   |
31 |         """Recursively scans for .md files and converts them to .qmd."""
32 |         HUD.persona_log("INFO", f"Scanning realm for documentation: {self.root}")
33 |         
   | ^^^^^^^^
34 |         candidates = []
35 |         for path in self.root.rglob("*.md"):
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\edda.py:56:1
   |
54 |         except ValueError:
55 |             return True
56 |             
   | ^^^^^^^^^^^^
57 |         # Pattern Check
58 |         for pattern in self.ignore_patterns:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\edda.py:76:1
   |
74 |         try:
75 |             content = source.read_text(encoding="utf-8")
76 |             
   | ^^^^^^^^^^^^
77 |             # 1. Harvest Metadata
78 |             title = self._extract_title(content) or source.stem.replace("-", " ").title()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\edda.py:79:1
   |
77 |             # 1. Harvest Metadata
78 |             title = self._extract_title(content) or source.stem.replace("-", " ").title()
79 |             
   | ^^^^^^^^^^^^
80 |             # 2. Forge Frontmatter
81 |             frontmatter = f"---\ntitle: {title}\nformat: html\n---\n\n"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\edda.py:82:1
   |
80 |             # 2. Forge Frontmatter
81 |             frontmatter = f"---\ntitle: {title}\nformat: html\n---\n\n"
82 |             
   | ^^^^^^^^^^^^
83 |             # 3. Transmute Content
84 |             new_content = self._convert_syntax(content)
   |
help: Remove whitespace from blank line

UP045 [*] Use `X | None` for type annotations
   --> src\core\edda.py:98:47
    |
 96 |             HUD.persona_log("ERROR", f"Failed to weave {source.name}: {e}")
 97 |
 98 |     def _extract_title(self, content: str) -> Optional[str]:
    |                                               ^^^^^^^^^^^^^
 99 |         """Extracts the first H1 header as title."""
100 |         match = re.search(r"^#\s+(.+)$", content, re.MULTILINE)
    |
help: Convert to `X | None`

ANN202 Missing return type annotation for private function `replace_alert`
   --> src\core\edda.py:105:13
    |
103 |     def _convert_syntax(self, content: str) -> str:
104 |         """Converts standard blockquotes to GitHub/Quarto Alerts."""
105 |         def replace_alert(match):
    |             ^^^^^^^^^^^^^
106 |             body = match.group(1).strip()
    |
help: Add return type annotation: `str`

ANN001 Missing type annotation for function argument `match`
   --> src\core\edda.py:105:27
    |
103 |     def _convert_syntax(self, content: str) -> str:
104 |         """Converts standard blockquotes to GitHub/Quarto Alerts."""
105 |         def replace_alert(match):
    |                           ^^^^^
106 |             body = match.group(1).strip()
    |

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:107:1
    |
105 |         def replace_alert(match):
106 |             body = match.group(1).strip()
107 |             
    | ^^^^^^^^^^^^
108 |             # Detect explicit header types
109 |             header_match = re.match(r"^(Note|Warning|Important|Tip|Caution):\s*(.*)", body, re.IGNORECASE)
    |
help: Remove whitespace from blank line

E501 Line too long (106 > 100)
   --> src\core\edda.py:109:101
    |
108 |             # Detect explicit header types
109 |             header_match = re.match(r"^(Note|Warning|Important|Tip|Caution):\s*(.*)", body, re.IGNORECASE)
    |                                                                                                     ^^^^^^
110 |             if header_match:
111 |                 tag = header_match.group(1).upper()
    |

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:122:1
    |
120 |                 clean_body = re.sub(r"warning:\s*", "", body, flags=re.IGNORECASE).strip()
121 |                 return f"> [!WARNING]\n> {clean_body}"
122 |             
    | ^^^^^^^^^^^^
123 |             return f"> [!NOTE]\n> {body}"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:143:1
    |
141 |             tree = ast.parse(source_file.read_text(encoding="utf-8"))
142 |             docs = []
143 |             
    | ^^^^^^^^^^^^
144 |             docs.append(f"# API Reference: {source_file.stem}\n")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:145:1
    |
144 |             docs.append(f"# API Reference: {source_file.stem}\n")
145 |             
    | ^^^^^^^^^^^^
146 |             for node in ast.walk(tree):
147 |                 if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:153:1
    |
151 |                         docs.append(f"## {icon} `{node.name}`")
152 |                         docs.append(f"\n{docstring}\n")
153 |             
    | ^^^^^^^^^^^^
154 |             if len(docs) > 1:
155 |                 out_dir = self.root / "docs" / "reference"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:171:1
    |
169 |     parser.add_argument("--quarantine", help="Quarantine directory", default=".corvus_quarantine")
170 |     parser.add_argument("--synthesize", help="Generate API docs for source file")
171 |     
    | ^^^^
172 |     args = parser.parse_args()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:173:1
    |
172 |     args = parser.parse_args()
173 |     
    | ^^^^
174 |     if args.scan:
175 |         root = Path(args.scan).resolve()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\edda.py:178:1
    |
176 |         q_dir = root / args.quarantine
177 |         EddaWeaver(root, q_dir).scan_and_transmute()
178 |         
    | ^^^^^^^^
179 |     elif args.target:
180 |         target = Path(args.target).resolve()
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\core\edda.py:192:11
    |
191 | if __name__ == "__main__":
192 |     main()
    |           ^
    |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\engine\alfred_observer.py:1:1
  |
1 | / import os
2 | | import time
  | |___________^
3 |
4 |   class AlfredOverwatch:
  |
help: Organize imports

E501 Line too long (139 > 100)
  --> src\core\engine\alfred_observer.py:9:101
   |
 7 | â€¦
 8 | â€¦
 9 | â€¦s there is a syntax error in {target_file}. Please check your braces and indentation."
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 | â€¦FoundError" in error_trace:
11 | â€¦dependency is missing in {target_file}. Verify the PYTHONPATH and internal imports."
   |

E501 Line too long (137 > 100)
  --> src\core\engine\alfred_observer.py:11:101
   |
 9 | â€¦rs there is a syntax error in {target_file}. Please check your braces and indentation."
10 | â€¦tFoundError" in error_trace:
11 | â€¦ dependency is missing in {target_file}. Verify the PYTHONPATH and internal imports."
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 | â€¦
13 | â€¦mplementation in {target_file} fails its contract. The logic does not match the expected state."
   |

E501 Line too long (148 > 100)
  --> src\core\engine\alfred_observer.py:13:101
   |
11 | â€¦dency is missing in {target_file}. Verify the PYTHONPATH and internal imports."
12 | â€¦
13 | â€¦ntation in {target_file} fails its contract. The logic does not match the expected state."
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 | â€¦
15 | â€¦ation for {target_file} was terminated by the user. Scaling back the computational workload."
   |

E501 Line too long (151 > 100)
  --> src\core\engine\alfred_observer.py:15:101
   |
13 | â€¦tation in {target_file} fails its contract. The logic does not match the expected state."
14 | â€¦
15 | â€¦tion for {target_file} was terminated by the user. Scaling back the computational workload."
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 | â€¦
17 | â€¦target_file} timed out. Logic may be inefficient or deadlocked."
   |

E501 Line too long (123 > 100)
  --> src\core\engine\alfred_observer.py:17:101
   |
15 | â€¦         return "KeyboardInterrupt", f"ALFRED: The operation for {target_file} was terminated by the user. Scaling back the computatiâ€¦
16 | â€¦     if "Timeout" in error_trace:
17 | â€¦         return "Timeout", f"ALFRED: The operation for {target_file} timed out. Logic may be inefficient or deadlocked."
   |                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^
18 | â€¦         
19 | â€¦     return "UnknownError", f"ALFRED: An unexpected error occurred in {target_file}. Trace analysis suggests careful review of recentâ€¦
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\alfred_observer.py:18:1
   |
16 | â€¦     if "Timeout" in error_trace:
17 | â€¦         return "Timeout", f"ALFRED: The operation for {target_file} timed out. Logic may be inefficient or deadlocked."
18 | â€¦         
   ^^^^^^^^^^^^
19 | â€¦     return "UnknownError", f"ALFRED: An unexpected error occurred in {target_file}. Trace analysis suggests careful review of recentâ€¦
   |
help: Remove whitespace from blank line

E501 Line too long (151 > 100)
  --> src\core\engine\alfred_observer.py:19:101
   |
17 | â€¦target_file} timed out. Logic may be inefficient or deadlocked."
18 | â€¦
19 | â€¦r occurred in {target_file}. Trace analysis suggests careful review of recent permutations."
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 | â€¦
21 | â€¦str = ".agent/ALFRED_SUGGESTIONS.md"):
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\alfred_observer.py:20:1
   |
19 |         return "UnknownError", f"ALFRED: An unexpected error occurred in {target_file}. Trace analysis suggests careful review of receâ€¦
20 |         
   | ^^^^^^^^
21 |     def write_suggestion(self, suggestion: str, file_path: str = ".agent/ALFRED_SUGGESTIONS.md"):
22 |         """Writes the guidance so the agent can read it on the next loop."""
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `write_suggestion`
  --> src\core\engine\alfred_observer.py:21:9
   |
19 |         return "UnknownError", f"ALFRED: An unexpected error occurred in {target_file}. Trace analysis suggests careful review of receâ€¦
20 |         
21 |     def write_suggestion(self, suggestion: str, file_path: str = ".agent/ALFRED_SUGGESTIONS.md"):
   |         ^^^^^^^^^^^^^^^^
22 |         """Writes the guidance so the agent can read it on the next loop."""
23 |         os.makedirs(os.path.dirname(file_path), exist_ok=True)
   |
help: Add return type annotation: `None`

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
  --> src\core\engine\alfred_observer.py:23:9
   |
21 |     def write_suggestion(self, suggestion: str, file_path: str = ".agent/ALFRED_SUGGESTIONS.md"):
22 |         """Writes the guidance so the agent can read it on the next loop."""
23 |         os.makedirs(os.path.dirname(file_path), exist_ok=True)
   |         ^^^^^^^^^^^
24 |         timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
25 |         with open(file_path, "a", encoding="utf-8") as f:
   |
help: Replace with `Path(...).mkdir(parents=True)`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\core\engine\alfred_observer.py:23:21
   |
21 |     def write_suggestion(self, suggestion: str, file_path: str = ".agent/ALFRED_SUGGESTIONS.md"):
22 |         """Writes the guidance so the agent can read it on the next loop."""
23 |         os.makedirs(os.path.dirname(file_path), exist_ok=True)
   |                     ^^^^^^^^^^^^^^^
24 |         timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
25 |         with open(file_path, "a", encoding="utf-8") as f:
   |
help: Replace with `Path(...).parent`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\engine\alfred_observer.py:25:14
   |
23 |         os.makedirs(os.path.dirname(file_path), exist_ok=True)
24 |         timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
25 |         with open(file_path, "a", encoding="utf-8") as f:
   |              ^^^^
26 |             f.write(f"\n## {timestamp}\n{suggestion}\n")
   |
help: Replace with `Path.open()`

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\engine\atomic_gpt.py:1:1
  |
1 | / import math
2 | | import random
3 | | import pickle
  | |_____________^
  |
help: Organize imports

F401 [*] `math` imported but unused
 --> src\core\engine\atomic_gpt.py:1:8
  |
1 | import math
  |        ^^^^
2 | import random
3 | import pickle
  |
help: Remove unused import: `math`

ANN001 Missing type annotation for function argument `data`
  --> src\core\engine\atomic_gpt.py:8:24
   |
 6 | class Value:
 7 |     """Autograd engine for local backpropagation. Inspired by micrograd."""
 8 |     def __init__(self, data, _children=(), _op='') -> None:
   |                        ^^^^
 9 |         self.data = data
10 |         self.grad = 0
   |

ANN001 Missing type annotation for function argument `_children`
  --> src\core\engine\atomic_gpt.py:8:30
   |
 6 | class Value:
 7 |     """Autograd engine for local backpropagation. Inspired by micrograd."""
 8 |     def __init__(self, data, _children=(), _op='') -> None:
   |                              ^^^^^^^^^
 9 |         self.data = data
10 |         self.grad = 0
   |

ANN001 Missing type annotation for function argument `_op`
  --> src\core\engine\atomic_gpt.py:8:44
   |
 6 | class Value:
 7 |     """Autograd engine for local backpropagation. Inspired by micrograd."""
 8 |     def __init__(self, data, _children=(), _op='') -> None:
   |                                            ^^^
 9 |         self.data = data
10 |         self.grad = 0
   |

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:18:23
   |
16 |         return f"Value(data={self.data}, grad={self.grad})"
17 |
18 |     def __add__(self, other):
   |                       ^^^^^
19 |         other = other if isinstance(other, Value) else Value(other)
20 |         out = Value(self.data + other.data, (self, other), '+')
   |

ANN202 Missing return type annotation for private function `_backward`
  --> src\core\engine\atomic_gpt.py:21:13
   |
19 |         other = other if isinstance(other, Value) else Value(other)
20 |         out = Value(self.data + other.data, (self, other), '+')
21 |         def _backward():
   |             ^^^^^^^^^
22 |             self.grad += out.grad
23 |             other.grad += out.grad
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:27:23
   |
25 |         return out
26 |
27 |     def __mul__(self, other):
   |                       ^^^^^
28 |         other = other if isinstance(other, Value) else Value(other)
29 |         out = Value(self.data * other.data, (self, other), '*')
   |

ANN202 Missing return type annotation for private function `_backward`
  --> src\core\engine\atomic_gpt.py:30:13
   |
28 |         other = other if isinstance(other, Value) else Value(other)
29 |         out = Value(self.data * other.data, (self, other), '*')
30 |         def _backward():
   |             ^^^^^^^^^
31 |             self.grad += other.data * out.grad
32 |             other.grad += self.data * out.grad
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:36:23
   |
34 |         return out
35 |
36 |     def __pow__(self, other):
   |                       ^^^^^
37 |         assert isinstance(other, (int, float))
38 |         out = Value(self.data**other, (self,), f'**{other}')
   |

S101 Use of `assert` detected
  --> src\core\engine\atomic_gpt.py:37:9
   |
36 |     def __pow__(self, other):
37 |         assert isinstance(other, (int, float))
   |         ^^^^^^
38 |         out = Value(self.data**other, (self,), f'**{other}')
39 |         def _backward():
   |

ANN202 Missing return type annotation for private function `_backward`
  --> src\core\engine\atomic_gpt.py:39:13
   |
37 |         assert isinstance(other, (int, float))
38 |         out = Value(self.data**other, (self,), f'**{other}')
39 |         def _backward():
   |             ^^^^^^^^^
40 |             self.grad += (other * self.data**(other-1)) * out.grad
41 |         out._backward = _backward
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `relu`
  --> src\core\engine\atomic_gpt.py:44:9
   |
42 |         return out
43 |
44 |     def relu(self):
   |         ^^^^
45 |         out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')
46 |         def _backward():
   |
help: Add return type annotation

ANN202 Missing return type annotation for private function `_backward`
  --> src\core\engine\atomic_gpt.py:46:13
   |
44 |     def relu(self):
45 |         out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')
46 |         def _backward():
   |             ^^^^^^^^^
47 |             self.grad += (out.data > 0) * out.grad
48 |         out._backward = _backward
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `backward`
  --> src\core\engine\atomic_gpt.py:51:9
   |
49 |         return out
50 |
51 |     def backward(self):
   |         ^^^^^^^^
52 |         topo = []
53 |         visited = set()
   |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `build_topo`
  --> src\core\engine\atomic_gpt.py:54:13
   |
52 |         topo = []
53 |         visited = set()
54 |         def build_topo(v):
   |             ^^^^^^^^^^
55 |             if v not in visited:
56 |                 visited.add(v)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `v`
  --> src\core\engine\atomic_gpt.py:54:24
   |
52 |         topo = []
53 |         visited = set()
54 |         def build_topo(v):
   |                        ^
55 |             if v not in visited:
56 |                 visited.add(v)
   |

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:66:23
   |
65 |     def __neg__(self): return self * -1
66 |     def __sub__(self, other): return self + (-other)
   |                       ^^^^^
67 |     def __radd__(self, other): return self + other
68 |     def __rmul__(self, other): return self * other
   |

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:67:24
   |
65 |     def __neg__(self): return self * -1
66 |     def __sub__(self, other): return self + (-other)
67 |     def __radd__(self, other): return self + other
   |                        ^^^^^
68 |     def __rmul__(self, other): return self * other
69 |     def __truediv__(self, other): return self * other**-1
   |

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:68:24
   |
66 |     def __sub__(self, other): return self + (-other)
67 |     def __radd__(self, other): return self + other
68 |     def __rmul__(self, other): return self * other
   |                        ^^^^^
69 |     def __truediv__(self, other): return self * other**-1
   |

ANN001 Missing type annotation for function argument `other`
  --> src\core\engine\atomic_gpt.py:69:27
   |
67 |     def __radd__(self, other): return self + other
68 |     def __rmul__(self, other): return self * other
69 |     def __truediv__(self, other): return self * other**-1
   |                           ^^^^^
70 |
71 | class Module:
   |

ANN201 Missing return type annotation for public function `zero_grad`
  --> src\core\engine\atomic_gpt.py:72:9
   |
71 | class Module:
72 |     def zero_grad(self):
   |         ^^^^^^^^^
73 |         for p in self.parameters():
74 |             p.grad = 0
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `parameters`
  --> src\core\engine\atomic_gpt.py:75:9
   |
73 |         for p in self.parameters():
74 |             p.grad = 0
75 |     def parameters(self):
   |         ^^^^^^^^^^
76 |         return []
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `nin`
  --> src\core\engine\atomic_gpt.py:79:24
   |
78 | class Neuron(Module):
79 |     def __init__(self, nin, nonlin=True) -> None:
   |                        ^^^
80 |         self.w = [Value(random.uniform(-1, 1)) for _ in range(nin)]
81 |         self.b = Value(0)
   |

ANN001 Missing type annotation for function argument `nonlin`
  --> src\core\engine\atomic_gpt.py:79:29
   |
78 | class Neuron(Module):
79 |     def __init__(self, nin, nonlin=True) -> None:
   |                             ^^^^^^
80 |         self.w = [Value(random.uniform(-1, 1)) for _ in range(nin)]
81 |         self.b = Value(0)
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\core\engine\atomic_gpt.py:80:25
   |
78 | class Neuron(Module):
79 |     def __init__(self, nin, nonlin=True) -> None:
80 |         self.w = [Value(random.uniform(-1, 1)) for _ in range(nin)]
   |                         ^^^^^^^^^^^^^^^^^^^^^
81 |         self.b = Value(0)
82 |         self.nonlin = nonlin
   |

ANN001 Missing type annotation for function argument `x`
  --> src\core\engine\atomic_gpt.py:83:24
   |
81 |         self.b = Value(0)
82 |         self.nonlin = nonlin
83 |     def __call__(self, x):
   |                        ^
84 |         act = sum((wi*xi for wi, xi in zip(self.w, x)), self.b)
85 |         return act.relu() if self.nonlin else act
   |

B905 `zip()` without an explicit `strict=` parameter
  --> src\core\engine\atomic_gpt.py:84:40
   |
82 |         self.nonlin = nonlin
83 |     def __call__(self, x):
84 |         act = sum((wi*xi for wi, xi in zip(self.w, x)), self.b)
   |                                        ^^^^^^^^^^^^^^
85 |         return act.relu() if self.nonlin else act
86 |     def parameters(self):
   |
help: Add explicit value for parameter `strict=`

ANN201 Missing return type annotation for public function `parameters`
  --> src\core\engine\atomic_gpt.py:86:9
   |
84 |         act = sum((wi*xi for wi, xi in zip(self.w, x)), self.b)
85 |         return act.relu() if self.nonlin else act
86 |     def parameters(self):
   |         ^^^^^^^^^^
87 |         return self.w + [self.b]
   |
help: Add return type annotation

RUF005 Consider `[*self.w, self.b]` instead of concatenation
  --> src\core\engine\atomic_gpt.py:87:16
   |
85 |         return act.relu() if self.nonlin else act
86 |     def parameters(self):
87 |         return self.w + [self.b]
   |                ^^^^^^^^^^^^^^^^^
88 |
89 | class Layer(Module):
   |
help: Replace with `[*self.w, self.b]`

ANN001 Missing type annotation for function argument `nin`
  --> src\core\engine\atomic_gpt.py:90:24
   |
89 | class Layer(Module):
90 |     def __init__(self, nin, nout, **kwargs) -> None:
   |                        ^^^
91 |         self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]
92 |     def __call__(self, x):
   |

ANN001 Missing type annotation for function argument `nout`
  --> src\core\engine\atomic_gpt.py:90:29
   |
89 | class Layer(Module):
90 |     def __init__(self, nin, nout, **kwargs) -> None:
   |                             ^^^^
91 |         self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]
92 |     def __call__(self, x):
   |

ANN003 Missing type annotation for `**kwargs`
  --> src\core\engine\atomic_gpt.py:90:35
   |
89 | class Layer(Module):
90 |     def __init__(self, nin, nout, **kwargs) -> None:
   |                                   ^^^^^^^^
91 |         self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]
92 |     def __call__(self, x):
   |

ANN001 Missing type annotation for function argument `x`
  --> src\core\engine\atomic_gpt.py:92:24
   |
90 |     def __init__(self, nin, nout, **kwargs) -> None:
91 |         self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]
92 |     def __call__(self, x):
   |                        ^
93 |         out = [n(x) for n in self.neurons]
94 |         return out[0] if len(out) == 1 else out
   |

ANN201 Missing return type annotation for public function `parameters`
  --> src\core\engine\atomic_gpt.py:95:9
   |
93 |         out = [n(x) for n in self.neurons]
94 |         return out[0] if len(out) == 1 else out
95 |     def parameters(self):
   |         ^^^^^^^^^^
96 |         return [p for n in self.neurons for p in n.parameters()]
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `nin`
   --> src\core\engine\atomic_gpt.py:99:24
    |
 98 | class MLP(Module):
 99 |     def __init__(self, nin, nouts) -> None:
    |                        ^^^
100 |         sz = [nin] + nouts
101 |         self.layers = [Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1) for i in range(len(nouts))]
    |

ANN001 Missing type annotation for function argument `nouts`
   --> src\core\engine\atomic_gpt.py:99:29
    |
 98 | class MLP(Module):
 99 |     def __init__(self, nin, nouts) -> None:
    |                             ^^^^^
100 |         sz = [nin] + nouts
101 |         self.layers = [Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1) for i in range(len(nouts))]
    |

RUF005 Consider `[nin, *nouts]` instead of concatenation
   --> src\core\engine\atomic_gpt.py:100:14
    |
 98 | class MLP(Module):
 99 |     def __init__(self, nin, nouts) -> None:
100 |         sz = [nin] + nouts
    |              ^^^^^^^^^^^^^
101 |         self.layers = [Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1) for i in range(len(nouts))]
102 |     def __call__(self, x):
    |
help: Replace with `[nin, *nouts]`

ANN001 Missing type annotation for function argument `x`
   --> src\core\engine\atomic_gpt.py:102:24
    |
100 |         sz = [nin] + nouts
101 |         self.layers = [Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1) for i in range(len(nouts))]
102 |     def __call__(self, x):
    |                        ^
103 |         for layer in self.layers:
104 |             x = layer(x)
    |

ANN201 Missing return type annotation for public function `parameters`
   --> src\core\engine\atomic_gpt.py:106:9
    |
104 |             x = layer(x)
105 |         return x
106 |     def parameters(self):
    |         ^^^^^^^^^^
107 |         return [p for layer in self.layers for p in layer.parameters()]
    |
help: Add return type annotation

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   --> src\core\engine\atomic_gpt.py:119:28
    |
117 |         self.embed_dim = embed_dim
118 |         # Token embeddings
119 |         self.wte = [[Value(random.uniform(-1, 1)) for _ in range(embed_dim)] for _ in range(vocab_size)]
    |                            ^^^^^^^^^^^^^^^^^^^^^
120 |         # Simple MLP to process embeddings (replacing full transformer blocks for standard library constraints)
121 |         self.mlp = MLP(embed_dim, [16, vocab_size])
    |

E501 Line too long (104 > 100)
   --> src\core\engine\atomic_gpt.py:119:101
    |
117 |         self.embed_dim = embed_dim
118 |         # Token embeddings
119 |         self.wte = [[Value(random.uniform(-1, 1)) for _ in range(embed_dim)] for _ in range(vocab_size)]
    |                                                                                                     ^^^^
120 |         # Simple MLP to process embeddings (replacing full transformer blocks for standard library constraints)
121 |         self.mlp = MLP(embed_dim, [16, vocab_size])
    |

E501 Line too long (111 > 100)
   --> src\core\engine\atomic_gpt.py:120:101
    |
118 |         # Token embeddings
119 |         self.wte = [[Value(random.uniform(-1, 1)) for _ in range(embed_dim)] for _ in range(vocab_size)]
120 |         # Simple MLP to process embeddings (replacing full transformer blocks for standard library constraints)
    |                                                                                                     ^^^^^^^^^^^
121 |         self.mlp = MLP(embed_dim, [16, vocab_size])
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:122:1
    |
120 |         # Simple MLP to process embeddings (replacing full transformer blocks for standard library constraints)
121 |         self.mlp = MLP(embed_dim, [16, vocab_size])
122 |         
    | ^^^^^^^^
123 |     def forward(self, input_tokens: list[int]) -> list[list[Value]]:
124 |         """Forward pass generating logits for each token."""
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:131:1
    |
129 |             all_logits.append(logits)
130 |         return all_logits
131 |         
    | ^^^^^^^^
132 |     def backward(self, loss: Value):
133 |         """Trigger backpropagation."""
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `backward`
   --> src\core\engine\atomic_gpt.py:132:9
    |
130 |         return all_logits
131 |         
132 |     def backward(self, loss: Value):
    |         ^^^^^^^^
133 |         """Trigger backpropagation."""
134 |         loss.backward()
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:135:1
    |
133 |         """Trigger backpropagation."""
134 |         loss.backward()
135 |         
    | ^^^^^^^^
136 |     def calculate_project_loss(self, text_corpus: str) -> float:
137 |         """
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:143:1
    |
141 |         if not text_corpus:
142 |             return 100.0
143 |             
    | ^^^^^^^^^^^^
144 |         # Convert text to tokens (bytes for simplicity)
145 |         tokens = [b for b in text_corpus.encode('utf-8')]
    |
help: Remove whitespace from blank line

C416 Unnecessary list comprehension (rewrite using `list()`)
   --> src\core\engine\atomic_gpt.py:145:18
    |
144 |         # Convert text to tokens (bytes for simplicity)
145 |         tokens = [b for b in text_corpus.encode('utf-8')]
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
146 |         if len(tokens) > 128: # Limit for performance
147 |             tokens = tokens[:128]
    |
help: Rewrite using `list()`

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:148:1
    |
146 |         if len(tokens) > 128: # Limit for performance
147 |             tokens = tokens[:128]
148 |             
    | ^^^^^^^^^^^^
149 |         logits_list = self.forward(tokens[:-1])
150 |         targets = tokens[1:]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:151:1
    |
149 |         logits_list = self.forward(tokens[:-1])
150 |         targets = tokens[1:]
151 |         
    | ^^^^^^^^
152 |         total_loss = Value(0)
153 |         for logits, target in zip(logits_list, targets):
    |
help: Remove whitespace from blank line

B905 `zip()` without an explicit `strict=` parameter
   --> src\core\engine\atomic_gpt.py:153:31
    |
152 |         total_loss = Value(0)
153 |         for logits, target in zip(logits_list, targets):
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^
154 |             # Simplified Softmax + Cross Entropy
155 |             # loss = -log(exp(logits[target]) / sum(exp(logits)))
    |
help: Add explicit value for parameter `strict=`

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:160:1
    |
158 |             target_idx = target % self.vocab_size
159 |             total_loss += (logits[target_idx] - 1.0)**2
160 |             
    | ^^^^^^^^^^^^
161 |         return total_loss.data / len(targets) if targets else 0.0
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `parameters`
   --> src\core\engine\atomic_gpt.py:163:9
    |
161 |         return total_loss.data / len(targets) if targets else 0.0
162 |
163 |     def parameters(self):
    |         ^^^^^^^^^^
164 |         return [p for row in self.wte for p in row] + self.mlp.parameters()
    |
help: Add return type annotation

ANN201 Missing return type annotation for public function `save_weights`
   --> src\core\engine\atomic_gpt.py:166:9
    |
164 |         return [p for row in self.wte for p in row] + self.mlp.parameters()
165 |
166 |     def save_weights(self, filepath: str):
    |         ^^^^^^^^^^^^
167 |         """Persists the neural weights to disk."""
168 |         data = {
    |
help: Add return type annotation: `None`

E501 Line too long (107 > 100)
   --> src\core\engine\atomic_gpt.py:170:101
    |
168 |         data = {
169 |             'wte': [[p.data for p in row] for row in self.wte],
170 |             'mlp': [[p.data for p in n.w] + [n.b.data] for layer in self.mlp.layers for n in layer.neurons]
    |                                                                                                     ^^^^^^^
171 |         }
172 |         with open(filepath, 'wb') as f:
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\engine\atomic_gpt.py:172:14
    |
170 |             'mlp': [[p.data for p in n.w] + [n.b.data] for layer in self.mlp.layers for n in layer.neurons]
171 |         }
172 |         with open(filepath, 'wb') as f:
    |              ^^^^
173 |             pickle.dump(data, f)
    |
help: Replace with `Path.open()`

ANN201 Missing return type annotation for public function `load_weights`
   --> src\core\engine\atomic_gpt.py:175:9
    |
173 |             pickle.dump(data, f)
174 |
175 |     def load_weights(self, filepath: str):
    |         ^^^^^^^^^^^^
176 |         """Loads neural weights from disk."""
177 |         try:
    |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\engine\atomic_gpt.py:178:18
    |
176 |         """Loads neural weights from disk."""
177 |         try:
178 |             with open(filepath, 'rb') as f:
    |                  ^^^^
179 |                 data = pickle.load(f)
    |
help: Replace with `Path.open()`

S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
   --> src\core\engine\atomic_gpt.py:179:24
    |
177 |         try:
178 |             with open(filepath, 'rb') as f:
179 |                 data = pickle.load(f)
    |                        ^^^^^^^^^^^^^^
180 |             
181 |             # Load Embeddings
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:180:1
    |
178 |             with open(filepath, 'rb') as f:
179 |                 data = pickle.load(f)
180 |             
    | ^^^^^^^^^^^^
181 |             # Load Embeddings
182 |             for i, row in enumerate(data.get('wte', [])):
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:187:1
    |
185 |                         if j < len(self.wte[i]):
186 |                             self.wte[i][j].data = val
187 |             
    | ^^^^^^^^^^^^
188 |             # Load MLP (Simplified structure matching)
189 |             # This assumes architecture hasn't changed. 
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\engine\atomic_gpt.py:189:56
    |
188 |             # Load MLP (Simplified structure matching)
189 |             # This assumes architecture hasn't changed. 
    |                                                        ^
190 |             # For a robust implementation, we'd traverse the structure more carefully.
191 |             flat_params = []
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:196:1
    |
194 |                     flat_params.extend(n.w)
195 |                     flat_params.append(n.b)
196 |             
    | ^^^^^^^^^^^^
197 |             saved_params = [p for n_list in data.get('mlp', []) for p in n_list]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:198:1
    |
197 |             saved_params = [p for n_list in data.get('mlp', []) for p in n_list]
198 |             
    | ^^^^^^^^^^^^
199 |             for p, val in zip(flat_params, saved_params):
200 |                 p.data = val
    |
help: Remove whitespace from blank line

B905 `zip()` without an explicit `strict=` parameter
   --> src\core\engine\atomic_gpt.py:199:27
    |
197 |             saved_params = [p for n_list in data.get('mlp', []) for p in n_list]
198 |             
199 |             for p, val in zip(flat_params, saved_params):
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
200 |                 p.data = val
    |
help: Add explicit value for parameter `strict=`

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:201:1
    |
199 |             for p, val in zip(flat_params, saved_params):
200 |                 p.data = val
201 |                 
    | ^^^^^^^^^^^^^^^^
202 |         except (FileNotFoundError, pickle.UnpicklingError):
203 |             pass # Start fresh if load fails
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `train_step`
   --> src\core\engine\atomic_gpt.py:205:9
    |
203 |             pass # Start fresh if load fails
204 |
205 |     def train_step(self, text_corpus: str, learning_rate: float = 0.01):
    |         ^^^^^^^^^^
206 |         """Perform one training step."""
207 |         tokens = [b for b in text_corpus.encode('utf-8')]
    |
help: Add return type annotation

C416 Unnecessary list comprehension (rewrite using `list()`)
   --> src\core\engine\atomic_gpt.py:207:18
    |
205 |     def train_step(self, text_corpus: str, learning_rate: float = 0.01):
206 |         """Perform one training step."""
207 |         tokens = [b for b in text_corpus.encode('utf-8')]
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
208 |         if len(tokens) > 64:
209 |             start = random.randint(0, len(tokens) - 65)
    |
help: Rewrite using `list()`

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   --> src\core\engine\atomic_gpt.py:209:21
    |
207 |         tokens = [b for b in text_corpus.encode('utf-8')]
208 |         if len(tokens) > 64:
209 |             start = random.randint(0, len(tokens) - 65)
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |             tokens = tokens[start:start+64]
211 |         if len(tokens) < 2: return
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\atomic_gpt.py:211:27
    |
209 |             start = random.randint(0, len(tokens) - 65)
210 |             tokens = tokens[start:start+64]
211 |         if len(tokens) < 2: return
    |                           ^
212 |         
213 |         logits_list = self.forward(tokens[:-1])
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:212:1
    |
210 |             tokens = tokens[start:start+64]
211 |         if len(tokens) < 2: return
212 |         
    | ^^^^^^^^
213 |         logits_list = self.forward(tokens[:-1])
214 |         targets = tokens[1:]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:215:1
    |
213 |         logits_list = self.forward(tokens[:-1])
214 |         targets = tokens[1:]
215 |         
    | ^^^^^^^^
216 |         loss = Value(0)
217 |         for logits, target in zip(logits_list, targets):
    |
help: Remove whitespace from blank line

B905 `zip()` without an explicit `strict=` parameter
   --> src\core\engine\atomic_gpt.py:217:31
    |
216 |         loss = Value(0)
217 |         for logits, target in zip(logits_list, targets):
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^
218 |             target_idx = target % self.vocab_size
219 |             loss += (logits[target_idx] - 1.0)**2
    |
help: Add explicit value for parameter `strict=`

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:220:1
    |
218 |             target_idx = target % self.vocab_size
219 |             loss += (logits[target_idx] - 1.0)**2
220 |             
    | ^^^^^^^^^^^^
221 |         for p in self.parameters():
222 |             p.grad = 0
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:224:1
    |
222 |             p.grad = 0
223 |         loss.backward()
224 |         
    | ^^^^^^^^
225 |         for p in self.parameters():
226 |             # Gradient clipping to prevent explosion
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\atomic_gpt.py:227:26
    |
225 |         for p in self.parameters():
226 |             # Gradient clipping to prevent explosion
227 |             if p.grad > 1: p.grad = 1
    |                          ^
228 |             if p.grad < -1: p.grad = -1
229 |             p.data -= learning_rate * p.grad
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\atomic_gpt.py:228:27
    |
226 |             # Gradient clipping to prevent explosion
227 |             if p.grad > 1: p.grad = 1
228 |             if p.grad < -1: p.grad = -1
    |                           ^
229 |             p.data -= learning_rate * p.grad
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:230:1
    |
228 |             if p.grad < -1: p.grad = -1
229 |             p.data -= learning_rate * p.grad
230 |         
    | ^^^^^^^^
231 |         return loss.data
    |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
   --> src\core\engine\atomic_gpt.py:234:5
    |
233 |   if __name__ == "__main__":
234 | /     import sys
235 | |     import os
    | |_____________^
236 |       
237 |       # Simple CLI for training
    |
help: Organize imports

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:236:1
    |
234 |     import sys
235 |     import os
236 |     
    | ^^^^
237 |     # Simple CLI for training
238 |     if len(sys.argv) > 1 and sys.argv[1] == "--train":
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:242:1
    |
240 |         if len(sys.argv) > 2:
241 |             steps = int(sys.argv[2])
242 |             
    | ^^^^^^^^^^^^
243 |         print(f"ALFRED: Initiating AtomicCortex training loop ({steps} steps)...")
244 |         cortex = AtomicCortex()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:245:1
    |
243 |         print(f"ALFRED: Initiating AtomicCortex training loop ({steps} steps)...")
244 |         cortex = AtomicCortex()
245 |         
    | ^^^^^^^^
246 |         # Collect codebase text
247 |         corpus = ""
    |
help: Remove whitespace from blank line

B007 Loop control variable `dirs` not used within loop body
   --> src\core\engine\atomic_gpt.py:248:19
    |
246 |         # Collect codebase text
247 |         corpus = ""
248 |         for root, dirs, files in os.walk("src"):
    |                   ^^^^
249 |             for file in files:
250 |                 if file.endswith(".py"):
    |
help: Rename unused `dirs` to `_dirs`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\engine\atomic_gpt.py:252:30
    |
250 |                 if file.endswith(".py"):
251 |                     try:
252 |                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
    |                              ^^^^
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
    |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\core\engine\atomic_gpt.py:252:35
    |
250 |                 if file.endswith(".py"):
251 |                     try:
252 |                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
    |                                   ^^^^^^^^^^^^
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
    |

UP015 [*] Unnecessary mode argument
   --> src\core\engine\atomic_gpt.py:252:61
    |
250 |                 if file.endswith(".py"):
251 |                     try:
252 |                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
    |                                                             ^^^
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
    |
help: Remove mode argument

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\engine\atomic_gpt.py:254:21
    |
252 |                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
    |                     ^^^^^^^^^^^^^^^^^^^^^^
255 |         
256 |         if not corpus:
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\atomic_gpt.py:254:37
    |
252 |                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
    |                                     ^
255 |         
256 |         if not corpus:
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:255:1
    |
253 |                             corpus += f.read() + "\n"
254 |                     except Exception: pass
255 |         
    | ^^^^^^^^
256 |         if not corpus:
257 |             print("ALFRED: Training corpus is empty. Aborting.")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:259:1
    |
257 |             print("ALFRED: Training corpus is empty. Aborting.")
258 |             sys.exit(0)
259 |             
    | ^^^^^^^^^^^^
260 |         for i in range(steps):
261 |             loss = cortex.train_step(corpus)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\atomic_gpt.py:264:1
    |
262 |             if i % 50 == 0:
263 |                 print(f"Step {i}: Loss {loss:.4f}")
264 |                 
    | ^^^^^^^^^^^^^^^^
265 |         print("ALFRED: Training complete. Neural weights evolved.")
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\core\engine\atomic_gpt.py:265:68
    |
263 |                 print(f"Step {i}: Loss {loss:.4f}")
264 |                 
265 |         print("ALFRED: Training complete. Neural weights evolved.")
    |                                                                    ^
    |
help: Add trailing newline

F401 [*] `os` imported but unused
 --> src\core\engine\cortex.py:1:8
  |
1 | import os
  |        ^^
2 | import re
3 | from pathlib import Path
  |
help: Remove unused import: `os`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src\core\engine\cortex.py:4:1
  |
2 | import re
3 | from pathlib import Path
4 | from typing import Any, Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |
6 | from src.core.engine.vector import SovereignVector
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src\core\engine\cortex.py:4:1
  |
2 | import re
3 | from pathlib import Path
4 | from typing import Any, Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |
6 | from src.core.engine.vector import SovereignVector
  |

E501 Line too long (106 > 100)
  --> src\core\engine\cortex.py:18:101
   |
16 |         self.base_path = Path(base_path)
17 |         # Initialize a fresh brain for knowledge (separate from skills)
18 |         self.brain = SovereignVector(stopwords_path=self.project_root / "src" / "data" / "stopwords.json")
   |                                                                                                     ^^^^^^
19 |         
20 |         # Knowledge Sources - [ALFRED] Updated for Operation Yggdrasil docs structure
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:19:1
   |
17 |         # Initialize a fresh brain for knowledge (separate from skills)
18 |         self.brain = SovereignVector(stopwords_path=self.project_root / "src" / "data" / "stopwords.json")
19 |         
   | ^^^^^^^^
20 |         # Knowledge Sources - [ALFRED] Updated for Operation Yggdrasil docs structure
21 |         doc_targets: Dict[str, str] = {
   |
help: Remove whitespace from blank line

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\engine\cortex.py:21:22
   |
20 |         # Knowledge Sources - [ALFRED] Updated for Operation Yggdrasil docs structure
21 |         doc_targets: Dict[str, str] = {
   |                      ^^^^
22 |             "AGENTS": "AGENTS.qmd",
23 |             "wireframe": "docs/architecture/wireframe.qmd",
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\engine\cortex.py:28:29
   |
26 |         }
27 |
28 |         self.knowledge_map: Dict[str, Path] = {}
   |                             ^^^^
29 |         for name, rel_path in doc_targets.items():
30 |             path = self.project_root / rel_path
   |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:38:1
   |
36 |                 if md_path.exists():
37 |                     self.knowledge_map[name] = md_path
38 |         
   | ^^^^^^^^
39 |         self._ingest()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:40:1
   |
39 |         self._ingest()
40 |     
   | ^^^^
41 |     def _ingest(self) -> None:
42 |         """[ALFRED] Secure ingestion of project laws into the Cortex."""
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:44:1
   |
42 |         """[ALFRED] Secure ingestion of project laws into the Cortex."""
43 |         from src.core.ui import HUD  # Lazy import to avoid circularity
44 |         
   | ^^^^^^^^
45 |         for name, path in self.knowledge_map.items():
46 |             if not path.exists(): 
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\core\engine\cortex.py:46:34
   |
45 |         for name, path in self.knowledge_map.items():
46 |             if not path.exists(): 
   |                                  ^
47 |                 continue
48 |             try:
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:55:1
   |
54 |                 content = path.read_text(encoding='utf-8')
55 |                 
   | ^^^^^^^^^^^^^^^^
56 |                 # Chunk by Headers (Markdown)
57 |                 # Split capturing the delimiter
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:59:1
   |
57 |                 # Split capturing the delimiter
58 |                 sections = re.split(r'(^#+ .*$)', content, flags=re.MULTILINE)
59 |                 
   | ^^^^^^^^^^^^^^^^
60 |                 current_header = name
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:61:1
   |
60 |                 current_header = name
61 |                 
   | ^^^^^^^^^^^^^^^^
62 |                 # If the file doesn't start with a header, the first chunk is "intro"
63 |                 if sections and not sections[0].startswith('#'):
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\core\engine\cortex.py:68:35
   |
66 |                 for i in range(len(sections)):
67 |                     section = sections[i].strip()
68 |                     if not section: continue
   |                                   ^
69 |                     
70 |                     if section.startswith('#'):
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:69:1
   |
67 |                     section = sections[i].strip()
68 |                     if not section: continue
69 |                     
   | ^^^^^^^^^^^^^^^^^^^^
70 |                     if section.startswith('#'):
71 |                         current_header = f"{name} > {section.lstrip('#').strip()}"
   |
help: Remove whitespace from blank line

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\engine\cortex.py:74:20
   |
72 |                     else:
73 |                         self.brain.add_skill(current_header, section)
74 |             except (IOError, PermissionError) as e:
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |                 HUD.log("FAIL", "Cortex Ingest", f"{name} ({str(e)})")
76 |             except Exception as e:
   |
help: Replace with builtin `OSError`

RUF010 [*] Use explicit conversion flag
  --> src\core\engine\cortex.py:75:61
   |
73 |                         self.brain.add_skill(current_header, section)
74 |             except (IOError, PermissionError) as e:
75 |                 HUD.log("FAIL", "Cortex Ingest", f"{name} ({str(e)})")
   |                                                             ^^^^^^
76 |             except Exception as e:
77 |                 # [ALFRED] Log but do not crash; Cortex is auxiliary
   |
help: Replace with conversion flag

F841 [*] Local variable `e` is assigned to but never used
  --> src\core\engine\cortex.py:76:33
   |
74 |             except (IOError, PermissionError) as e:
75 |                 HUD.log("FAIL", "Cortex Ingest", f"{name} ({str(e)})")
76 |             except Exception as e:
   |                                 ^
77 |                 # [ALFRED] Log but do not crash; Cortex is auxiliary
78 |                 HUD.log("WARN", "Cortex Warning", f"Failed to digest {name}")
   |
help: Remove assignment to unused variable `e`

W293 [*] Blank line contains whitespace
  --> src\core\engine\cortex.py:79:1
   |
77 |                 # [ALFRED] Log but do not crash; Cortex is auxiliary
78 |                 HUD.log("WARN", "Cortex Warning", f"Failed to digest {name}")
79 |         
   | ^^^^^^^^
80 |         self.brain.build_index()
   |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\core\engine\cortex.py:82:35
   |
80 |         self.brain.build_index()
81 |
82 |     def query(self, text: str) -> List[Any]:
   |                                   ^^^^
83 |         return self.brain.search(text)
   |
help: Replace with `list`

W292 [*] No newline at end of file
  --> src\core\engine\cortex.py:83:39
   |
82 |     def query(self, text: str) -> List[Any]:
83 |         return self.brain.search(text)
   |                                       ^
   |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\engine\dialogue.py:1:1
  |
1 | / from pathlib import Path
2 | | import random
3 | |
4 | | import random
5 | | import yaml
6 | | from pathlib import Path
7 | | from collections import deque
  | |_____________________________^
8 |
9 |   class DialogueEngine:
  |
help: Organize imports

F811 [*] Redefinition of unused `random` from line 2
 --> src\core\engine\dialogue.py:2:8
  |
1 | from pathlib import Path
2 | import random
  |        ------ previous definition of `random` here
3 |
4 | import random
  |        ^^^^^^ `random` redefined here
5 | import yaml
6 | from pathlib import Path
  |
help: Remove definition: `random`

F811 [*] Redefinition of unused `Path` from line 1
 --> src\core\engine\dialogue.py:6:21
  |
4 | import random
5 | import yaml
6 | from pathlib import Path
  |                     ^^^^ `Path` redefined here
7 | from collections import deque
  |
 ::: src\core\engine\dialogue.py:1:21
  |
1 | from pathlib import Path
  |                     ---- previous definition of `Path` here
2 | import random
  |
help: Remove definition: `Path`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\engine\dialogue.py:22:18
   |
20 |             return
21 |         try:
22 |             with open(path, 'r', encoding='utf-8') as f:
   |                  ^^^^
23 |                 self.phrase_data = yaml.safe_load(f) or {}
24 |         except Exception:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\engine\dialogue.py:22:29
   |
20 |             return
21 |         try:
22 |             with open(path, 'r', encoding='utf-8') as f:
   |                             ^^^
23 |                 self.phrase_data = yaml.safe_load(f) or {}
24 |         except Exception:
   |
help: Remove mode argument

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\core\engine\dialogue.py:24:9
   |
22 |               with open(path, 'r', encoding='utf-8') as f:
23 |                   self.phrase_data = yaml.safe_load(f) or {}
24 | /         except Exception:
25 | |             pass
   | |________________^
26 |
27 |       def get(self, persona: str, intent: str, context: dict = None) -> str:
   |

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\core\engine\dialogue.py:27:55
   |
25 |             pass
26 |
27 |     def get(self, persona: str, intent: str, context: dict = None) -> str:
   |                                                       ^^^^
28 |         """[ALFRED] Get a contextually scored phrase for a persona and intent."""
29 |         context = context or {}
   |
help: Convert to `T | None`

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:32:1
   |
30 |         persona = persona.upper()
31 |         pool = self.phrase_data.get(persona, {}).get(intent, [])
32 |         
   | ^^^^^^^^
33 |         if not pool:
34 |             return "..."
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:49:1
   |
47 |                 if "compliance_breach" in tags:
48 |                     score += 10
49 |             
   | ^^^^^^^^^^^^
50 |             # Alfred: Check for error type keywords
51 |             error_type = context.get("error_type", "").lower()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:60:1
   |
58 |                 if any(error_type in t.lower() or t.lower() in error_type for t in tags):
59 |                     score += 10
60 |             
   | ^^^^^^^^^^^^
61 |             # Generic setback/syntax tags
62 |             if "setback" in context and "setback" in tags:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:70:1
   |
68 |         scored_candidates.sort(key=lambda x: x[0], reverse=True)
69 |         top_score = scored_candidates[0][0]
70 |         
   | ^^^^^^^^
71 |         # Filter for top scoring candidates and remove from history if possible
72 |         best_matches = [p for s, p in scored_candidates if s == top_score]
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:74:1
   |
72 |         best_matches = [p for s, p in scored_candidates if s == top_score]
73 |         final_candidates = [p for p in best_matches if p not in self.history]
74 |         
   | ^^^^^^^^
75 |         # Fallback if everything is in history
76 |         selection = random.choice(final_candidates if final_candidates else best_matches)
   |
help: Remove whitespace from blank line

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\core\engine\dialogue.py:76:21
   |
75 |         # Fallback if everything is in history
76 |         selection = random.choice(final_candidates if final_candidates else best_matches)
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |         
78 |         self.history.append(selection)
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\dialogue.py:77:1
   |
75 |         # Fallback if everything is in history
76 |         selection = random.choice(final_candidates if final_candidates else best_matches)
77 |         
   | ^^^^^^^^
78 |         self.history.append(selection)
79 |         return selection
   |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
  --> src\core\engine\dialogue.py:83:68
   |
81 |     def __repr__(self):
82 |         personas = list(self.phrase_data.keys())
83 |         return f"<DialogueEngine: {len(personas)} personas loaded>"
   |                                                                    ^
   |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\engine\gungnir\muninn.py:1:1
  |
1 | / import json
2 | | import os
3 | | import argparse
4 | | import uuid
5 | | from datetime import datetime
  | |_____________________________^
6 |
7 |   def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |
help: Organize imports

ANN201 Missing return type annotation for public function `manage_ledger`
 --> src\core\engine\gungnir\muninn.py:7:5
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |     ^^^^^^^^^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `ledger_path`
 --> src\core\engine\gungnir\muninn.py:7:19
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                   ^^^^^^^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

ANN001 Missing type annotation for function argument `target`
 --> src\core\engine\gungnir\muninn.py:7:32
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                                ^^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

ANN001 Missing type annotation for function argument `decision`
 --> src\core\engine\gungnir\muninn.py:7:40
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                                        ^^^^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

ANN001 Missing type annotation for function argument `score`
 --> src\core\engine\gungnir\muninn.py:7:50
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                                                  ^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

ANN001 Missing type annotation for function argument `llr`
 --> src\core\engine\gungnir\muninn.py:7:57
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                                                         ^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

ANN001 Missing type annotation for function argument `observations`
 --> src\core\engine\gungnir\muninn.py:7:62
  |
5 | from datetime import datetime
6 |
7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
  |                                                              ^^^^^^^^^^^^
8 |     # Initialize structure if ledger doesn't exist
9 |     if not os.path.exists(ledger_path):
  |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\core\engine\gungnir\muninn.py:9:12
   |
 7 | def manage_ledger(ledger_path, target, decision, score, llr, observations):
 8 |     # Initialize structure if ledger doesn't exist
 9 |     if not os.path.exists(ledger_path):
   |            ^^^^^^^^^^^^^^
10 |         data = {
11 |             "project_name": "CStar-Gungnir",
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\engine\gungnir\muninn.py:16:14
   |
14 |         }
15 |     else:
16 |         with open(ledger_path, 'r') as f:
   |              ^^^^
17 |             data = json.load(f)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\engine\gungnir\muninn.py:16:32
   |
14 |         }
15 |     else:
16 |         with open(ledger_path, 'r') as f:
   |                                ^^^
17 |             data = json.load(f)
   |
help: Remove mode argument

E501 Line too long (105 > 100)
  --> src\core\engine\gungnir\muninn.py:32:101
   |
31 |     # Recalculate GPHS (Moving average of score for Accepted flights)
32 |     accepted_scores = [h["alignment_score"] for h in data["flight_history"] if h["decision"] == "Accept"]
   |                                                                                                     ^^^^^
33 |     if accepted_scores:
34 |         data["global_project_health_score"] = sum(accepted_scores) / len(accepted_scores)
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\engine\gungnir\muninn.py:37:10
   |
36 |     # Write back to JSON
37 |     with open(ledger_path, 'w') as f:
   |          ^^^^
38 |         json.dump(data, f, indent=4)
   |
help: Replace with `Path.open()`

W293 [*] Blank line contains whitespace
  --> src\core\engine\gungnir\muninn.py:39:1
   |
37 |     with open(ledger_path, 'w') as f:
38 |         json.dump(data, f, indent=4)
39 |         
   | ^^^^^^^^
40 |     print(f"Ledger updated. Current GPHS: {data['global_project_health_score']:.2f}")
   |
help: Remove whitespace from blank line

E402 Module level import not at top of file
  --> src\core\engine\vector.py:15:1
   |
13 |     sys.path.append(str(project_root))
14 |
15 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

B905 `zip()` without an explicit `strict=` parameter
  --> src\core\engine\vector.py:27:37
   |
25 |     """[ALFRED] Standard cosine similarity â€” the default strategy."""
26 |     def compute(self, v1: list[float], v2: list[float]) -> float:
27 |         dot = sum(a * b for a, b in zip(v1, v2))
   |                                     ^^^^^^^^^^^
28 |         mag1 = math.sqrt(sum(a * a for a in v1))
29 |         mag2 = math.sqrt(sum(b * b for b in v2))
   |
help: Add explicit value for parameter `strict=`

ANN001 Missing type annotation for function argument `thesaurus_path`
  --> src\core\engine\vector.py:39:24
   |
38 | class SovereignVector:
39 |     def __init__(self, thesaurus_path=None, corrections_path=None, stopwords_path=None) -> None:
   |                        ^^^^^^^^^^^^^^
40 |         """
41 |         [ALFRED] Initializes the Sovereign Vector Engine.
   |

ANN001 Missing type annotation for function argument `corrections_path`
  --> src\core\engine\vector.py:39:45
   |
38 | class SovereignVector:
39 |     def __init__(self, thesaurus_path=None, corrections_path=None, stopwords_path=None) -> None:
   |                                             ^^^^^^^^^^^^^^^^
40 |         """
41 |         [ALFRED] Initializes the Sovereign Vector Engine.
   |

ANN001 Missing type annotation for function argument `stopwords_path`
  --> src\core\engine\vector.py:39:68
   |
38 | class SovereignVector:
39 |     def __init__(self, thesaurus_path=None, corrections_path=None, stopwords_path=None) -> None:
   |                                                                    ^^^^^^^^^^^^^^
40 |         """
41 |         [ALFRED] Initializes the Sovereign Vector Engine.
   |

E501 Line too long (132 > 100)
  --> src\core\engine\vector.py:45:101
   |
43 |         """
44 |         self.thesaurus = self._load_thesaurus(thesaurus_path) if thesaurus_path else {}
45 |         self.corrections = self._load_json(corrections_path) if corrections_path else {"phrase_mappings": {}, "synonym_updates": {}}
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
46 |         self.stopwords = self._load_stopwords(stopwords_path)
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\vector.py:47:1
   |
45 |         self.corrections = self._load_json(corrections_path) if corrections_path else {"phrase_mappings": {}, "synonym_updates": {}}
46 |         self.stopwords = self._load_stopwords(stopwords_path)
47 |         
   | ^^^^^^^^
48 |         # SovereignFish: Boot Log (Suppressed for Daemon speed)
49 |         # HUD.box_top("ENGINE INITIALIZED")
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\core\engine\vector.py:64:20
   |
63 |     def _load_json(self, path: str | Path | None) -> dict:
64 |         if not path: return {}
   |                    ^
65 |         p = Path(path)
66 |         if not p.exists(): return {}
   |

E701 Multiple statements on one line (colon)
  --> src\core\engine\vector.py:66:26
   |
64 |         if not path: return {}
65 |         p = Path(path)
66 |         if not p.exists(): return {}
   |                          ^
67 |         try:
68 |             return json.loads(p.read_text(encoding='utf-8'))
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\engine\vector.py:69:16
   |
67 |         try:
68 |             return json.loads(p.read_text(encoding='utf-8'))
69 |         except (json.JSONDecodeError, IOError, OSError):
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |             return {}
   |
help: Replace with builtin `OSError`

E501 Line too long (101 > 100)
  --> src\core\engine\vector.py:74:101
   |
72 |     def _load_stopwords(self, path: str | Path | None) -> set[str]:
73 |         defaults = {
74 |             'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 
   |                                                                                                     ^
75 |             'is', 'are', 'was', 'were', 'be', 'been', 'it', 'this', 'that', 'these', 'those', 
76 |             'i', 'you', 'he', 'she', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
   |

W291 [*] Trailing whitespace
  --> src\core\engine\vector.py:74:101
   |
72 |     def _load_stopwords(self, path: str | Path | None) -> set[str]:
73 |         defaults = {
74 |             'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 
   |                                                                                                     ^
75 |             'is', 'are', 'was', 'were', 'be', 'been', 'it', 'this', 'that', 'these', 'those', 
76 |             'i', 'you', 'he', 'she', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\core\engine\vector.py:75:94
   |
73 |         defaults = {
74 |             'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 
75 |             'is', 'are', 'was', 'were', 'be', 'been', 'it', 'this', 'that', 'these', 'those', 
   |                                                                                              ^
76 |             'i', 'you', 'he', 'she', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
77 |             'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how',
   |
help: Remove trailing whitespace

E501 Line too long (104 > 100)
  --> src\core\engine\vector.py:78:101
   |
76 |             'i', 'you', 'he', 'she', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
77 |             'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how',
78 |             'some', 'any', 'no', 'not', 'do', 'does', 'did', 'done', 'will', 'would', 'shall', 'should',
   |                                                                                                     ^^^^
79 |             'can', 'could', 'may', 'might', 'must', 'have', 'has', 'had', 'go', 'get', 'make', 'do'
80 |         }
   |

B033 [*] Sets should not contain duplicate item `'do'`
  --> src\core\engine\vector.py:79:96
   |
77 |             'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how',
78 |             'some', 'any', 'no', 'not', 'do', 'does', 'did', 'done', 'will', 'would', 'shall', 'should',
79 |             'can', 'could', 'may', 'might', 'must', 'have', 'has', 'had', 'go', 'get', 'make', 'do'
   |                                                                                                ^^^^
80 |         }
81 |         if not path: return defaults
   |
help: Remove duplicate item

E701 Multiple statements on one line (colon)
  --> src\core\engine\vector.py:81:20
   |
79 |             'can', 'could', 'may', 'might', 'must', 'have', 'has', 'had', 'go', 'get', 'make', 'do'
80 |         }
81 |         if not path: return defaults
   |                    ^
82 |         p = Path(path)
83 |         if not p.exists(): return defaults
   |

E701 Multiple statements on one line (colon)
  --> src\core\engine\vector.py:83:26
   |
81 |         if not path: return defaults
82 |         p = Path(path)
83 |         if not p.exists(): return defaults
   |                          ^
84 |         try:
85 |             loaded = set(json.loads(p.read_text(encoding='utf-8')))
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\engine\vector.py:87:16
   |
85 |             loaded = set(json.loads(p.read_text(encoding='utf-8')))
86 |             return loaded if loaded else defaults
87 |         except (json.JSONDecodeError, IOError, OSError, TypeError):
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |             return defaults
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\core\engine\vector.py:92:20
   |
90 |     def _load_thesaurus(self, path: str | Path | None) -> dict[str, dict[str, float]]:
91 |         """[ALFRED] Secure thesaurus loader with weight clamping and correction merging."""
92 |         if not path: return {}
   |                    ^
93 |         
94 |         p = Path(path)
   |

W293 [*] Blank line contains whitespace
  --> src\core\engine\vector.py:93:1
   |
91 |         """[ALFRED] Secure thesaurus loader with weight clamping and correction merging."""
92 |         if not path: return {}
93 |         
   | ^^^^^^^^
94 |         p = Path(path)
95 |         if not p.exists():
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:98:28
    |
 96 |             # [ALFRED] Staged Symbiosis: Support .qmd with .md fallback
 97 |             alt = p.with_suffix('.qmd') if p.suffix == '.md' else p.with_suffix('.md')
 98 |             if alt.exists(): p = alt
    |                            ^
 99 |         
100 |         if not p.exists() or p.stat().st_size > 2*10**6: return {}
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:99:1
    |
 97 |             alt = p.with_suffix('.qmd') if p.suffix == '.md' else p.with_suffix('.md')
 98 |             if alt.exists(): p = alt
 99 |         
    | ^^^^^^^^
100 |         if not p.exists() or p.stat().st_size > 2*10**6: return {}
101 |         try:
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:100:56
    |
 98 |             if alt.exists(): p = alt
 99 |         
100 |         if not p.exists() or p.stat().st_size > 2*10**6: return {}
    |                                                        ^
101 |         try:
102 |             content = p.read_text(encoding='utf-8')
    |

E501 Line too long (182 > 100)
   --> src\core\engine\vector.py:104:101
    |
102 | â€¦
103 | â€¦
104 | â€¦\u3040-\u309f\u30a0-\u30ff]+)(?:\*\*)?: ([\w\d,\.: \-\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]+)', content):
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 | â€¦
106 | â€¦
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:108:29
    |
106 |                 for s in syns.split(','):
107 |                     s = s.strip().lower()
108 |                     if not s: continue
    |                             ^
109 |                     name, weight = (s.split(':') + ["1.0"])[:2]
110 |                     try: weight = max(0.1, min(2.0, float(weight)))
    |

RUF005 Consider `[*s.split(':'), "1.0"]` instead of concatenation
   --> src\core\engine\vector.py:109:37
    |
107 |                     s = s.strip().lower()
108 |                     if not s: continue
109 |                     name, weight = (s.split(':') + ["1.0"])[:2]
    |                                     ^^^^^^^^^^^^^^^^^^^^^^
110 |                     try: weight = max(0.1, min(2.0, float(weight)))
111 |                     except (ValueError, TypeError): weight = 1.0
    |
help: Replace with `[*s.split(':'), "1.0"]`

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:110:24
    |
108 |                     if not s: continue
109 |                     name, weight = (s.split(':') + ["1.0"])[:2]
110 |                     try: weight = max(0.1, min(2.0, float(weight)))
    |                        ^
111 |                     except (ValueError, TypeError): weight = 1.0
112 |                     syn_dict[name.strip()] = weight
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:111:51
    |
109 |                     name, weight = (s.split(':') + ["1.0"])[:2]
110 |                     try: weight = max(0.1, min(2.0, float(weight)))
111 |                     except (ValueError, TypeError): weight = 1.0
    |                                                   ^
112 |                     syn_dict[name.strip()] = weight
113 |                 mapping[word.lower()] = syn_dict
    |

UP024 [*] Replace aliased errors with `OSError`
   --> src\core\engine\vector.py:116:16
    |
114 |             self._apply_thesaurus_corrections(mapping)
115 |             return mapping
116 |         except (IOError, OSError): return {}
    |                ^^^^^^^^^^^^^^^^^^
117 |
118 |     def _apply_thesaurus_corrections(self, mapping):
    |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:116:34
    |
114 |             self._apply_thesaurus_corrections(mapping)
115 |             return mapping
116 |         except (IOError, OSError): return {}
    |                                  ^
117 |
118 |     def _apply_thesaurus_corrections(self, mapping):
    |

ANN202 Missing return type annotation for private function `_apply_thesaurus_corrections`
   --> src\core\engine\vector.py:118:9
    |
116 |         except (IOError, OSError): return {}
117 |
118 |     def _apply_thesaurus_corrections(self, mapping):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 |         """Apply dynamic corrections to the static thesaurus."""
120 |         if not hasattr(self, 'corrections') or not isinstance(self.corrections, dict): return
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `mapping`
   --> src\core\engine\vector.py:118:44
    |
116 |         except (IOError, OSError): return {}
117 |
118 |     def _apply_thesaurus_corrections(self, mapping):
    |                                            ^^^^^^^
119 |         """Apply dynamic corrections to the static thesaurus."""
120 |         if not hasattr(self, 'corrections') or not isinstance(self.corrections, dict): return
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:120:86
    |
118 |     def _apply_thesaurus_corrections(self, mapping):
119 |         """Apply dynamic corrections to the static thesaurus."""
120 |         if not hasattr(self, 'corrections') or not isinstance(self.corrections, dict): return
    |                                                                                      ^
121 |         for word, syns in self.corrections.get("synonym_updates", {}).items():
122 |             if isinstance(syns, list):
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:125:42
    |
123 |                 word_map = mapping.get(word, {})
124 |                 for s in syns:
125 |                     if isinstance(s, str): word_map[s] = 1.0
    |                                          ^
126 |                 mapping[word] = word_map
    |

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:131:1
    |
129 |         """
130 |         [ALFRED] Optimized Unicode-aware tokenizer with CJK segmentation and trigger preservation.
131 |         
    | ^^^^^^^^
132 |         Args:
133 |             text: The raw input string to tokenize.
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:134:1
    |
132 |         Args:
133 |             text: The raw input string to tokenize.
134 |             
    | ^^^^^^^^^^^^
135 |         Returns:
136 |             A list of prioritized tokens, preserving command triggers and handling CJK characters.
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:138:20
    |
136 |             A list of prioritized tokens, preserving command triggers and handling CJK characters.
137 |         """
138 |         if not text: return []
    |                    ^
139 |         text = text.lower()
140 |         # [ALFRED] Preserving / and - for direct command matching
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:144:1
    |
142 |         for match in re.finditer(r'[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]|[\w\d\/\-]+', text):
143 |             tokens.append(match.group())
144 |         
    | ^^^^^^^^
145 |         # Filter stopwords UNLESS the token is a known trigger
146 |         return [t for t in tokens if t not in self.stopwords or t in self.trigger_map] or tokens
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:152:1
    |
150 |         tokens = self.tokenize(query)
151 |         weights = {}
152 |         
    | ^^^^^^^^
153 |         for t in tokens:
154 |             # 0. Check Token Cache
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:161:1
    |
159 |                     weights[k] = max(weights.get(k, 0), v)
160 |                 continue
161 |                 
    | ^^^^^^^^^^^^^^^^
162 |             # If not in cache, compute expansion
163 |             t_weights = {t: 1.0}
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:164:1
    |
162 |             # If not in cache, compute expansion
163 |             t_weights = {t: 1.0}
164 |             
    | ^^^^^^^^^^^^
165 |             # 1. Stemming Rules (Dampened)
166 |             if len(t) > 4:
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:168:37
    |
166 |             if len(t) > 4:
167 |                 stem = None
168 |                 if t.endswith('ing'): stem = t[:-3]
    |                                     ^
169 |                 elif t.endswith('ed') or t.endswith('es'): stem = t[:-2]
170 |                 elif t.endswith('s') and not t.endswith('ss'): stem = t[:-1]
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:169:58
    |
167 |                 stem = None
168 |                 if t.endswith('ing'): stem = t[:-3]
169 |                 elif t.endswith('ed') or t.endswith('es'): stem = t[:-2]
    |                                                          ^
170 |                 elif t.endswith('s') and not t.endswith('ss'): stem = t[:-1]
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:170:62
    |
168 |                 if t.endswith('ing'): stem = t[:-3]
169 |                 elif t.endswith('ed') or t.endswith('es'): stem = t[:-2]
170 |                 elif t.endswith('s') and not t.endswith('ss'): stem = t[:-1]
    |                                                              ^
171 |                 
172 |                 if stem and len(stem) > 2:
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:171:1
    |
169 |                 elif t.endswith('ed') or t.endswith('es'): stem = t[:-2]
170 |                 elif t.endswith('s') and not t.endswith('ss'): stem = t[:-1]
171 |                 
    | ^^^^^^^^^^^^^^^^
172 |                 if stem and len(stem) > 2:
173 |                     t_weights[stem] = 0.8
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:179:1
    |
177 |                 for syn, weight in self.thesaurus[t].items():
178 |                     t_weights[syn] = max(t_weights.get(syn, 0), weight)
179 |             
    | ^^^^^^^^^^^^
180 |             # Cache the result for this token
181 |             self._token_cache[t] = t_weights
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:182:1
    |
180 |             # Cache the result for this token
181 |             self._token_cache[t] = t_weights
182 |             
    | ^^^^^^^^^^^^
183 |             # Merge into main weights
184 |             for k, v in t_weights.items():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:186:1
    |
184 |             for k, v in t_weights.items():
185 |                 weights[k] = max(weights.get(k, 0), v)
186 |         
    | ^^^^^^^^
187 |         return weights
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:192:1
    |
190 |         """
191 |         Registers a new skill in the engine.
192 |         
    | ^^^^^^^^
193 |         Args:
194 |             trigger: The primary activation command (e.g., '/run-task').
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:205:25
    |
203 |         """[ALFRED] Build TF-IDF index with cached sorted vocabulary for rapid search."""
204 |         num_docs = len(self.skills)
205 |         if num_docs == 0: return
    |                         ^
206 |         
207 |         # [ALFRED] Cache sorted vocab to avoid redundant sorts in search loop
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:206:1
    |
204 |         num_docs = len(self.skills)
205 |         if num_docs == 0: return
206 |         
    | ^^^^^^^^
207 |         # [ALFRED] Cache sorted vocab to avoid redundant sorts in search loop
208 |         self.sorted_vocab = sorted(list(self.vocab))
    |
help: Remove whitespace from blank line

C414 Unnecessary `list()` call within `sorted()`
   --> src\core\engine\vector.py:208:29
    |
207 |         # [ALFRED] Cache sorted vocab to avoid redundant sorts in search loop
208 |         self.sorted_vocab = sorted(list(self.vocab))
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^
209 |         
210 |         doc_counts = {}
    |
help: Remove the inner `list()` call

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:209:1
    |
207 |         # [ALFRED] Cache sorted vocab to avoid redundant sorts in search loop
208 |         self.sorted_vocab = sorted(list(self.vocab))
209 |         
    | ^^^^^^^^
210 |         doc_counts = {}
211 |         for text in self.skills.values():
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:215:42
    |
213 |             for word in words:
214 |                 doc_counts[word] = doc_counts.get(word, 0) + 1
215 |                 if word not in self.vocab: self.vocab.add(word) # Dynamic update
    |                                          ^
216 |         
217 |         # Calculate IDF
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:216:1
    |
214 |                 doc_counts[word] = doc_counts.get(word, 0) + 1
215 |                 if word not in self.vocab: self.vocab.add(word) # Dynamic update
216 |         
    | ^^^^^^^^
217 |         # Calculate IDF
218 |         for word, count in doc_counts.items():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:220:1
    |
218 |         for word, count in doc_counts.items():
219 |             self.idf[word] = math.log(num_docs / (1 + count)) + 1
220 |             
    | ^^^^^^^^^^^^
221 |         for trigger, text in self.skills.items():
222 |             # Build initial vector from doc tokens (Use Term Frequency)
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:230:1
    |
228 |         """
229 |         Converts a dictionary of token weights into a normalized TF-IDF vector.
230 |         
    | ^^^^^^^^
231 |         Args:
232 |             token_weights: A dictionary mapping tokens to their relative weights.
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:233:1
    |
231 |         Args:
232 |             token_weights: A dictionary mapping tokens to their relative weights.
233 |             
    | ^^^^^^^^^^^^
234 |         Returns:
235 |             A normalized list of floats representing the query in the engine's vector space.
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:239:1
    |
237 |         # token_weights is a dict of {token: weight}
238 |         total_weight = sum(token_weights.values()) or 1
239 |         
    | ^^^^^^^^
240 |         # [ALFRED] Use cached vocabulary and list comprehension for speed optimization
241 |         vocab = getattr(self, 'sorted_vocab', sorted(list(self.vocab)))
    |
help: Remove whitespace from blank line

C414 Unnecessary `list()` call within `sorted()`
   --> src\core\engine\vector.py:241:47
    |
240 |         # [ALFRED] Use cached vocabulary and list comprehension for speed optimization
241 |         vocab = getattr(self, 'sorted_vocab', sorted(list(self.vocab)))
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^
242 |         
243 |         return [
    |
help: Remove the inner `list()` call

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:242:1
    |
240 |         # [ALFRED] Use cached vocabulary and list comprehension for speed optimization
241 |         vocab = getattr(self, 'sorted_vocab', sorted(list(self.vocab)))
242 |         
    | ^^^^^^^^
243 |         return [
244 |             (token_weights.get(word, 0) / total_weight) * self.idf.get(word, 0)
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:253:1
    |
251 |         """
252 |         [ALFRED] Performs high-performance vector search with intent calibration.
253 |         
    | ^^^^^^^^
254 |         Args:
255 |             query: The raw user input string.
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:256:1
    |
254 |         Args:
255 |             query: The raw user input string.
256 |             
    | ^^^^^^^^^^^^
257 |         Returns:
258 |             A list of result dictionaries containing 'trigger', 'score', and 'is_global'.
    |
help: Remove whitespace from blank line

E501 Line too long (107 > 100)
   --> src\core\engine\vector.py:271:101
    |
269 |             trigger = self.corrections["phrase_mappings"][query_norm]
270 |             is_global = trigger.startswith("GLOBAL:") if trigger else False
271 |             res = [{"trigger": trigger, "score": 1.1, "note": "Correction mapped", "is_global": is_global}]
    |                                                                                                     ^^^^^^^
272 |             self._search_cache[query_norm] = res
273 |             return res
    |

E501 Line too long (105 > 100)
   --> src\core\engine\vector.py:278:101
    |
276 |         weighted_tokens = {}
277 |         # [ALFRED] Expansion Caching: Check if we've already expanded this specific query's tokens
278 |         # Note: We cache the *result* of expansion for the whole query string for simplicity and hit-rate
    |                                                                                                     ^^^^^
279 |         if query_norm in self._expansion_cache:
280 |             weighted_tokens = self._expansion_cache[query_norm]
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:286:1
    |
285 |         q_vec = self._vectorize(weighted_tokens)
286 |         
    | ^^^^^^^^
287 |         # 3. Direct Trigger Boost (Dampened)
288 |         trigger_boosts = {}
    |
help: Remove whitespace from blank line

E501 Line too long (101 > 100)
   --> src\core\engine\vector.py:292:101
    |
290 |         common_verbs = {
291 |             'make', 'check', 'look', 'wrap', 'run', 'build', 'create', 'do',
292 |             'construct', 'implement', 'develop', 'generate', 'analyze', 'audit', 'debug', 'validate',
    |                                                                                                     ^
293 |             'verify', 'plan', 'design', 'test', 'deploy', 'launch', 'push', 'release', 'ship',
294 |             'setup', 'bootstrap', 'now', 'today', 'what', 'please', 'just', 'more',
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:299:1
    |
297 |         # [ALFRED] High-priority verbs that should NOT be dampened if they match a specific trigger
298 |         priority_verbs = {'begin', 'start', 'resume', 'initiate', 'fix'}
299 |         
    | ^^^^^^^^
300 |         for t in tokens:
301 |             if t in self.trigger_map:
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\engine\vector.py:307:36
    |
305 |                     boost_val = 2.0 # Mega-boost for start/resume signals
306 |                 elif t in common_verbs:
307 |                     boost_val = 0.8 
    |                                    ^
308 |                 else:
309 |                     boost_val = 0.98
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:310:1
    |
308 |                 else:
309 |                     boost_val = 0.98
310 |                     
    | ^^^^^^^^^^^^^^^^^^^^
311 |                 for skill in self.trigger_map[t]:
312 |                     trigger_boosts[skill] = max(trigger_boosts.get(skill, 0), boost_val)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:317:1
    |
315 |         # [ALFRED] Optimization: Pre-calculate vector magnitudes for faster similarity
316 |         q_mag = sum(a * a for a in q_vec) ** 0.5
317 |         
    | ^^^^^^^^
318 |         for trigger, s_vec in self.vectors.items():
319 |             # Optimization: Skip if dot product will be 0 (no shared tokens) 
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\engine\vector.py:319:77
    |
318 |         for trigger, s_vec in self.vectors.items():
319 |             # Optimization: Skip if dot product will be 0 (no shared tokens) 
    |                                                                             ^
320 |             # or if query magnitude is zero (empty signal)
321 |             if not q_mag:
    |
help: Remove trailing whitespace

E501 Line too long (110 > 100)
   --> src\core\engine\vector.py:322:101
    |
320 |             # or if query magnitude is zero (empty signal)
321 |             if not q_mag:
322 |                 results.append({"trigger": trigger, "score": 0.0, "is_global": trigger.startswith("GLOBAL:")})
    |                                                                                                     ^^^^^^^^^^
323 |                 continue
    |

B905 `zip()` without an explicit `strict=` parameter
   --> src\core\engine\vector.py:325:41
    |
323 |                 continue
324 |
325 |             dot = sum(a * b for a, b in zip(q_vec, s_vec))
    |                                         ^^^^^^^^^^^^^^^^^
326 |             if not dot:
327 |                  results.append({"trigger": trigger, "score": 0.0, "is_global": trigger.startswith("GLOBAL:")})
    |
help: Add explicit value for parameter `strict=`

E501 Line too long (111 > 100)
   --> src\core\engine\vector.py:327:101
    |
325 |             dot = sum(a * b for a, b in zip(q_vec, s_vec))
326 |             if not dot:
327 |                  results.append({"trigger": trigger, "score": 0.0, "is_global": trigger.startswith("GLOBAL:")})
    |                                                                                                     ^^^^^^^^^^^
328 |                  continue
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:332:1
    |
330 |             s_mag = sum(a * a for a in s_vec) ** 0.5
331 |             score = dot / (q_mag * s_mag) if s_mag else 0.0
332 |             
    | ^^^^^^^^^^^^
333 |             # Apply dampened boost
334 |             if trigger in trigger_boosts:
    |
help: Remove whitespace from blank line

SIM108 Use ternary operator `score = 1.0 + (boost - 1.0) if boost >= 2.0 else score + boost * (1.0 - score)` instead of `if`-`else`-block
   --> src\core\engine\vector.py:337:17
    |
335 |                   # If we have a massive boost (2.0), we force it to top
336 |                   boost = trigger_boosts[trigger]
337 | /                 if boost >= 2.0:
338 | |                    score = 1.0 + (boost - 1.0) # pushes above 1.0
339 | |                 else:
340 | |                    score = score + boost * (1.0 - score)
    | |________________________________________________________^
341 |               
342 |               is_global = trigger.startswith("GLOBAL:")
    |
help: Replace `if`-`else`-block with `score = 1.0 + (boost - 1.0) if boost >= 2.0 else score + boost * (1.0 - score)`

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:341:1
    |
339 |                 else:
340 |                    score = score + boost * (1.0 - score)
341 |             
    | ^^^^^^^^^^^^
342 |             is_global = trigger.startswith("GLOBAL:")
343 |             # [ALFRED] Sovereign Priority: Slight tie-breaker for core intents
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:346:1
    |
344 |             if (trigger.startswith("/") or trigger == "SovereignFish") and not is_global:
345 |                 score *= 1.1
346 |             
    | ^^^^^^^^^^^^
347 |             # [ALFRED] Specific Demotion: If "begin" or "new" is present, /run-task shouldn't steal from /lets-go
348 |             # logic: /run-task is "create", /lets-go is "begin"
    |
help: Remove whitespace from blank line

E501 Line too long (113 > 100)
   --> src\core\engine\vector.py:347:101
    |
345 |                 score *= 1.1
346 |             
347 |             # [ALFRED] Specific Demotion: If "begin" or "new" is present, /run-task shouldn't steal from /lets-go
    |                                                                                                     ^^^^^^^^^^^^^
348 |             # logic: /run-task is "create", /lets-go is "begin"
349 |             if "/lets-go" in trigger_boosts and trigger == "/run-task":
    |

W291 [*] Trailing whitespace
   --> src\core\engine\vector.py:350:29
    |
348 |             # logic: /run-task is "create", /lets-go is "begin"
349 |             if "/lets-go" in trigger_boosts and trigger == "/run-task":
350 |                 score *= 0.5 
    |                             ^
351 |
352 |             # [ALFRED] Global vs Generic Arbitration
    |
help: Remove trailing whitespace

E501 Line too long (122 > 100)
   --> src\core\engine\vector.py:355:101
    |
353 |             # If a Specific GLOBAL skill matches well, it should beat generic /run-task
354 |             # But /investigate should beat generic GLOBAL tools unless highly specific
355 |             if trigger == "/run-task" and any(k.startswith("GLOBAL:") for k in trigger_boosts if trigger_boosts[k] > 1.0):
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
356 |                  score *= 0.8
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:359:1
    |
358 |             results.append({"trigger": trigger, "score": score, "is_global": is_global})
359 |         
    | ^^^^^^^^
360 |         final_results = sorted(results, key=lambda x: x['score'], reverse=True)
361 |         # Apply Confidence Floor (The 85% Bar - Dampened for Vector Search)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:370:1
    |
368 |                     r['trigger'] = None
369 |                 confident_results.append(r)
370 |         
    | ^^^^^^^^
371 |         self._search_cache[query_norm] = confident_results
372 |         return confident_results
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `load_core_skills`
   --> src\core\engine\vector.py:375:9
    |
375 |     def load_core_skills(self):
    |         ^^^^^^^^^^^^^^^^
376 |         """
377 |         [ALFRED] Populates the engine with the standard Sovereign Command set.
    |
help: Add return type annotation: `None`

E501 Line too long (104 > 100)
   --> src\core\engine\vector.py:382:101
    |
380 |         core = {
381 |             "/lets-go": "begin initiate start resume lets-go priority boot progress",
382 |             "/run-task": "create build generate implement develop construct new feature page component",
    |                                                                                                     ^^^^
383 |             "/investigate": "debug analyze audit sentinel validate explore bug error issue auth login credentials log",
384 |             "/plan": "architect blueprint itinerary map outline plan strategy roadmap system architecture",
    |

E501 Line too long (119 > 100)
   --> src\core\engine\vector.py:383:101
    |
381 |             "/lets-go": "begin initiate start resume lets-go priority boot progress",
382 |             "/run-task": "create build generate implement develop construct new feature page component",
383 |             "/investigate": "debug analyze audit sentinel validate explore bug error issue auth login credentials log",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^
384 |             "/plan": "architect blueprint itinerary map outline plan strategy roadmap system architecture",
385 |             "/test": "check integrity performance test validate verification verify coverage unit integration",
    |

E501 Line too long (107 > 100)
   --> src\core\engine\vector.py:384:101
    |
382 |             "/run-task": "create build generate implement develop construct new feature page component",
383 |             "/investigate": "debug analyze audit sentinel validate explore bug error issue auth login credentials log",
384 |             "/plan": "architect blueprint itinerary map outline plan strategy roadmap system architecture",
    |                                                                                                     ^^^^^^^
385 |             "/test": "check integrity performance test validate verification verify coverage unit integration",
386 |             "/wrap-it-up": "finish complete finalize quit exit done stop end session wrap close",
    |

E501 Line too long (111 > 100)
   --> src\core\engine\vector.py:385:101
    |
383 |             "/investigate": "debug analyze audit sentinel validate explore bug error issue auth login credentials log",
384 |             "/plan": "architect blueprint itinerary map outline plan strategy roadmap system architecture",
385 |             "/test": "check integrity performance test validate verification verify coverage unit integration",
    |                                                                                                     ^^^^^^^^^^^
386 |             "/wrap-it-up": "finish complete finalize quit exit done stop end session wrap close",
387 |             "SovereignFish": "polish improve refine aesthetics style design beautify visual ui ux"
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:403:49
    |
401 |             for w in core[trigger].split():
402 |                 clean = w.lower().strip()
403 |                 if clean not in self.trigger_map: self.trigger_map[clean] = []
    |                                                 ^
404 |                 self.trigger_map[clean].append(trigger)
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:405:1
    |
403 |                 if clean not in self.trigger_map: self.trigger_map[clean] = []
404 |                 self.trigger_map[clean].append(trigger)
405 |             
    | ^^^^^^^^^^^^
406 |             # [ALFRED] Hardened Trigger: Index the trigger itself for 1:1 matching
407 |             if trigger not in self.trigger_map: self.trigger_map[trigger] = [trigger]
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:407:47
    |
406 |             # [ALFRED] Hardened Trigger: Index the trigger itself for 1:1 matching
407 |             if trigger not in self.trigger_map: self.trigger_map[trigger] = [trigger]
    |                                               ^
408 |             elif trigger not in self.trigger_map[trigger]: self.trigger_map[trigger].append(trigger)
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:408:58
    |
406 |             # [ALFRED] Hardened Trigger: Index the trigger itself for 1:1 matching
407 |             if trigger not in self.trigger_map: self.trigger_map[trigger] = [trigger]
408 |             elif trigger not in self.trigger_map[trigger]: self.trigger_map[trigger].append(trigger)
    |                                                          ^
409 |
410 |         for trigger in core:
    |

ANN201 Missing return type annotation for public function `load_skills_from_dir`
   --> src\core\engine\vector.py:414:9
    |
412 |             self.add_skill(trigger, (words + " ") * 3)
413 |
414 |     def load_skills_from_dir(self, directory, prefix=""):
    |         ^^^^^^^^^^^^^^^^^^^^
415 |         """
416 |         [ALFRED] Dynamically discovers and indexes skills from a physical directory.
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `directory`
   --> src\core\engine\vector.py:414:36
    |
412 |             self.add_skill(trigger, (words + " ") * 3)
413 |
414 |     def load_skills_from_dir(self, directory, prefix=""):
    |                                    ^^^^^^^^^
415 |         """
416 |         [ALFRED] Dynamically discovers and indexes skills from a physical directory.
    |

ANN001 Missing type annotation for function argument `prefix`
   --> src\core\engine\vector.py:414:47
    |
412 |             self.add_skill(trigger, (words + " ") * 3)
413 |
414 |     def load_skills_from_dir(self, directory, prefix=""):
    |                                               ^^^^^^
415 |         """
416 |         [ALFRED] Dynamically discovers and indexes skills from a physical directory.
    |

W293 Blank line contains whitespace
   --> src\core\engine\vector.py:417:1
    |
415 |         """
416 |         [ALFRED] Dynamically discovers and indexes skills from a physical directory.
417 |         
    | ^^^^^^^^
418 |         Args:
419 |             directory: The path to the folder containing skill subdirectories.
    |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\core\engine\vector.py:422:16
    |
420 |             prefix: An optional string prefix for the trigger names (e.g., 'GLOBAL:').
421 |         """
422 |         if not os.path.exists(directory): return
    |                ^^^^^^^^^^^^^^
423 |         for folder in os.listdir(directory):
424 |             path = os.path.join(directory, folder)
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:422:41
    |
420 |             prefix: An optional string prefix for the trigger names (e.g., 'GLOBAL:').
421 |         """
422 |         if not os.path.exists(directory): return
    |                                         ^
423 |         for folder in os.listdir(directory):
424 |             path = os.path.join(directory, folder)
    |

PTH208 Use `pathlib.Path.iterdir()` instead.
   --> src\core\engine\vector.py:423:23
    |
421 |         """
422 |         if not os.path.exists(directory): return
423 |         for folder in os.listdir(directory):
    |                       ^^^^^^^^^^
424 |             path = os.path.join(directory, folder)
425 |             if not os.path.isdir(path): continue
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\core\engine\vector.py:424:20
    |
422 |         if not os.path.exists(directory): return
423 |         for folder in os.listdir(directory):
424 |             path = os.path.join(directory, folder)
    |                    ^^^^^^^^^^^^
425 |             if not os.path.isdir(path): continue
    |

PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
   --> src\core\engine\vector.py:425:20
    |
423 |         for folder in os.listdir(directory):
424 |             path = os.path.join(directory, folder)
425 |             if not os.path.isdir(path): continue
    |                    ^^^^^^^^^^^^^
426 |             
427 |             # [ALFRED] Hybrid Discovery: Support SKILL.qmd (Primary) or SKILL.md (Fallback)
    |
help: Replace with `Path(...).is_dir()`

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:425:39
    |
423 |         for folder in os.listdir(directory):
424 |             path = os.path.join(directory, folder)
425 |             if not os.path.isdir(path): continue
    |                                       ^
426 |             
427 |             # [ALFRED] Hybrid Discovery: Support SKILL.qmd (Primary) or SKILL.md (Fallback)
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:426:1
    |
424 |             path = os.path.join(directory, folder)
425 |             if not os.path.isdir(path): continue
426 |             
    | ^^^^^^^^^^^^
427 |             # [ALFRED] Hybrid Discovery: Support SKILL.qmd (Primary) or SKILL.md (Fallback)
428 |             qmd_path = os.path.join(path, "SKILL.qmd")
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\core\engine\vector.py:428:24
    |
427 |             # [ALFRED] Hybrid Discovery: Support SKILL.qmd (Primary) or SKILL.md (Fallback)
428 |             qmd_path = os.path.join(path, "SKILL.qmd")
    |                        ^^^^^^^^^^^^
429 |             md_path = os.path.join(path, "SKILL.md")
430 |             if os.path.exists(qmd_path):
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\core\engine\vector.py:429:23
    |
427 |             # [ALFRED] Hybrid Discovery: Support SKILL.qmd (Primary) or SKILL.md (Fallback)
428 |             qmd_path = os.path.join(path, "SKILL.qmd")
429 |             md_path = os.path.join(path, "SKILL.md")
    |                       ^^^^^^^^^^^^
430 |             if os.path.exists(qmd_path):
431 |                 self._load_single_skill(folder, qmd_path, prefix)
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\core\engine\vector.py:430:16
    |
428 |             qmd_path = os.path.join(path, "SKILL.qmd")
429 |             md_path = os.path.join(path, "SKILL.md")
430 |             if os.path.exists(qmd_path):
    |                ^^^^^^^^^^^^^^
431 |                 self._load_single_skill(folder, qmd_path, prefix)
432 |             elif os.path.exists(md_path):
    |
help: Replace with `Path(...).exists()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\core\engine\vector.py:432:18
    |
430 |             if os.path.exists(qmd_path):
431 |                 self._load_single_skill(folder, qmd_path, prefix)
432 |             elif os.path.exists(md_path):
    |                  ^^^^^^^^^^^^^^
433 |                 self._load_single_skill(folder, md_path, prefix)
    |
help: Replace with `Path(...).exists()`

ANN202 Missing return type annotation for private function `_load_single_skill`
   --> src\core\engine\vector.py:435:9
    |
433 |                 self._load_single_skill(folder, md_path, prefix)
434 |
435 |     def _load_single_skill(self, folder, md_path, prefix):
    |         ^^^^^^^^^^^^^^^^^^
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `folder`
   --> src\core\engine\vector.py:435:34
    |
433 |                 self._load_single_skill(folder, md_path, prefix)
434 |
435 |     def _load_single_skill(self, folder, md_path, prefix):
    |                                  ^^^^^^
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
    |

ANN001 Missing type annotation for function argument `md_path`
   --> src\core\engine\vector.py:435:42
    |
433 |                 self._load_single_skill(folder, md_path, prefix)
434 |
435 |     def _load_single_skill(self, folder, md_path, prefix):
    |                                          ^^^^^^^
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
    |

ANN001 Missing type annotation for function argument `prefix`
   --> src\core\engine\vector.py:435:51
    |
433 |                 self._load_single_skill(folder, md_path, prefix)
434 |
435 |     def _load_single_skill(self, folder, md_path, prefix):
    |                                                   ^^^^^^
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\engine\vector.py:438:14
    |
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
438 |         with open(md_path, 'r', encoding='utf-8') as f: lines = f.readlines()
    |              ^^^^
439 |         
440 |         signal, in_fm, expect_keywords = [], False, False
    |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
   --> src\core\engine\vector.py:438:28
    |
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
438 |         with open(md_path, 'r', encoding='utf-8') as f: lines = f.readlines()
    |                            ^^^
439 |         
440 |         signal, in_fm, expect_keywords = [], False, False
    |
help: Remove mode argument

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:438:55
    |
436 |         """Extract metadata and activation signals from a single SKILL.md."""
437 |         trigger = f"{prefix}{folder}"
438 |         with open(md_path, 'r', encoding='utf-8') as f: lines = f.readlines()
    |                                                       ^
439 |         
440 |         signal, in_fm, expect_keywords = [], False, False
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:439:1
    |
437 |         trigger = f"{prefix}{folder}"
438 |         with open(md_path, 'r', encoding='utf-8') as f: lines = f.readlines()
439 |         
    | ^^^^^^^^
440 |         signal, in_fm, expect_keywords = [], False, False
441 |         for line in lines:
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:443:24
    |
441 |         for line in lines:
442 |             line = line.strip()
443 |             if not line: continue
    |                        ^
444 |             if line == "---": in_fm = not in_fm; continue
445 |             if in_fm:
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:444:29
    |
442 |             line = line.strip()
443 |             if not line: continue
444 |             if line == "---": in_fm = not in_fm; continue
    |                             ^
445 |             if in_fm:
446 |                 if line.startswith(("name:", "description:")): signal.append(line.split(":", 1)[1].strip())
    |

E702 Multiple statements on one line (semicolon)
   --> src\core\engine\vector.py:444:48
    |
442 |             line = line.strip()
443 |             if not line: continue
444 |             if line == "---": in_fm = not in_fm; continue
    |                                                ^
445 |             if in_fm:
446 |                 if line.startswith(("name:", "description:")): signal.append(line.split(":", 1)[1].strip())
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:446:62
    |
444 |             if line == "---": in_fm = not in_fm; continue
445 |             if in_fm:
446 |                 if line.startswith(("name:", "description:")): signal.append(line.split(":", 1)[1].strip())
    |                                                              ^
447 |             elif "Activation Words" in line or "Keywords" in line:
448 |                 if ":" in line:
    |

E501 Line too long (107 > 100)
   --> src\core\engine\vector.py:446:101
    |
444 |             if line == "---": in_fm = not in_fm; continue
445 |             if in_fm:
446 |                 if line.startswith(("name:", "description:")): signal.append(line.split(":", 1)[1].strip())
    |                                                                                                     ^^^^^^^
447 |             elif "Activation Words" in line or "Keywords" in line:
448 |                 if ":" in line:
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:458:1
    |
456 |                 signal.append(line)
457 |                 expect_keywords = False
458 |         
    | ^^^^^^^^
459 |         self.add_skill(trigger, f"{folder} {' '.join(signal)}")
    |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `_populate_trigger_map`
   --> src\core\engine\vector.py:461:9
    |
459 |         self.add_skill(trigger, f"{folder} {' '.join(signal)}")
460 |
461 |     def _populate_trigger_map(self, trigger, words_str):
    |         ^^^^^^^^^^^^^^^^^^^^^
462 |         """Helper to safely populate trigger map with word list."""
463 |         words = words_str.replace(',', ' ').lower().split()
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `trigger`
   --> src\core\engine\vector.py:461:37
    |
459 |         self.add_skill(trigger, f"{folder} {' '.join(signal)}")
460 |
461 |     def _populate_trigger_map(self, trigger, words_str):
    |                                     ^^^^^^^
462 |         """Helper to safely populate trigger map with word list."""
463 |         words = words_str.replace(',', ' ').lower().split()
    |

ANN001 Missing type annotation for function argument `words_str`
   --> src\core\engine\vector.py:461:46
    |
459 |         self.add_skill(trigger, f"{folder} {' '.join(signal)}")
460 |
461 |     def _populate_trigger_map(self, trigger, words_str):
    |                                              ^^^^^^^^^
462 |         """Helper to safely populate trigger map with word list."""
463 |         words = words_str.replace(',', ' ').lower().split()
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:465:21
    |
463 |         words = words_str.replace(',', ' ').lower().split()
464 |         for w in words:
465 |             if not w: continue
    |                     ^
466 |             if w not in self.trigger_map: self.trigger_map[w] = []
467 |             if trigger not in self.trigger_map[w]:
    |

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:466:41
    |
464 |         for w in words:
465 |             if not w: continue
466 |             if w not in self.trigger_map: self.trigger_map[w] = []
    |                                         ^
467 |             if trigger not in self.trigger_map[w]:
468 |                 self.trigger_map[w].append(trigger)
    |

W291 Trailing whitespace
   --> src\core\engine\vector.py:472:66
    |
470 |     def score_identity(self, text: str, persona_name: str) -> float:
471 |         """
472 |         Calculates a 'Purity Score' (0-1) by comparing input text 
    |                                                                  ^
473 |         to the vector space of the chosen persona's dialogue.
474 |         """
    |
help: Remove trailing whitespace

F841 Local variable `text_vec` is assigned to but never used
   --> src\core\engine\vector.py:477:9
    |
475 |         # 1. Expand query for text
476 |         weighted_tokens = self.expand_query(text)
477 |         text_vec = self._vectorize(weighted_tokens)
    |         ^^^^^^^^
478 |         
479 |         # 2. Re-index temporarily on dialogue
    |
help: Remove assignment to unused variable `text_vec`

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:478:1
    |
476 |         weighted_tokens = self.expand_query(text)
477 |         text_vec = self._vectorize(weighted_tokens)
478 |         
    | ^^^^^^^^
479 |         # 2. Re-index temporarily on dialogue
480 |         # We need a mini-engine for this or just simulate similarity
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:483:1
    |
481 |         # Let's use the current engine's vocab but check against dialogue data
482 |         # If the text has tokens that appear frequently in the persona's DB, it's a match.
483 |         
    | ^^^^^^^^
484 |         # Actually, if we have HUD.DIALOGUE loaded, we can compare directly.
485 |         # Simple heuristic for now: token overlap with dialogue registry
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:488:1
    |
486 |         tokens = set(self.tokenize(text))
487 |         persona_tokens = set()
488 |         
    | ^^^^^^^^
489 |         # Defensive check for HUD.DIALOGUE
490 |         if HUD.DIALOGUE:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:494:1
    |
492 |                 for p in phrases:
493 |                     persona_tokens.update(self.tokenize(p))
494 |         
    | ^^^^^^^^
495 |         if not persona_tokens or not tokens: return 0.0
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\engine\vector.py:495:44
    |
493 |                     persona_tokens.update(self.tokenize(p))
494 |         
495 |         if not persona_tokens or not tokens: return 0.0
    |                                            ^
496 |         
497 |         match = len(tokens.intersection(persona_tokens)) / len(tokens)
    |

W293 [*] Blank line contains whitespace
   --> src\core\engine\vector.py:496:1
    |
495 |         if not persona_tokens or not tokens: return 0.0
496 |         
    | ^^^^^^^^
497 |         match = len(tokens.intersection(persona_tokens)) / len(tokens)
498 |         return match
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\core\engine\vector.py:498:21
    |
497 |         match = len(tokens.intersection(persona_tokens)) / len(tokens)
498 |         return match
    |                     ^
    |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
  --> src\core\metrics.py:1:1
   |
 1 | / import json
 2 | | import os
 3 | | import subprocess
 4 | | import sys
 5 | | import time
 6 | | from pathlib import Path
 7 | | from typing import Any, Callable, Optional
 8 | | from src.core.prompt_linter import PromptLinter
 9 | | from src.core.engine.atomic_gpt import AtomicCortex
   | |___________________________________________________^
10 |
11 |   try:
   |
help: Organize imports

F401 [*] `pathlib.Path` imported but unused
 --> src\core\metrics.py:6:21
  |
4 | import sys
5 | import time
6 | from pathlib import Path
  |                     ^^^^
7 | from typing import Any, Callable, Optional
8 | from src.core.prompt_linter import PromptLinter
  |
help: Remove unused import: `pathlib.Path`

UP035 [*] Import from `collections.abc` instead: `Callable`
 --> src\core\metrics.py:7:1
  |
5 | import time
6 | from pathlib import Path
7 | from typing import Any, Callable, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | from src.core.prompt_linter import PromptLinter
9 | from src.core.engine.atomic_gpt import AtomicCortex
  |
help: Import from `collections.abc`

W291 Trailing whitespace
  --> src\core\metrics.py:20:44
   |
18 |     """
19 |     Decoupled Metrics Tracker.
20 |     Tracks pure latency using perf_counter. 
   |                                            ^
21 |     Memory profiling (psutil) is only sampled at explicit start/end bounds 
22 |     to prevent Observer Effect latency inflation.
   |
help: Remove trailing whitespace

W291 Trailing whitespace
  --> src\core\metrics.py:21:75
   |
19 |     Decoupled Metrics Tracker.
20 |     Tracks pure latency using perf_counter. 
21 |     Memory profiling (psutil) is only sampled at explicit start/end bounds 
   |                                                                           ^
22 |     to prevent Observer Effect latency inflation.
23 |     """
   |
help: Remove trailing whitespace

ANN001 Missing type annotation for function argument `exc_type`
  --> src\core\metrics.py:38:24
   |
36 |         return self
37 |
38 |     def __exit__(self, exc_type, exc_val, exc_tb):
   |                        ^^^^^^^^
39 |         self.end_time = time.perf_counter()
40 |         if HAS_PSUTIL:
   |

ANN001 Missing type annotation for function argument `exc_val`
  --> src\core\metrics.py:38:34
   |
36 |         return self
37 |
38 |     def __exit__(self, exc_type, exc_val, exc_tb):
   |                                  ^^^^^^^
39 |         self.end_time = time.perf_counter()
40 |         if HAS_PSUTIL:
   |

ANN001 Missing type annotation for function argument `exc_tb`
  --> src\core\metrics.py:38:43
   |
36 |         return self
37 |
38 |     def __exit__(self, exc_type, exc_val, exc_tb):
   |                                           ^^^^^^
39 |         self.end_time = time.perf_counter()
40 |         if HAS_PSUTIL:
   |

W293 [*] Blank line contains whitespace
  --> src\core\metrics.py:51:1
   |
49 |     def mem_delta_mb(self) -> float:
50 |         return self.end_mem - self.start_mem
51 |         
   | ^^^^^^^^
52 |     def report(self) -> dict[str, Any]:
53 |         return {
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `track_execution`
  --> src\core\metrics.py:61:5
   |
59 |         }
60 |
61 | def track_execution(name: Optional[str] = None):
   |     ^^^^^^^^^^^^^^^
62 |     """
63 |     Decorator to easily track execution metrics for a function without polluting its logic.
   |
help: Add return type annotation

UP045 [*] Use `X | None` for type annotations
  --> src\core\metrics.py:61:27
   |
59 |         }
60 |
61 | def track_execution(name: Optional[str] = None):
   |                           ^^^^^^^^^^^^^
62 |     """
63 |     Decorator to easily track execution metrics for a function without polluting its logic.
   |
help: Convert to `X | None`

ANN202 Missing return type annotation for private function `decorator`
  --> src\core\metrics.py:65:9
   |
63 |     Decorator to easily track execution metrics for a function without polluting its logic.
64 |     """
65 |     def decorator(func: Callable):
   |         ^^^^^^^^^
66 |         def wrapper(*args, **kwargs):
67 |             op_name = name or func.__name__
   |
help: Add return type annotation

ANN202 Missing return type annotation for private function `wrapper`
  --> src\core\metrics.py:66:13
   |
64 |     """
65 |     def decorator(func: Callable):
66 |         def wrapper(*args, **kwargs):
   |             ^^^^^^^
67 |             op_name = name or func.__name__
68 |             with ExecutionTracker(op_name) as tracker:
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> src\core\metrics.py:66:21
   |
64 |     """
65 |     def decorator(func: Callable):
66 |         def wrapper(*args, **kwargs):
   |                     ^^^^^
67 |             op_name = name or func.__name__
68 |             with ExecutionTracker(op_name) as tracker:
   |

ANN003 Missing type annotation for `**kwargs`
  --> src\core\metrics.py:66:28
   |
64 |     """
65 |     def decorator(func: Callable):
66 |         def wrapper(*args, **kwargs):
   |                            ^^^^^^^^
67 |             op_name = name or func.__name__
68 |             with ExecutionTracker(op_name) as tracker:
   |

W293 [*] Blank line contains whitespace
  --> src\core\metrics.py:70:1
   |
68 |             with ExecutionTracker(op_name) as tracker:
69 |                 result = func(*args, **kwargs)
70 |                 
   | ^^^^^^^^^^^^^^^^
71 |             # Log or store the metrics
72 |             try:
   |
help: Remove whitespace from blank line

E501 Line too long (122 > 100)
  --> src\core\metrics.py:76:101
   |
74 |                 # Only log if it's a significant operation (>50ms) to avoid spam
75 |                 if tracker.latency_ms > 50:
76 |                     delta_str = f"+{tracker.mem_delta_mb}MB" if tracker.mem_delta_mb >= 0 else f"{tracker.mem_delta_mb}MB"
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
77 |                     HUD.persona_log("INFO", f"[{op_name}] Latency: {tracker.latency_ms:.2f}ms | Mem: {delta_str}")
78 |             except Exception:
   |

E501 Line too long (114 > 100)
  --> src\core\metrics.py:77:101
   |
75 |                 if tracker.latency_ms > 50:
76 |                     delta_str = f"+{tracker.mem_delta_mb}MB" if tracker.mem_delta_mb >= 0 else f"{tracker.mem_delta_mb}MB"
77 |                     HUD.persona_log("INFO", f"[{op_name}] Latency: {tracker.latency_ms:.2f}ms | Mem: {delta_str}")
   |                                                                                                     ^^^^^^^^^^^^^^
78 |             except Exception:
79 |                 pass
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\core\metrics.py:78:13
   |
76 |                       delta_str = f"+{tracker.mem_delta_mb}MB" if tracker.mem_delta_mb >= 0 else f"{tracker.mem_delta_mb}MB"
77 |                       HUD.persona_log("INFO", f"[{op_name}] Latency: {tracker.latency_ms:.2f}ms | Mem: {delta_str}")
78 | /             except Exception:
79 | |                 pass
   | |____________________^
80 |                   
81 |               return result
   |

W293 [*] Blank line contains whitespace
  --> src\core\metrics.py:80:1
   |
78 |             except Exception:
79 |                 pass
80 |                 
   | ^^^^^^^^^^^^^^^^
81 |             return result
82 |         return wrapper
   |
help: Remove whitespace from blank line

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> src\core\metrics.py:92:21
   |
90 |     def __init__(self, weights_path: str = "src/core/weights.json") -> None:
91 |         # Resolve path relative to project root
92 |         self.root = os.getcwd()
   |                     ^^^^^^^^^
93 |         full_weights_path = os.path.join(self.root, weights_path)
94 |         if os.path.exists(full_weights_path):
   |
help: Replace with `Path.cwd()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\core\metrics.py:93:29
   |
91 |         # Resolve path relative to project root
92 |         self.root = os.getcwd()
93 |         full_weights_path = os.path.join(self.root, weights_path)
   |                             ^^^^^^^^^^^^
94 |         if os.path.exists(full_weights_path):
95 |             with open(full_weights_path, 'r') as f:
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\core\metrics.py:94:12
   |
92 |         self.root = os.getcwd()
93 |         full_weights_path = os.path.join(self.root, weights_path)
94 |         if os.path.exists(full_weights_path):
   |            ^^^^^^^^^^^^^^
95 |             with open(full_weights_path, 'r') as f:
96 |                 self.weights = json.load(f)
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\metrics.py:95:18
   |
93 |         full_weights_path = os.path.join(self.root, weights_path)
94 |         if os.path.exists(full_weights_path):
95 |             with open(full_weights_path, 'r') as f:
   |                  ^^^^
96 |                 self.weights = json.load(f)
97 |         else:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\metrics.py:95:42
   |
93 |         full_weights_path = os.path.join(self.root, weights_path)
94 |         if os.path.exists(full_weights_path):
95 |             with open(full_weights_path, 'r') as f:
   |                                          ^^^
96 |                 self.weights = json.load(f)
97 |         else:
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:105:1
    |
103 |                 "lore_saga": 10
104 |             }
105 |             
    | ^^^^^^^^^^^^
106 |     def compute(self, project_root: str = ".") -> float:
107 |         """
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:113:1
    |
111 |         linter = PromptLinter()
112 |         cortex = AtomicCortex()
113 |         
    | ^^^^^^^^
114 |         # 1. Prompt Integrity (15%)
115 |         prompt_score = linter.calculate_integrity_score()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:116:1
    |
114 |         # 1. Prompt Integrity (15%)
115 |         prompt_score = linter.calculate_integrity_score()
116 |         
    | ^^^^^^^^
117 |         # 2. Cortex Alignment (15%) - Measuring loss over recent log entries or source
118 |         sample_file = os.path.join(project_root, "src/sentinel/muninn.py")
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\core\metrics.py:118:23
    |
117 |         # 2. Cortex Alignment (15%) - Measuring loss over recent log entries or source
118 |         sample_file = os.path.join(project_root, "src/sentinel/muninn.py")
    |                       ^^^^^^^^^^^^
119 |         cortex_loss = 1.0
120 |         if os.path.exists(sample_file):
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\core\metrics.py:120:12
    |
118 |         sample_file = os.path.join(project_root, "src/sentinel/muninn.py")
119 |         cortex_loss = 1.0
120 |         if os.path.exists(sample_file):
    |            ^^^^^^^^^^^^^^
121 |             with open(sample_file, 'r', encoding='utf-8') as f:
122 |                 cortex_loss = cortex.calculate_project_loss(f.read())
    |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\metrics.py:121:18
    |
119 |         cortex_loss = 1.0
120 |         if os.path.exists(sample_file):
121 |             with open(sample_file, 'r', encoding='utf-8') as f:
    |                  ^^^^
122 |                 cortex_loss = cortex.calculate_project_loss(f.read())
123 |         # Convert loss to score (alignment: 1 means perfect alignment, 0 means random)
    |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
   --> src\core\metrics.py:121:36
    |
119 |         cortex_loss = 1.0
120 |         if os.path.exists(sample_file):
121 |             with open(sample_file, 'r', encoding='utf-8') as f:
    |                                    ^^^
122 |                 cortex_loss = cortex.calculate_project_loss(f.read())
123 |         # Convert loss to score (alignment: 1 means perfect alignment, 0 means random)
    |
help: Remove mode argument

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:125:1
    |
123 |         # Convert loss to score (alignment: 1 means perfect alignment, 0 means random)
124 |         alignment_score = max(0, 100 * (1 - min(1, cortex_loss)))
125 |         
    | ^^^^^^^^
126 |         # 3. Functional Health (35%) - Mocking or running pytest pass rate
127 |         # In a real environment, we'd run: pytest --json-report
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:130:1
    |
128 |         # For now, we'll use a heuristic or check a log file
129 |         functional_score = 80.0 # Default
130 |         
    | ^^^^^^^^
131 |         # 4. Form/Structure (25%) - Complexity check via subprocess radon
132 |         complexity_score = 70.0 # Default
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\core\metrics.py:135:22
    |
133 |         try:
134 |             # We check if radon is available
135 |             result = subprocess.run([sys.executable, "-m", "radon", "cc", project_root, "-s", "-a"], capture_output=True, text=True)
    |                      ^^^^^^^^^^^^^^
136 |             if result.returncode == 0:
137 |                 # Basic parsing to find average complexity
    |

E501 Line too long (132 > 100)
   --> src\core\metrics.py:135:101
    |
133 |         try:
134 |             # We check if radon is available
135 |             result = subprocess.run([sys.executable, "-m", "radon", "cc", project_root, "-s", "-a"], capture_output=True, text=True)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
136 |             if result.returncode == 0:
137 |                 # Basic parsing to find average complexity
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\metrics.py:140:9
    |
138 |                   # This is a simplification
139 |                   complexity_score = 90.0 if "Average complexity: A" in result.stdout else 60.0
140 | /         except Exception:
141 | |             pass
    | |________________^
142 |               
143 |           # 5. Lore Saga (10%) - Documentation check
    |

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:142:1
    |
140 |         except Exception:
141 |             pass
142 |             
    | ^^^^^^^^^^^^
143 |         # 5. Lore Saga (10%) - Documentation check
144 |         lore_score = 50.0 # Default
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:145:1
    |
143 |         # 5. Lore Saga (10%) - Documentation check
144 |         lore_score = 50.0 # Default
145 |         
    | ^^^^^^^^
146 |         final_gphs = (
147 |             (functional_score * self.weights["function"]) +
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\metrics.py:153:1
    |
151 |             (lore_score * self.weights["lore_saga"])
152 |         ) / 100.0
153 |         
    | ^^^^^^^^
154 |         return final_gphs
    |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\personas.py:1:1
  |
1 | / from pathlib import Path
2 | | from datetime import datetime
3 | | import json
4 | | import os
5 | | import shutil
6 | | import time
  | |___________^
7 |   try:
8 |       import msvcrt
  |
help: Organize imports

F401 [*] `os` imported but unused
 --> src\core\personas.py:4:8
  |
2 | from datetime import datetime
3 | import json
4 | import os
  |        ^^
5 | import shutil
6 | import time
  |
help: Remove unused import: `os`

ANN003 Missing type annotation for `**kwargs`
  --> src\core\personas.py:21:30
   |
19 |         self.root = Path(project_root)
20 |
21 |     def enforce_policy(self, **kwargs) -> dict:
   |                              ^^^^^^^^
22 |         """Analyze and enforce file structure policies. Returns context for dialogue."""
23 |         return {} 
   |

W291 [*] Trailing whitespace
  --> src\core\personas.py:23:18
   |
21 |     def enforce_policy(self, **kwargs) -> dict:
22 |         """Analyze and enforce file structure policies. Returns context for dialogue."""
23 |         return {} 
   |                  ^
24 |
25 |     def get_voice(self) -> str:
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:38:1
   |
36 |         if not source.exists():
37 |             return None
38 |             
   | ^^^^^^^^^^^^
39 |         quarantine_dir = source.parent / ".corvus_quarantine"
40 |         quarantine_dir.mkdir(exist_ok=True)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:41:1
   |
39 |         quarantine_dir = source.parent / ".corvus_quarantine"
40 |         quarantine_dir.mkdir(exist_ok=True)
41 |         
   | ^^^^^^^^
42 |         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
43 |         quarantine_path = quarantine_dir / f"{timestamp}_{source.name}"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:44:1
   |
42 |         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
43 |         quarantine_path = quarantine_dir / f"{timestamp}_{source.name}"
44 |         
   | ^^^^^^^^
45 |         shutil.move(str(source), str(quarantine_path))
46 |         return quarantine_path
   |
help: Remove whitespace from blank line

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\core\personas.py:60:13
   |
58 |                   data.pop("Persona", None)
59 |                   config_path.write_text(json.dumps(data, indent=4), encoding='utf-8')
60 | /             except Exception:
61 | |                 pass
   | |____________________^
62 |
63 |   class OdinStrategy(PersonaStrategy):
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\core\personas.py:68:20
   |
66 |     Aims for high standardization and authoritative project documentation.
67 |     """
68 |     _state_cache = {"data": None, "timestamp": 0}
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |     CACHE_TTL = 1.0  # 1 second buffer
   |

ANN202 Missing return type annotation for private function `_get_sovereign_state`
  --> src\core\personas.py:74:9
   |
72 |         return "O.D.I.N."
73 |
74 |     def _get_sovereign_state(self):
   |         ^^^^^^^^^^^^^^^^^^^^
75 |         """[ALFRED] Advanced state retriever with Windows-safe shared read and caching."""
76 |         now = time.time()
   |
help: Add return type annotation

E501 Line too long (109 > 100)
  --> src\core\personas.py:77:101
   |
75 |         """[ALFRED] Advanced state retriever with Windows-safe shared read and caching."""
76 |         now = time.time()
77 |         if self._state_cache["data"] is not None and (now - self._state_cache["timestamp"]) < self.CACHE_TTL:
   |                                                                                                     ^^^^^^^^^
78 |             return self._state_cache["data"]
   |

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:81:1
   |
80 |         state_path = self.root / ".agent" / "sovereign_state.json"
81 |         
   | ^^^^^^^^
82 |         from src.core.utils import safe_read_json
83 |         data = safe_read_json(state_path)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:84:1
   |
82 |         from src.core.utils import safe_read_json
83 |         data = safe_read_json(state_path)
84 |         
   | ^^^^^^^^
85 |         if data:
86 |             self._state_cache = {"data": data, "timestamp": now}
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\personas.py:92:1
   |
90 |         """O.D.I.N. documentation re-theming: Overwrite for Dominion."""
91 |         results = []
92 |         
   | ^^^^^^^^
93 |         def _res(base_name: str) -> Path:
94 |             names = [
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\core\personas.py:95:48
   |
93 |         def _res(base_name: str) -> Path:
94 |             names = [
95 |                 self.root / f"{base_name}.qmd", 
   |                                                ^
96 |                 self.root / f"{base_name}.md",
97 |                 self.root / "docs" / "architecture" / f"{base_name}.qmd",
   |
help: Remove trailing whitespace

E701 Multiple statements on one line (colon)
   --> src\core\personas.py:101:33
    |
 99 |             ]
100 |             for path in names:
101 |                 if path.exists(): return path
    |                                 ^
102 |             return self.root / f"{base_name}.qmd"
    |

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:106:1
    |
104 |         agents_path = _res("AGENTS")
105 |         source_template = _res("sterileAgent/AGENTS_ODIN")
106 |         
    | ^^^^^^^^
107 |         if source_template.exists():
108 |             legacy_content = ""
    |
help: Remove whitespace from blank line

E501 Line too long (103 > 100)
   --> src\core\personas.py:112:99
    |
110 |                 content = agents_path.read_text(encoding='utf-8')
111 |                 if "## ðŸ“œ Project Legacy" in content:
112 |                     legacy_content = "## ðŸ“œ Project Legacy" + content.split("## ðŸ“œ Project Legacy")[-1]
    |                                                                                                     ^^^
113 |                 else:
114 |                     legacy_content = "\n---\n\n## ðŸ“œ Project Legacy\n\n" + content
    |

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:115:1
    |
113 |                 else:
114 |                     legacy_content = "\n---\n\n## ðŸ“œ Project Legacy\n\n" + content
115 |                 
    | ^^^^^^^^^^^^^^^^
116 |                 self._quarantine(agents_path)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:117:1
    |
116 |                 self._quarantine(agents_path)
117 |             
    | ^^^^^^^^^^^^
118 |             template = source_template.read_text(encoding='utf-8')
119 |             agents_path.parent.mkdir(parents=True, exist_ok=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:121:1
    |
119 |             agents_path.parent.mkdir(parents=True, exist_ok=True)
120 |             agents_path.write_text(template + "\n\n" + legacy_content, encoding='utf-8')
121 |                 
    | ^^^^^^^^^^^^^^^^
122 |             results.append(f"RE-THEMED: {agents_path.name} (O.D.I.N. voice applied)")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:123:1
    |
122 |             results.append(f"RE-THEMED: {agents_path.name} (O.D.I.N. voice applied)")
123 |             
    | ^^^^^^^^^^^^
124 |         self._sync_configs("O.D.I.N.")
125 |         return results
    |
help: Remove whitespace from blank line

ANN003 Missing type annotation for `**kwargs`
   --> src\core\personas.py:127:30
    |
125 |         return results
126 |
127 |     def enforce_policy(self, **kwargs) -> dict:
    |                              ^^^^^^^^
128 |         """O.D.I.N. Policy: Complete Dominion. Return context for dialogue adjudication."""
129 |         results = [] # Internal logging
    |

F841 Local variable `results` is assigned to but never used
   --> src\core\personas.py:129:9
    |
127 |     def enforce_policy(self, **kwargs) -> dict:
128 |         """O.D.I.N. Policy: Complete Dominion. Return context for dialogue adjudication."""
129 |         results = [] # Internal logging
    |         ^^^^^^^
130 |         
131 |         # 1. Check for defiance in cached state
    |
help: Remove assignment to unused variable `results`

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:130:1
    |
128 |         """O.D.I.N. Policy: Complete Dominion. Return context for dialogue adjudication."""
129 |         results = [] # Internal logging
130 |         
    | ^^^^^^^^
131 |         # 1. Check for defiance in cached state
132 |         state = self._get_sovereign_state()
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\personas.py:133:100
    |
131 |         # 1. Check for defiance in cached state
132 |         state = self._get_sovereign_state()
133 |         is_defiant = any(v == "DEFIANCE" or (isinstance(v, dict) and v.get("status") == "DEFIANCE") 
    |                                                                                                    ^
134 |                          for v in state.values())
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:135:1
    |
133 |         is_defiant = any(v == "DEFIANCE" or (isinstance(v, dict) and v.get("status") == "DEFIANCE") 
134 |                          for v in state.values())
135 |         
    | ^^^^^^^^
136 |         # 2. Original Policy Enforcement
137 |         target_dirs = [self.root, self.root / "docs" / "architecture"]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:142:1
    |
140 |             md = target / "AGENTS.md"
141 |             agents_path = qmd if qmd.exists() else (md if md.exists() else None)
142 |             
    | ^^^^^^^^^^^^
143 |             if agents_path:
144 |                 try:
    |
help: Remove whitespace from blank line

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\personas.py:149:17
    |
147 |                       if not re.search(r"IDENTITY:\s+[A-Z]+", content):
148 |                           self._create_standard_agents(agents_path)
149 | /                 except Exception:
150 | |                     pass
    | |________________________^
151 |
152 |           rules_path = self.root / ".cursorrules"
    |

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:155:1
    |
153 |         if not rules_path.exists():
154 |             self._create_cursor_rules(rules_path)
155 |             
    | ^^^^^^^^^^^^
156 |         return {"compliance_breach": is_defiant}
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\personas.py:185:14
    |
183 | > You MUST execute the `SovereignFish` protocol EVERY SESSION.
184 | """
185 |         with open(path, 'w', encoding='utf-8') as f:
    |              ^^^^
186 |             f.write(content)
    |
help: Replace with `Path.open()`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\personas.py:201:14
    |
199 | - Monitor. Optimize. Report. 100% Test Coverage is the LAW.
200 | """
201 |         with open(path, 'w', encoding='utf-8') as f:
    |              ^^^^
202 |             f.write(content)
    |
help: Replace with `Path.open()`

ANN003 Missing type annotation for `**kwargs`
   --> src\core\personas.py:213:30
    |
211 |         return "alfred"
212 |
213 |     def enforce_policy(self, **kwargs) -> dict:
    |                              ^^^^^^^^
214 |         """ALFRED Policy: Humble Service. Returns context including error details."""
215 |         results = []
    |

F841 Local variable `results` is assigned to but never used
   --> src\core\personas.py:215:9
    |
213 |     def enforce_policy(self, **kwargs) -> dict:
214 |         """ALFRED Policy: Humble Service. Returns context including error details."""
215 |         results = []
    |         ^^^^^^^
216 |         
217 |         doc_targets = ["AGENTS", "tasks", "thesaurus"]
    |
help: Remove assignment to unused variable `results`

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:216:1
    |
214 |         """ALFRED Policy: Humble Service. Returns context including error details."""
215 |         results = []
216 |         
    | ^^^^^^^^
217 |         doc_targets = ["AGENTS", "tasks", "thesaurus"]
218 |         for name in doc_targets:
    |
help: Remove whitespace from blank line

UP024 [*] Replace aliased errors with `OSError`
   --> src\core\personas.py:227:20
    |
225 |                     if not bak.exists():
226 |                         shutil.copy2(str(path), str(bak))
227 |             except (IOError, PermissionError):
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
228 |                 pass 
    |
help: Replace with builtin `OSError`

W291 [*] Trailing whitespace
   --> src\core\personas.py:228:21
    |
226 |                         shutil.copy2(str(path), str(bak))
227 |             except (IOError, PermissionError):
228 |                 pass 
    |                     ^
229 |
230 |         agents_found = any((self.root / name).exists() for name in ["AGENTS.qmd", "AGENTS.md", "INSTRUCTIONS.qmd", "brief.qmd", "cursâ€¦
    |
help: Remove trailing whitespace

E501 Line too long (147 > 100)
   --> src\core\personas.py:230:101
    |
228 | â€¦
229 | â€¦
230 | â€¦ name in ["AGENTS.qmd", "AGENTS.md", "INSTRUCTIONS.qmd", "brief.qmd", "cursorrules.qmd"])
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
231 | â€¦
232 | â€¦S.qmd")
    |

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:233:1
    |
231 |         if not agents_found:
232 |             self._create_minimal_agents(self.root / "AGENTS.qmd")
233 |             
    | ^^^^^^^^^^^^
234 |         rules_path = self.root / ".cursorrules"
235 |         if not rules_path.exists():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:237:1
    |
235 |         if not rules_path.exists():
236 |             self._create_cursor_rules(rules_path)
237 |             
    | ^^^^^^^^^^^^
238 |         self._sync_configs("ALFRED")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:239:1
    |
238 |         self._sync_configs("ALFRED")
239 |         
    | ^^^^^^^^
240 |         context = {}
241 |         if "error_type" in kwargs:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\personas.py:243:1
    |
241 |         if "error_type" in kwargs:
242 |             context["error_type"] = kwargs["error_type"]
243 |         
    | ^^^^^^^^
244 |         return context
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\personas.py:274:14
    |
272 | > You MUST execute the `SovereignFish` protocol EVERY SESSION.
273 | """
274 |         with open(path, 'w', encoding='utf-8') as f:
    |              ^^^^
275 |             f.write(content)
    |
help: Replace with `Path.open()`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\core\personas.py:281:14
    |
279 | Here is a space for your agent instructions. I am here to help you build your vision.
280 | """
281 |         with open(path, 'w', encoding='utf-8') as f:
    |              ^^^^
282 |             f.write(content)
    |
help: Replace with `Path.open()`

W292 [*] No newline at end of file
   --> src\core\personas.py:296:30
    |
294 |     """[ALFRED] Look up the persona strategy from the registry, defaulting to ALFRED."""
295 |     strategy_cls = _PERSONA_REGISTRY.get(name.upper(), AlfredStrategy)
296 |     return strategy_cls(root)
    |                              ^
    |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\prompt_linter.py:1:1
  |
1 | / import re
2 | | import ast
3 | | import os
  | |_________^
4 |
5 |   class PromptLinter:
  |
help: Organize imports

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\core\prompt_linter.py:8:16
   |
 6 |     def parse_prompty_vars(self, filepath: str) -> list[str]:
 7 |         """Reads a .prompty file and uses regex to find all {{variables}}."""
 8 |         if not os.path.exists(filepath):
   |                ^^^^^^^^^^^^^^
 9 |             return []
10 |         with open(filepath, 'r', encoding='utf-8') as f:
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\prompt_linter.py:10:14
   |
 8 |         if not os.path.exists(filepath):
 9 |             return []
10 |         with open(filepath, 'r', encoding='utf-8') as f:
   |              ^^^^
11 |             content = f.read()
12 |         return list(set(re.findall(r"\{\{([a-zA-Z0-9_]+)\}\}", content)))
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\prompt_linter.py:10:29
   |
 8 |         if not os.path.exists(filepath):
 9 |             return []
10 |         with open(filepath, 'r', encoding='utf-8') as f:
   |                             ^^^
11 |             content = f.read()
12 |         return list(set(re.findall(r"\{\{([a-zA-Z0-9_]+)\}\}", content)))
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:13:1
   |
11 |             content = f.read()
12 |         return list(set(re.findall(r"\{\{([a-zA-Z0-9_]+)\}\}", content)))
13 |         
   | ^^^^^^^^
14 |     def audit_python_invocation(self, py_filepath: str, expected_vars: list[str]) -> bool:
15 |         """Uses AST to ensure the python code passes the required variables to any dict or string format that looks like prompt data."â€¦
   |
help: Remove whitespace from blank line

E501 Line too long (136 > 100)
  --> src\core\prompt_linter.py:15:101
   |
14 | â€¦tr, expected_vars: list[str]) -> bool:
15 | â€¦ the required variables to any dict or string format that looks like prompt data."""
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 | â€¦
17 | â€¦
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\core\prompt_linter.py:16:16
   |
14 |     def audit_python_invocation(self, py_filepath: str, expected_vars: list[str]) -> bool:
15 |         """Uses AST to ensure the python code passes the required variables to any dict or string format that looks like prompt data."â€¦
16 |         if not os.path.exists(py_filepath):
   |                ^^^^^^^^^^^^^^
17 |             return False
   |
help: Replace with `Path(...).exists()`

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:18:1
   |
16 |         if not os.path.exists(py_filepath):
17 |             return False
18 |             
   | ^^^^^^^^^^^^
19 |         try:
20 |             with open(py_filepath, 'r', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\prompt_linter.py:20:18
   |
19 |         try:
20 |             with open(py_filepath, 'r', encoding='utf-8') as f:
   |                  ^^^^
21 |                 tree = ast.parse(f.read())
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\prompt_linter.py:20:36
   |
19 |         try:
20 |             with open(py_filepath, 'r', encoding='utf-8') as f:
   |                                    ^^^
21 |                 tree = ast.parse(f.read())
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:22:1
   |
20 |             with open(py_filepath, 'r', encoding='utf-8') as f:
21 |                 tree = ast.parse(f.read())
22 |                 
   | ^^^^^^^^^^^^^^^^
23 |             found_vars = set()
24 |             for node in ast.walk(tree):
   |
help: Remove whitespace from blank line

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\core\prompt_linter.py:28:25
   |
26 |                   if isinstance(node, ast.Dict):
27 |                       for key in node.keys:
28 | /                         if isinstance(key, ast.Constant) and isinstance(key.value, str):
29 | |                             if key.value in expected_vars:
   | |__________________________________________________________^
30 |                                   found_vars.add(key.value)
31 |                   # Look for Keyword arguments in function calls
   |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\core\prompt_linter.py:36:17
   |
34 |                           found_vars.add(node.arg)
35 |                   # Look for string formatting with expected variables
36 | /                 elif isinstance(node, ast.Call):
37 | |                     if isinstance(node.func, ast.Attribute) and node.func.attr == 'format':
   | |___________________________________________________________________________________________^
38 |                           for kw in node.keywords:
39 |                               if kw.arg in expected_vars:
   |
help: Combine `if` statements using `and`

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:41:1
   |
39 |                             if kw.arg in expected_vars:
40 |                                 found_vars.add(kw.arg)
41 |             
   | ^^^^^^^^^^^^
42 |             return all(var in found_vars for var in expected_vars)
43 |         except Exception:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:45:1
   |
43 |         except Exception:
44 |             return False
45 |         
   | ^^^^^^^^
46 |     def calculate_integrity_score(self, prompt_dir: str = ".agent/prompts") -> float:
47 |         """Returns 0.0 to 100.0 based on how many prompts are error-free."""
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\core\prompt_linter.py:48:16
   |
46 |     def calculate_integrity_score(self, prompt_dir: str = ".agent/prompts") -> float:
47 |         """Returns 0.0 to 100.0 based on how many prompts are error-free."""
48 |         if not os.path.exists(prompt_dir):
   |                ^^^^^^^^^^^^^^
49 |             return 0.0
   |
help: Replace with `Path(...).exists()`

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:50:1
   |
48 |         if not os.path.exists(prompt_dir):
49 |             return 0.0
50 |             
   | ^^^^^^^^^^^^
51 |         prompty_files = [f for f in os.listdir(prompt_dir) if f.endswith('.prompty')]
52 |         if not prompty_files:
   |
help: Remove whitespace from blank line

PTH208 Use `pathlib.Path.iterdir()` instead.
  --> src\core\prompt_linter.py:51:37
   |
49 |             return 0.0
50 |             
51 |         prompty_files = [f for f in os.listdir(prompt_dir) if f.endswith('.prompty')]
   |                                     ^^^^^^^^^^
52 |         if not prompty_files:
53 |             return 0.0
   |

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:54:1
   |
52 |         if not prompty_files:
53 |             return 0.0
54 |             
   | ^^^^^^^^^^^^
55 |         total_prompts = len(prompty_files)
56 |         valid_prompts = 0
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:57:1
   |
55 |         total_prompts = len(prompty_files)
56 |         valid_prompts = 0
57 |         
   | ^^^^^^^^
58 |         for pfile in prompty_files:
59 |             path = os.path.join(prompt_dir, pfile)
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\core\prompt_linter.py:59:20
   |
58 |         for pfile in prompty_files:
59 |             path = os.path.join(prompt_dir, pfile)
   |                    ^^^^^^^^^^^^
60 |             vars = self.parse_prompty_vars(path)
61 |             # For now, if it parses vars, it's valid. 
   |

W291 [*] Trailing whitespace
  --> src\core\prompt_linter.py:61:54
   |
59 |             path = os.path.join(prompt_dir, pfile)
60 |             vars = self.parse_prompty_vars(path)
61 |             # For now, if it parses vars, it's valid. 
   |                                                      ^
62 |             # Integration check would happen during mutation phase.
63 |             if vars is not None:
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\core\prompt_linter.py:65:1
   |
63 |             if vars is not None:
64 |                 valid_prompts += 1
65 |                 
   | ^^^^^^^^^^^^^^^^
66 |         return (valid_prompts / total_prompts) * 100.0
   |
help: Remove whitespace from blank line

F401 [*] `os` imported but unused
 --> src\core\report_engine.py:2:8
  |
1 | # report_engine.py
2 | import os
  |        ^^
3 | import sys
4 | from datetime import datetime
  |
help: Remove unused import: `os`

E402 Module level import not at top of file
  --> src\core\report_engine.py:12:1
   |
10 |     sys.path.append(str(current_dir))
11 |
12 | import utils
   | ^^^^^^^^^^^^
13 | from ui import HUD
   |

E402 Module level import not at top of file
  --> src\core\report_engine.py:13:1
   |
12 | import utils
13 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
   |

W291 Trailing whitespace
  --> src\core\report_engine.py:19:66
   |
17 |     """
18 |     Enforces Persona-driven reporting standards.
19 |     Prevents "generic engineer" hallucinations by algorithmically 
   |                                                                  ^
20 |     injecting the correct voice and signature.
21 |     """
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\core\report_engine.py:22:1
   |
20 |     injecting the correct voice and signature.
21 |     """
22 |     
   | ^^^^
23 |     def __init__(self, project_root: str | Path | None = None) -> None:
24 |         self.root = Path(project_root) if project_root else Path.cwd()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\report_engine.py:29:1
   |
27 |         legacy = self.config.get("persona") or self.config.get("Persona") or "ALFRED"
28 |         self.persona = str(self.config.get("system", {}).get("persona", legacy)).upper()
29 |         
   | ^^^^^^^^
30 |         # Ensure HUD is synced
31 |         HUD.PERSONA = self.persona
   |
help: Remove whitespace from blank line

W291 Trailing whitespace
  --> src\core\report_engine.py:68:37
   |
66 |     def signature(self) -> str:
67 |         """
68 |         The anti-hallucination seal. 
   |                                     ^
69 |         Returns the ONLY authorized signature for the active persona.
70 |         """
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\core\report_engine.py:79:33
   |
77 |         """Combines all elements into a final markdown string."""
78 |         return (
79 |             self.header(title) + 
   |                                 ^
80 |             "\n" + body + 
81 |             "\n" + self.signature()
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\core\report_engine.py:80:26
   |
78 |         return (
79 |             self.header(title) + 
80 |             "\n" + body + 
   |                          ^
81 |             "\n" + self.signature()
82 |         )
   |
help: Remove trailing whitespace

W292 [*] No newline at end of file
  --> src\core\report_engine.py:82:10
   |
80 |             "\n" + body + 
81 |             "\n" + self.signature()
82 |         )
   |          ^
   |
help: Add trailing newline

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\core\set_persona.py:12:1
   |
10 | from datetime import datetime
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from src.core import personas
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src\core\set_persona.py:12:1
   |
10 | from datetime import datetime
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from src.core import personas
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src\core\set_persona.py:12:1
   |
10 | from datetime import datetime
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from src.core import personas
   |

F401 [*] `typing.List` imported but unused
  --> src\core\set_persona.py:12:31
   |
10 | from datetime import datetime
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   |                               ^^^^
13 |
14 | from src.core import personas
   |
help: Remove unused import

F401 [*] `typing.Tuple` imported but unused
  --> src\core\set_persona.py:12:47
   |
10 | from datetime import datetime
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   |                                               ^^^^^
13 |
14 | from src.core import personas
   |
help: Remove unused import

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\core\set_persona.py:23:24
   |
21 |     """
22 |
23 |     ALLOWED_PERSONAS = ["O.D.I.N.", "ALFRED"]
   |                        ^^^^^^^^^^^^^^^^^^
24 |
25 |     def __init__(self, target_root: Optional[Path] = None) -> None:
   |

UP045 [*] Use `X | None` for type annotations
  --> src\core\set_persona.py:25:37
   |
23 |     ALLOWED_PERSONAS = ["O.D.I.N.", "ALFRED"]
24 |
25 |     def __init__(self, target_root: Optional[Path] = None) -> None:
   |                                     ^^^^^^^^^^^^^^
26 |         self.script_path = Path(__file__).absolute()
27 |         self.project_root = target_root or self.script_path.parent.parent.parent
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\set_persona.py:32:30
   |
30 |             self.base_dir / "config.json"
31 |         ]
32 |         self.current_config: Dict[str, Any] = self._load_union_config()
   |                              ^^^^
33 |         self.old_persona: str = self._extract_persona(self.current_config)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\set_persona.py:35:37
   |
33 |         self.old_persona: str = self._extract_persona(self.current_config)
34 |
35 |     def _load_union_config(self) -> Dict[str, Any]:
   |                                     ^^^^
36 |         """Loads and merges configuration from known paths."""
37 |         merged: Dict[str, Any] = {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\set_persona.py:37:17
   |
35 |     def _load_union_config(self) -> Dict[str, Any]:
36 |         """Loads and merges configuration from known paths."""
37 |         merged: Dict[str, Any] = {}
   |                 ^^^^
38 |         for path in self.config_paths:
39 |             if path.exists():
   |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\set_persona.py:43:24
   |
41 |                     with path.open("r", encoding="utf-8") as f:
42 |                         merged.update(json.load(f))
43 |                 except (json.JSONDecodeError, IOError):
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
44 |                     continue
45 |         return merged
   |
help: Replace with builtin `OSError`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\core\set_persona.py:47:40
   |
45 |         return merged
46 |
47 |     def _extract_persona(self, config: Dict[str, Any]) -> str:
   |                                        ^^^^
48 |         """Extracts the persona name from config, defaulting to ALFRED."""
49 |         val = config.get("system", {}).get("persona", "ALFRED")
   |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\set_persona.py:68:24
   |
66 |                     with path.open("w", encoding="utf-8") as f:
67 |                         json.dump(data, f, indent=4)
68 |                 except (json.JSONDecodeError, IOError):
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |                     continue
   |
help: Replace with builtin `OSError`

UP045 [*] Use `X | None` for type annotations
  --> src\core\set_persona.py:71:41
   |
69 |                     continue
70 |
71 |     def _get_alfred_suggestion(self) -> Optional[str]:
   |                                         ^^^^^^^^^^^^^
72 |         """Retrieves the top suggestion from Alfred's cache."""
73 |         for ext in ['.qmd', '.md']:
   |
help: Convert to `X | None`

E741 Ambiguous variable name: `l`
  --> src\core\set_persona.py:78:44
   |
76 |                 try:
77 |                     content = p.read_text(encoding="utf-8")
78 |                     lines = [l.strip() for l in content.split('\n') if l.strip().startswith('- ')]
   |                                            ^
79 |                     if lines:
80 |                         return lines[0]
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\set_persona.py:81:24
   |
79 |                     if lines:
80 |                         return lines[0]
81 |                 except IOError:
   |                        ^^^^^^^
82 |                     pass
83 |         return None
   |
help: Replace `IOError` with builtin `OSError`

W293 [*] Blank line contains whitespace
  --> src\core\set_persona.py:95:1
   |
93 |         print("  Your documentation remains intact. I've been... observing.")
94 |         print("")
95 |         
   | ^^^^^^^^
96 |         suggestion = self._get_alfred_suggestion()
97 |         if suggestion:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:101:1
    |
 99 |             print(f"     {suggestion}")
100 |             print("")
101 |         
    | ^^^^^^^^
102 |         print("  [Alfred's Whisper]: \"Shall I prepare the usual, sir?\"")
103 |         print("=" * 60 + "\n")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:110:1
    |
108 |         print("Documentation (AGENTS.md) will be re-themed to O.D.I.N. voice.")
109 |         print("Original files will be preserved in .corvus_quarantine/")
110 |         
    | ^^^^^^^^
111 |         if not interactive:
112 |             return True
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:113:1
    |
111 |         if not interactive:
112 |             return True
113 |             
    | ^^^^^^^^^^^^
114 |         try:
115 |             choice = input("Proceed? [y/N]: ").strip().lower()
    |
help: Remove whitespace from blank line

UP024 [*] Replace aliased errors with `OSError`
   --> src\core\set_persona.py:127:16
    |
125 |             with log_path.open("a", encoding="utf-8") as f:
126 |                 f.write(f"[{timestamp}] {self.old_persona} -> {new_persona}\n")
127 |         except IOError:
    |                ^^^^^^^
128 |             pass
    |
help: Replace `IOError` with builtin `OSError`

UP045 [*] Use `X | None` for type annotations
   --> src\core\set_persona.py:130:30
    |
128 |             pass
129 |
130 |     def switch(self, target: Optional[str] = None) -> None:
    |                              ^^^^^^^^^^^^^
131 |         """
132 |         Executes the persona transition logic.
    |
help: Convert to `X | None`

E701 Multiple statements on one line (colon)
   --> src\core\set_persona.py:148:33
    |
146 |             try:
147 |                 choice = input("\nSelect Persona [1/2]: ").strip()
148 |                 if choice == "1": new_persona = "O.D.I.N."
    |                                 ^
149 |                 elif choice == "2": new_persona = "ALFRED"
150 |                 else:
    |

E701 Multiple statements on one line (colon)
   --> src\core\set_persona.py:149:35
    |
147 |                 choice = input("\nSelect Persona [1/2]: ").strip()
148 |                 if choice == "1": new_persona = "O.D.I.N."
149 |                 elif choice == "2": new_persona = "ALFRED"
    |                                   ^
150 |                 else:
151 |                     print("Invalid choice.")
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> src\core\set_persona.py:170:9
    |
169 |           # [ALFRED] Fire the HUD transition ceremony
170 | /         try:
171 | |             HUD.transition_ceremony(self.old_persona, new_persona)
172 | |         except Exception:
173 | |             pass  # Graceful fallback if HUD import fails
    | |________________^
174 |
175 |           print(f"\nâœ… Persona set to: {new_persona}")
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\core\set_persona.py:172:9
    |
170 |           try:
171 |               HUD.transition_ceremony(self.old_persona, new_persona)
172 | /         except Exception:
173 | |             pass  # Graceful fallback if HUD import fails
    | |________________^
174 |
175 |           print(f"\nâœ… Persona set to: {new_persona}")
    |

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:177:1
    |
175 |         print(f"\nâœ… Persona set to: {new_persona}")
176 |         print("Applying operational policy...")
177 |         
    | ^^^^^^^^
178 |         self._apply_policy(new_persona)
179 |         self._log_audit(new_persona)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:185:1
    |
183 |         try:
184 |             strategy = personas.get_strategy(persona, str(self.project_root))
185 |             
    | ^^^^^^^^^^^^
186 |             # documentation re-theme for O.D.I.N.
187 |             if self.old_persona == "ALFRED" and persona == "O.D.I.N.":
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:193:1
    |
191 |                     for res in results:
192 |                         print(f"    - {res}")
193 |             
    | ^^^^^^^^^^^^
194 |             results = strategy.enforce_policy()
195 |             for res in results:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\set_persona.py:197:1
    |
195 |             for res in results:
196 |                 print(f"  > {res}")
197 |                 
    | ^^^^^^^^^^^^^^^^
198 |         except Exception as e:
199 |             print(f"âš ï¸ Policy enforcement warning: {e}")
    |
help: Remove whitespace from blank line

UP045 [*] Use `X | None` for type annotations
   --> src\core\set_persona.py:201:37
    |
199 |             print(f"âš ï¸ Policy enforcement warning: {e}")
200 |
201 | def set_persona(persona: str, root: Optional[str] = None) -> None:
    |                                     ^^^^^^^^^^^^^
202 |     """Convenience function for external callers (e.g. tests, ravens)."""
203 |     manager = PersonaManager(target_root=Path(root) if root else None)
    |
help: Convert to `X | None`

W292 [*] No newline at end of file
   --> src\core\set_persona.py:213:11
    |
212 | if __name__ == "__main__":
213 |     main()
    |           ^
    |
help: Add trailing newline

E501 Line too long (106 > 100)
  --> src\core\sv_engine.py:83:101
   |
81 |         remote_path_str = k_config.get("cores", {}).get(active) or \
82 |                           self.config.get("KnowledgeCore") or \
83 |                           str(Path(self.config.get("system", {}).get("framework_root", "")) / "skills_db")
   |                                                                                                     ^^^^^^
84 |         if remote_path_str:
85 |             remote_path = Path(remote_path_str)
   |

W293 [*] Blank line contains whitespace
   --> src\core\sv_engine.py:153:1
    |
151 |             HUD.box_row("Match", match_str, HUD.DIM)
152 |             HUD.box_row("Confidence", f"{HUD.progress_bar(top['score'])} {top['score']:.2f}", color)
153 |             
    | ^^^^^^^^^^^^
154 |             if top['trigger'] == 'WEB_FALLBACK':
155 |                  HUD.box_separator()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\core\sv_engine.py:170:1
    |
168 |         if top['score'] <= self.THRESHOLDS["ACCURACY"] and top['trigger'] != 'WEB_FALLBACK':
169 |             return
170 |         
    | ^^^^^^^^
171 |         if top['trigger'] == 'WEB_FALLBACK':
172 |             return
    |
help: Remove whitespace from blank line

E501 Line too long (103 > 100)
   --> src\core\sv_engine.py:233:101
    |
231 |         if not top or top['score'] < 0.6:
232 |             # Zero-Hit Fallback: Brave Web Search
233 |             HUD.persona_log("INFO", "SovereignEngine: Low confidence match. Creating Web Fallback...") 
    |                                                                                                     ^^^
234 |             searcher = BraveSearch()
235 |             web_results = searcher.search(query)
    |

W291 [*] Trailing whitespace
   --> src\core\sv_engine.py:233:103
    |
231 |         if not top or top['score'] < 0.6:
232 |             # Zero-Hit Fallback: Brave Web Search
233 |             HUD.persona_log("INFO", "SovereignEngine: Low confidence match. Creating Web Fallback...") 
    |                                                                                                       ^
234 |             searcher = BraveSearch()
235 |             web_results = searcher.search(query)
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\core\sv_engine.py:236:1
    |
234 |             searcher = BraveSearch()
235 |             web_results = searcher.search(query)
236 |             
    | ^^^^^^^^^^^^
237 |             if web_results:
238 |                 formatted_results = "\n".join(
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\core\sv_engine.py:246:47
    |
244 |                     "data": formatted_results,
245 |                     "is_global": False,
246 |                     "web_results": web_results 
    |                                               ^
247 |                 }
    |
help: Remove trailing whitespace

E501 Line too long (102 > 100)
   --> src\core\sv_engine.py:282:101
    |
281 |         term = unknown_terms[0]
282 |         HUD.persona_log("INFO", f"Raven's Eye: Unknown term detected '{term}'. Seeking definition...")
    |                                                                                                     ^^
283 |
284 |         # 2. Trigger Brave Search
    |

E501 Line too long (110 > 100)
   --> src\core\sv_engine.py:300:101
    |
298 |         # 4. Inject into Cortex (Session-local)
299 |         cortex = Cortex(str(self.project_root), str(self.base_path))
300 |         cortex.add_node(f"LEXICON:{term}", {"definition": definition, "source": "BraveSearch", "query": term})
    |                                                                                                     ^^^^^^^^^^
301 |         
302 |         # [ALFRED] Note: This improves session-level intent mapping for subsequent queries
    |

W293 [*] Blank line contains whitespace
   --> src\core\sv_engine.py:301:1
    |
299 |         cortex = Cortex(str(self.project_root), str(self.base_path))
300 |         cortex.add_node(f"LEXICON:{term}", {"definition": definition, "source": "BraveSearch", "query": term})
301 |         
    | ^^^^^^^^
302 |         # [ALFRED] Note: This improves session-level intent mapping for subsequent queries
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\core\sv_engine.py:339:11
    |
338 | if __name__ == "__main__":
339 |     main()
    |           ^
    |
help: Add trailing newline

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:13:1
   |
11 |     # Set environment variable for any child processes
12 |     os.environ["PYTHONIOENCODING"] = "utf-8"
13 |     
   | ^^^^
14 |     # Reconfigure stdout/stderr for UTF-8
15 |     for stream in [sys.stdout, sys.stderr]:
   |
help: Remove whitespace from blank line

SIM105 Use `contextlib.suppress(OSError, AttributeError)` instead of `try`-`except`-`pass`
  --> src\core\ui.py:17:13
   |
15 |       for stream in [sys.stdout, sys.stderr]:
16 |           if stream and hasattr(stream, "reconfigure"):
17 | /             try:
18 | |                 stream.reconfigure(encoding="utf-8", errors="replace")
19 | |             except (OSError, AttributeError):
20 | |                 pass
   | |____________________^
21 |       
22 |       # Enable Windows Console Virtual Terminal Processing (ANSI support)
   |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError, AttributeError): ...`

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:21:1
   |
19 |             except (OSError, AttributeError):
20 |                 pass
21 |     
   | ^^^^
22 |     # Enable Windows Console Virtual Terminal Processing (ANSI support)
23 |     try:
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\core\ui.py:35:1
   |
33 |     """
34 |     Hyper-Refined User Interface (HUD) Class.
35 |     
   | ^^^^
36 |     Provides ANSI-colored terminal output primitives for the Corvus Star framework.
37 |     Strictly follows the Linscott Standard for "Iron Clad" reliability.
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:62:1
   |
60 |         if HUD._INITIALIZED:
61 |             return
62 |             
   | ^^^^^^^^^^^^
63 |         # If PERSONA was set manually before initialization, respect it.
64 |         # But how do we know if it was "manual"? 
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\core\ui.py:64:49
   |
63 |         # If PERSONA was set manually before initialization, respect it.
64 |         # But how do we know if it was "manual"? 
   |                                                 ^
65 |         # Default is "ALFRED". If it's something else, maybe it was manual.
66 |         # For simplicity, if we are initializing, we load if config exists.
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:67:1
   |
65 |         # Default is "ALFRED". If it's something else, maybe it was manual.
66 |         # For simplicity, if we are initializing, we load if config exists.
67 |             
   | ^^^^^^^^^^^^
68 |         try:
69 |             from pathlib import Path
   |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
  --> src\core\ui.py:69:13
   |
68 |           try:
69 | /             from pathlib import Path
70 | |             import json
   | |_______________________^
71 |               
72 |               # Resolve root relative to this file: src/core/ui.py -> project_root
   |
help: Organize imports

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:71:1
   |
69 |             from pathlib import Path
70 |             import json
71 |             
   | ^^^^^^^^^^^^
72 |             # Resolve root relative to this file: src/core/ui.py -> project_root
73 |             root = Path(__file__).parent.parent.parent.resolve()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\core\ui.py:75:1
   |
73 |             root = Path(__file__).parent.parent.parent.resolve()
74 |             config_path = root / ".agent" / "config.json"
75 |             
   | ^^^^^^^^^^^^
76 |             if config_path.exists():
77 |                 with config_path.open("r", encoding="utf-8") as f:
   |
help: Remove whitespace from blank line

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\core\ui.py:82:9
   |
80 |                       persona = data.get("system", {}).get("persona", legacy_persona)
81 |                       HUD.PERSONA = str(persona).upper()
82 | /         except Exception:
83 | |             pass # Stay as ALFRED
   | |________________^
84 |           finally:
85 |               HUD._INITIALIZED = True
   |

W293 Blank line contains whitespace
  --> src\core\ui.py:91:1
   |
89 |         """
90 |         Retrieves dialogue from the vector DB or returns fallback.
91 |         
   | ^^^^^^^^
92 |         Args:
93 |             intent: The semantic intent key to look up.
   |
help: Remove whitespace from blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\core\ui.py:101:50
    |
100 |       # [ALFRED] Theme Registry: Add new persona themes by adding an entry here.
101 |       _THEME_REGISTRY: dict[str, dict[str, str]] = {
    |  __________________________________________________^
102 | |         "O.D.I.N.": {
103 | |             "main": "\033[31m",   # RED
104 | |             "dim": "\033[35m",    # MAGENTA
105 | |             "accent": "\033[33m", # YELLOW
106 | |             "success": "\033[32m",
107 | |             "warning": "\033[33m",
108 | |             "error": "\033[31m",
109 | |             "title": "Î© O.D.I.N. ENGINE Î©",
110 | |             "prefix": "[O.D.I.N.]",
111 | |             "war_title": "THE WAR ROOM (CONFLICT RADAR)",
112 | |             "trace_label": "TRACE (LIES)",
113 | |             "truth_label": "TRUTH (LAW)",
114 | |             "greeting": "Speak, wanderer. The Hooded One listens.",
115 | |             "success_msg": "It is done. The rune is carved in stone.",
116 | |             "error_msg": "The thread snaps. Fate denies this path.",
117 | |             "warning_msg": "Gjallarhorn sounds low. Heed this omen."
118 | |         },
119 | |         "ALFRED": {
120 | |             "main": "\033[36m",   # CYAN
121 | |             "dim": "\033[2;36m",  # CYAN_DIM
122 | |             "accent": "\033[32m", # GREEN
123 | |             "success": "\033[32m",
124 | |             "warning": "\033[33m",
125 | |             "error": "\033[31m",
126 | |             "title": "C* BUTLER INTERFACE",
127 | |             "prefix": "[ALFRED]",
128 | |             "war_title": "THE BATCAVE (ANOMALY DETECTOR)",
129 | |             "trace_label": "EVENT LOG",
130 | |             "truth_label": "KNOWN TRUTH",
131 | |             "greeting": "Good day, sir. How may I be of service?",
132 | |             "success_msg": "The task is complete, sir. Everything is in order.",
133 | |             "error_msg": "I'm afraid we've encountered a difficulty, sir.",
134 | |             "warning_msg": "A word of caution, sir, if I may."
135 | |         },
136 | |     }
    | |_____^
137 |
138 |       @staticmethod
    |

W293 Blank line contains whitespace
   --> src\core\ui.py:193:1
    |
191 |         """
192 |         Log with persona prefix for major announcements.
193 |         
    | ^^^^^^^^
194 |         Args:
195 |             level: The severity level (INFO, SUCCESS, WARN, ERROR).
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\ui.py:229:1
    |
227 |         """
228 |         Renders the top implementation of a box with a title.
229 |         
    | ^^^^^^^^
230 |         Args:
231 |             title: The text to display in the center header.
    |
help: Remove whitespace from blank line

E501 Line too long (125 > 100)
   --> src\core\ui.py:253:101
    |
252 |         # Glow effect
253 |         print(f"{dim_color}â”Œ{'â”€'*pad_l} {main_color}{HUD.BOLD}{display_title}{HUD.RESET}{dim_color} {'â”€'*pad_r}â”{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
254 |
255 |     @staticmethod
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> src\core\ui.py:256:36
    |
255 |     @staticmethod
256 |     def box_row(label: str, value: Any, color: str | None = None, dim_label: bool = False, width: int | None = None) -> None:
    |                                    ^^^
257 |         """
258 |         Renders a row within a box.
    |

E501 Line too long (125 > 100)
   --> src\core\ui.py:256:101
    |
255 |     @staticmethod
256 |     def box_row(label: str, value: Any, color: str | None = None, dim_label: bool = False, width: int | None = None) -> None:
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
257 |         """
258 |         Renders a row within a box.
    |

W293 Blank line contains whitespace
   --> src\core\ui.py:259:1
    |
257 |         """
258 |         Renders a row within a box.
259 |         
    | ^^^^^^^^
260 |         Args:
261 |             label: The key string (left side).
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\core\ui.py:328:1
    |
326 |         """
327 |         Generates a progress bar string.
328 |         
    | ^^^^^^^^
329 |         Args:
330 |             val: Float between 0.0 and 1.0.
    |
help: Remove whitespace from blank line

E501 Line too long (106 > 100)
   --> src\core\ui.py:336:101
    |
334 |         safe_val = max(0.0, min(1.0, val))
335 |         blocks = int(safe_val * width)
336 |         bar = f"{HUD.GREEN}" + "â–ˆ" * blocks + f"{HUD.GREEN_DIM}" + "â–‘" * (width - blocks) + f"{HUD.RESET}"
    |                                                                                                     ^^^^^^
337 |         return bar
    |

W293 Blank line contains whitespace
   --> src\core\ui.py:343:1
    |
341 |         """
342 |         Generates an ASCII Sparkline.
343 |         
    | ^^^^^^^^
344 |         Args:
345 |             data: List of float values.
    |
help: Remove whitespace from blank line

N806 Variable `BARS` in function should be lowercase
   --> src\core\ui.py:348:9
    |
346 |             max_points: Maximum characters to render.
347 |         """
348 |         BARS = " â–‚â–ƒâ–„â–…â–†â–‡â–ˆ"
    |         ^^^^
349 |         if not data: return ""
    |

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:349:20
    |
347 |         """
348 |         BARS = " â–‚â–ƒâ–„â–…â–†â–‡â–ˆ"
349 |         if not data: return ""
    |                    ^
350 |
351 |         try:
    |

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:354:27
    |
352 |             # [ALFRED] Filter non-numeric to prevent crashes
353 |             visible = [float(x) for x in data[-max_points:] if isinstance(x, (int, float, str))]
354 |             if not visible: return ""
    |                           ^
355 |
356 |             min_val = min(visible)
    |

W293 [*] Blank line contains whitespace
   --> src\core\ui.py:377:1
    |
375 |         ts = datetime.now().strftime("%H:%M:%S")
376 |         theme = HUD.get_theme()
377 |         
    | ^^^^^^^^
378 |         color = theme["main"]
379 |         if level == "WARN": color = theme["warning"]
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:379:27
    |
378 |         color = theme["main"]
379 |         if level == "WARN": color = theme["warning"]
    |                           ^
380 |         if level == "FAIL": color = theme["error"]
381 |         if level == "PASS": color = theme["success"]
    |

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:380:27
    |
378 |         color = theme["main"]
379 |         if level == "WARN": color = theme["warning"]
380 |         if level == "FAIL": color = theme["error"]
    |                           ^
381 |         if level == "PASS": color = theme["success"]
382 |         if level == "CRITICAL": color = theme["error"] # Default to error for critical
    |

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:381:27
    |
379 |         if level == "WARN": color = theme["warning"]
380 |         if level == "FAIL": color = theme["error"]
381 |         if level == "PASS": color = theme["success"]
    |                           ^
382 |         if level == "CRITICAL": color = theme["error"] # Default to error for critical
    |

E701 Multiple statements on one line (colon)
   --> src\core\ui.py:382:31
    |
380 |         if level == "FAIL": color = theme["error"]
381 |         if level == "PASS": color = theme["success"]
382 |         if level == "CRITICAL": color = theme["error"] # Default to error for critical
    |                               ^
383 |
384 |         print(f"{HUD.DIM}[{ts}]{HUD.RESET} {color}[{level}]{HUD.RESET} {msg} {HUD.DIM}{detail}{HUD.RESET}")
    |

E501 Line too long (107 > 100)
   --> src\core\ui.py:384:101
    |
382 |         if level == "CRITICAL": color = theme["error"] # Default to error for critical
383 |
384 |         print(f"{HUD.DIM}[{ts}]{HUD.RESET} {color}[{level}]{HUD.RESET} {msg} {HUD.DIM}{detail}{HUD.RESET}")
    |                                                                                                     ^^^^^^^
385 |
386 |     @staticmethod
    |

W293 Blank line contains whitespace
   --> src\core\ui.py:390:1
    |
388 |         """
389 |         Shorthand for a yellow warning log.
390 |         
    | ^^^^^^^^
391 |         Args:
392 |             msg: The warning message as a string.
    |
help: Remove whitespace from blank line

E501 Line too long (115 > 100)
   --> src\core\ui.py:402:101
    |
400 |         width = 60
401 |         if label:
402 |             print(f"{theme['dim']}â”€â”€ {theme['accent']}{label}{theme['dim']} {'â”€'*(width-len(label)-4)}{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^
403 |         else:
404 |             print(f"{theme['dim']}{'â”€'*width}{HUD.RESET}")
    |

E501 Line too long (174 > 100)
   --> src\core\ui.py:416:100
    |
414 | â€¦
415 | â€¦
416 | â€¦ger\n\n| Timestamp | Persona | Reason | Details |\n| :--- | :--- | :--- | :--- |\n", encoding='utf-8')
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
417 | â€¦
418 | â€¦
    |

I001 [*] Import block is un-sorted or un-formatted
 --> src\core\utils.py:1:1
  |
1 | / import os
2 | | import re
3 | | import sys
4 | | import threading
5 | | import queue
6 | | import json
7 | | from pathlib import Path
  | |________________________^
8 |
9 |   try:
  |
help: Organize imports

W293 [*] Blank line contains whitespace
  --> src\core\utils.py:24:1
   |
22 |     if not path.exists():
23 |         return {}
24 |         
   | ^^^^^^^^
25 |     try:
26 |         with open(path, 'r', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\core\utils.py:26:14
   |
25 |     try:
26 |         with open(path, 'r', encoding='utf-8') as f:
   |              ^^^^
27 |             if msvcrt:
28 |                 # Windows-specific: shared read lock (LK_NBLCK)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\core\utils.py:26:25
   |
25 |     try:
26 |         with open(path, 'r', encoding='utf-8') as f:
   |                         ^^^
27 |             if msvcrt:
28 |                 # Windows-specific: shared read lock (LK_NBLCK)
   |
help: Remove mode argument

SIM105 Use `contextlib.suppress(IOError, OSError)` instead of `try`-`except`-`pass`
  --> src\core\utils.py:29:17
   |
27 |               if msvcrt:
28 |                   # Windows-specific: shared read lock (LK_NBLCK)
29 | /                 try:
30 | |                     msvcrt.locking(f.fileno(), msvcrt.LK_NBLCK, os.path.getsize(path))
31 | |                 except (IOError, OSError):
32 | |                     pass
   | |________________________^
33 |               return json.load(f)
34 |       except (json.JSONDecodeError, IOError, OSError):
   |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(IOError, OSError): ...`

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\core\utils.py:30:65
   |
28 |                 # Windows-specific: shared read lock (LK_NBLCK)
29 |                 try:
30 |                     msvcrt.locking(f.fileno(), msvcrt.LK_NBLCK, os.path.getsize(path))
   |                                                                 ^^^^^^^^^^^^^^^
31 |                 except (IOError, OSError):
32 |                     pass
   |
help: Replace with `Path(...).stat().st_size`

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\utils.py:31:24
   |
29 |                 try:
30 |                     msvcrt.locking(f.fileno(), msvcrt.LK_NBLCK, os.path.getsize(path))
31 |                 except (IOError, OSError):
   |                        ^^^^^^^^^^^^^^^^^^
32 |                     pass
33 |             return json.load(f)
   |
help: Replace with builtin `OSError`

UP024 [*] Replace aliased errors with `OSError`
  --> src\core\utils.py:34:12
   |
32 |                     pass
33 |             return json.load(f)
34 |     except (json.JSONDecodeError, IOError, OSError):
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
35 |         return {}
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\core\utils.py:43:16
   |
41 | def sanitize_query(text: str) -> str:
42 |     """[ALFRED] Purify user input of shell hazards and noise."""
43 |     if not text: return ""
   |                ^
44 |     clean = re.sub(r'[;&|`$(){}<>\\!]', '', text)
45 |     return " ".join(clean.split())
   |

W293 [*] Blank line contains whitespace
  --> src\core\utils.py:51:1
   |
49 |     print(prompt, end="", flush=True)
50 |     q = queue.Queue()
51 |     
   | ^^^^
52 |     def _read() -> None:
53 |         """Reads one line from sys.stdin and puts it into the queue."""
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\core\utils.py:54:12
   |
52 |     def _read() -> None:
53 |         """Reads one line from sys.stdin and puts it into the queue."""
54 |         try: q.put(sys.stdin.readline().strip().lower())
   |            ^
55 |         except EOFError: q.put(None)
   |

E701 Multiple statements on one line (colon)
  --> src\core\utils.py:55:24
   |
53 |         """Reads one line from sys.stdin and puts it into the queue."""
54 |         try: q.put(sys.stdin.readline().strip().lower())
55 |         except EOFError: q.put(None)
   |                        ^
56 |
57 |     t = threading.Thread(target=_read)
   |

E701 Multiple statements on one line (colon)
  --> src\core\utils.py:60:8
   |
58 |     t.daemon = True
59 |     t.start()
60 |     try: return q.get(block=True, timeout=timeout) or "n"
   |        ^
61 |     except queue.Empty: return "n"
   |

E701 Multiple statements on one line (colon)
  --> src\core\utils.py:61:23
   |
59 |     t.start()
60 |     try: return q.get(block=True, timeout=timeout) or "n"
61 |     except queue.Empty: return "n"
   |                       ^
   |

E402 Module level import not at top of file
  --> src\cstar\core\antigravity_bridge.py:14:1
   |
12 |     sys.path.append(str(project_root))
13 |
14 | from src.sentinel.code_sanitizer import sanitize_code
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |
16 | # Constants
   |

ANN001 Missing type annotation for function argument `client`
  --> src\cstar\core\antigravity_bridge.py:33:24
   |
31 | _MODEL_CACHE = {} # Stores available models per API key
32 |
33 | def _get_optimal_model(client, api_key: str, persona: str) -> str:
   |                        ^^^^^^
34 |     """Discovers available models and routes based on workload."""
35 |     global _MODEL_CACHE
   |

ANN201 Missing return type annotation for public function `init_client`
  --> src\cstar\core\antigravity_bridge.py:69:5
   |
67 |     return available[0] if available else safe_default
68 |
69 | def init_client():
   |     ^^^^^^^^^^^
70 |     """Initializes the google.genai client exclusively using the Daemon key."""
71 |     global CLIENT
   |
help: Add return type annotation: `None`

E501 Line too long (141 > 100)
  --> src\cstar\core\antigravity_bridge.py:86:101
   |
84 | â€¦
85 | â€¦
86 | â€¦t found in .env.local (Loaded: {loaded}). Forcing Simulation Mode to protect credits.")
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 | â€¦
   |

E501 Line too long (114 > 100)
  --> src\cstar\core\antigravity_bridge.py:90:101
   |
89 |     except ImportError as e:
90 |         logging.error(f"Missing dependency: {e}. Please ensure 'google-genai' and 'python-dotenv' are installed.")
   |                                                                                                     ^^^^^^^^^^^^^^
91 |         CLIENT = None
   |

ANN201 Missing return type annotation for public function `handle_client`
  --> src\cstar\core\antigravity_bridge.py:93:11
   |
91 |         CLIENT = None
92 |
93 | async def handle_client(reader, writer):
   |           ^^^^^^^^^^^^^
94 |     """Handles incoming JSON payloads from uplink.py."""
95 |     addr = writer.get_extra_info('peername')
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `reader`
  --> src\cstar\core\antigravity_bridge.py:93:25
   |
91 |         CLIENT = None
92 |
93 | async def handle_client(reader, writer):
   |                         ^^^^^^
94 |     """Handles incoming JSON payloads from uplink.py."""
95 |     addr = writer.get_extra_info('peername')
   |

ANN001 Missing type annotation for function argument `writer`
  --> src\cstar\core\antigravity_bridge.py:93:33
   |
91 |         CLIENT = None
92 |
93 | async def handle_client(reader, writer):
   |                                 ^^^^^^
94 |     """Handles incoming JSON payloads from uplink.py."""
95 |     addr = writer.get_extra_info('peername')
   |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\cstar\core\antigravity_bridge.py:125:63
    |
123 |         writer.close()
124 |
125 | async def process_request(query: str, context: dict, api_key: str = None) -> dict:
    |                                                               ^^^
126 |     """
127 |     Assembles the prompt and calls the LLM.
    |
help: Convert to `T | None`

E501 Line too long (134 > 100)
   --> src\cstar\core\antigravity_bridge.py:144:101
    |
143 |     if previous_attempt:
144 |         full_prompt += f"\n[SYSTEM: PREVIOUS CODE]\n{previous_attempt}\n\n[INSTRUCTION]\nFix the code above based on the error trace."
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
145 |
146 |     if target_interface:
    |

E501 Line too long (105 > 100)
   --> src\cstar\core\antigravity_bridge.py:156:101
    |
154 |             try:
155 |                 from google import genai
156 |                 logging.info(f"Initializing cached client for requested API key (persona: {persona})...")
    |                                                                                                     ^^^^^
157 |                 _CLIENT_CACHE[api_key] = genai.Client(api_key=api_key)
158 |             except Exception as e:
    |

E501 Line too long (113 > 100)
   --> src\cstar\core\antigravity_bridge.py:193:101
    |
191 |                 if attempt < max_retries - 1:
192 |                     wait_time = 3 ** attempt # Exponential: 1s, 3s, 9s
193 |                     logging.warning(f"API throttled or unavailable ({e}). Waiting {wait_time}s to ping again...")
    |                                                                                                     ^^^^^^^^^^^^^
194 |
195 |                     # Force model re-discovery on next attempt in case models dropped offline
    |

E501 Line too long (102 > 100)
   --> src\cstar\core\antigravity_bridge.py:226:101
    |
224 |             # We try to extract JSON block regardless of tags or carriage returns
225 |             import re
226 |             json_match = re.search(r"```(?:json)?\s+(.*?)\s+```", raw_text, re.DOTALL | re.IGNORECASE)
    |                                                                                                     ^^
227 |             if json_match:
228 |                 json_str = json_match.group(1)
    |

ANN201 Missing return type annotation for public function `generate_simulation`
   --> src\cstar\core\antigravity_bridge.py:254:5
    |
254 | def generate_simulation(query, context):
    |     ^^^^^^^^^^^^^^^^^^^
255 |     """Deterministic responses for testing without credentials."""
256 |     persona = context.get("persona", "O.D.I.N.")
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
   --> src\cstar\core\antigravity_bridge.py:254:25
    |
254 | def generate_simulation(query, context):
    |                         ^^^^^
255 |     """Deterministic responses for testing without credentials."""
256 |     persona = context.get("persona", "O.D.I.N.")
    |

ANN001 Missing type annotation for function argument `context`
   --> src\cstar\core\antigravity_bridge.py:254:32
    |
254 | def generate_simulation(query, context):
    |                                ^^^^^^^
255 |     """Deterministic responses for testing without credentials."""
256 |     persona = context.get("persona", "O.D.I.N.")
    |

E501 Line too long (136 > 100)
   --> src\cstar\core\antigravity_bridge.py:262:101
    |
260 | â€¦
261 | â€¦
262 | â€¦    return 'BRIDGE_ACTIVE: This is a simulation because no credentials were found.'"
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
263 | â€¦
264 | â€¦
    |

ANN201 Missing return type annotation for public function `main`
   --> src\cstar\core\antigravity_bridge.py:277:11
    |
275 |     return {"status": "success", "data": {"insight": "Simulation Mode Active"}}
276 |
277 | async def main():
    |           ^^^^
278 |     init_client()
    |
help: Add return type annotation: `None`

I001 [*] Import block is un-sorted or un-formatted
 --> src\cstar\core\client.py:1:1
  |
1 | / import socket
2 | | import json
3 | | import sys
4 | | import os
5 | | import argparse
6 | | import time
7 | | from pathlib import Path
  | |________________________^
8 |
9 |   # Add project root to path
  |
help: Organize imports

F401 [*] `argparse` imported but unused
 --> src\cstar\core\client.py:5:8
  |
3 | import sys
4 | import os
5 | import argparse
  |        ^^^^^^^^
6 | import time
7 | from pathlib import Path
  |
help: Remove unused import: `argparse`

F401 [*] `time` imported but unused
 --> src\cstar\core\client.py:6:8
  |
4 | import os
5 | import argparse
6 | import time
  |        ^^^^
7 | from pathlib import Path
  |
help: Remove unused import: `time`

ANN201 Missing return type annotation for public function `ping_daemon`
  --> src\cstar\core\client.py:18:5
   |
16 | PORT = 50051
17 |
18 | def ping_daemon(host=HOST, port=PORT, timeout=1.0):
   |     ^^^^^^^^^^^
19 |     """
20 |     Pre-flight check to verify the Cortex Daemon is online.
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `host`
  --> src\cstar\core\client.py:18:17
   |
16 | PORT = 50051
17 |
18 | def ping_daemon(host=HOST, port=PORT, timeout=1.0):
   |                 ^^^^
19 |     """
20 |     Pre-flight check to verify the Cortex Daemon is online.
   |

ANN001 Missing type annotation for function argument `port`
  --> src\cstar\core\client.py:18:28
   |
16 | PORT = 50051
17 |
18 | def ping_daemon(host=HOST, port=PORT, timeout=1.0):
   |                            ^^^^
19 |     """
20 |     Pre-flight check to verify the Cortex Daemon is online.
   |

ANN001 Missing type annotation for function argument `timeout`
  --> src\cstar\core\client.py:18:39
   |
16 | PORT = 50051
17 |
18 | def ping_daemon(host=HOST, port=PORT, timeout=1.0):
   |                                       ^^^^^^^
19 |     """
20 |     Pre-flight check to verify the Cortex Daemon is online.
   |

ANN201 Missing return type annotation for public function `send_command`
  --> src\cstar\core\client.py:26:5
   |
24 |         pass
25 |
26 | def send_command(command, args=None, cwd=None):
   |     ^^^^^^^^^^^^
27 |     if args is None:
28 |         args = []
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `command`
  --> src\cstar\core\client.py:26:18
   |
24 |         pass
25 |
26 | def send_command(command, args=None, cwd=None):
   |                  ^^^^^^^
27 |     if args is None:
28 |         args = []
   |

ANN001 Missing type annotation for function argument `args`
  --> src\cstar\core\client.py:26:27
   |
24 |         pass
25 |
26 | def send_command(command, args=None, cwd=None):
   |                           ^^^^
27 |     if args is None:
28 |         args = []
   |

ANN001 Missing type annotation for function argument `cwd`
  --> src\cstar\core\client.py:26:38
   |
24 |         pass
25 |
26 | def send_command(command, args=None, cwd=None):
   |                                      ^^^
27 |     if args is None:
28 |         args = []
   |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> src\cstar\core\client.py:30:15
   |
28 |         args = []
29 |     if cwd is None:
30 |         cwd = os.getcwd()
   |               ^^^^^^^^^
31 |         
32 |     payload = {
   |
help: Replace with `Path.cwd()`

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:31:1
   |
29 |     if cwd is None:
30 |         cwd = os.getcwd()
31 |         
   | ^^^^^^^^
32 |     payload = {
33 |         "command": command,
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:37:1
   |
35 |         "cwd": cwd
36 |     }
37 |     
   | ^^^^
38 |     try:
39 |         with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:42:1
   |
40 |             s.connect((HOST, PORT))
41 |             s.sendall(json.dumps(payload).encode('utf-8'))
42 |             
   | ^^^^^^^^^^^^
43 |             # [PLAN B] Streaming Response Handling
44 |             # Verify if command is forge (or other streaming commands)
   |
help: Remove whitespace from blank line

E501 Line too long (109 > 100)
  --> src\cstar\core\client.py:45:101
   |
43 |             # [PLAN B] Streaming Response Handling
44 |             # Verify if command is forge (or other streaming commands)
45 |             # Actually, simply reading until close allows supporting both Sync and Async if structured right.
   |                                                                                                     ^^^^^^^^^
46 |             # However, for simplicity, we read line by line or chunk by chunk.
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:47:1
   |
45 |             # Actually, simply reading until close allows supporting both Sync and Async if structured right.
46 |             # However, for simplicity, we read line by line or chunk by chunk.
47 |             
   | ^^^^^^^^^^^^
48 |             # Use a file-like object for cleaner line reading
49 |             f = s.makefile('rb') 
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\cstar\core\client.py:49:33
   |
48 |             # Use a file-like object for cleaner line reading
49 |             f = s.makefile('rb') 
   |                                 ^
50 |             
51 |             last_result = None
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:50:1
   |
48 |             # Use a file-like object for cleaner line reading
49 |             f = s.makefile('rb') 
50 |             
   | ^^^^^^^^^^^^
51 |             last_result = None
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:52:1
   |
51 |             last_result = None
52 |             
   | ^^^^^^^^^^^^
53 |             for line in f:
54 |                 if not line: break
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\cstar\core\client.py:54:28
   |
53 |             for line in f:
54 |                 if not line: break
   |                            ^
55 |                 try:
56 |                     event = json.loads(line.decode('utf-8'))
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:57:1
   |
55 |                 try:
56 |                     event = json.loads(line.decode('utf-8'))
57 |                     
   | ^^^^^^^^^^^^^^^^^^^^
58 |                     if event.get("type") == "ui":
59 |                         # Render UI Event
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:65:1
   |
63 |                         prefix = f"[{persona}]"
64 |                         print(f"{prefix} {msg}")
65 |                     
   | ^^^^^^^^^^^^^^^^^^^^
66 |                     elif event.get("type") == "result":
67 |                         last_result = event
   |
help: Remove whitespace from blank line

SIM114 [*] Combine `if` branches using logical `or` operator
  --> src\cstar\core\client.py:66:21
   |
64 |                           print(f"{prefix} {msg}")
65 |                       
66 | /                     elif event.get("type") == "result":
67 | |                         last_result = event
68 | |                     
69 | |                     # If it's a standard response (no type), treat as result
70 | |                     elif "status" in event and "type" not in event:
71 | |                          last_result = event
   | |____________________________________________^
72 |
73 |                   except json.JSONDecodeError:
   |
help: Combine `if` branches

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:68:1
   |
66 |                     elif event.get("type") == "result":
67 |                         last_result = event
68 |                     
   | ^^^^^^^^^^^^^^^^^^^^
69 |                     # If it's a standard response (no type), treat as result
70 |                     elif "status" in event and "type" not in event:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:75:1
   |
73 |                 except json.JSONDecodeError:
74 |                     pass
75 |             
   | ^^^^^^^^^^^^
76 |             return last_result if last_result else {"status": "success", "message": "Stream ended without result."}
   |
help: Remove whitespace from blank line

E501 Line too long (115 > 100)
  --> src\cstar\core\client.py:76:101
   |
74 |                     pass
75 |             
76 |             return last_result if last_result else {"status": "success", "message": "Stream ended without result."}
   |                                                                                                     ^^^^^^^^^^^^^^^
77 |             
78 |     except ConnectionRefusedError:
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:77:1
   |
76 |             return last_result if last_result else {"status": "success", "message": "Stream ended without result."}
77 |             
   | ^^^^^^^^^^^^
78 |     except ConnectionRefusedError:
79 |         return {"status": "error", "message": "Daemon not running."}
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:87:1
   |
85 |         print("Usage: c* <command> [args...]")
86 |         sys.exit(1)
87 |         
   | ^^^^^^^^
88 |     cmd = sys.argv[1]
89 |     cmd_args = sys.argv[2:]
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:90:1
   |
88 |     cmd = sys.argv[1]
89 |     cmd_args = sys.argv[2:]
90 |     
   | ^^^^
91 |     # [PLAN B] Everything goes through Daemon
92 |     result = send_command(cmd, cmd_args)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:93:1
   |
91 |     # [PLAN B] Everything goes through Daemon
92 |     result = send_command(cmd, cmd_args)
93 |     
   | ^^^^
94 |     # Only print result if not already handled by UI stream or if it's a simple command
95 |     # If result has 'type': 'result', we might want to suppress it if UI was shown, or show summary?
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\client.py:97:1
   |
95 |     # If result has 'type': 'result', we might want to suppress it if UI was shown, or show summary?
96 |     # For standard commands, we print JSON. For forge, UI handles it.
97 |     
   | ^^^^
98 |     if result and cmd != "forge":
99 |          print(json.dumps(result, indent=2))
   |
help: Remove whitespace from blank line

SIM114 [*] Combine `if` branches using logical `or` operator
   --> src\cstar\core\client.py:98:5
    |
 96 |       # For standard commands, we print JSON. For forge, UI handles it.
 97 |       
 98 | /     if result and cmd != "forge":
 99 | |          print(json.dumps(result, indent=2))
100 | |     elif result and result.get("status") == "error":
101 | |          print(json.dumps(result, indent=2))
    | |____________________________________________^
    |
help: Combine `if` branches

I001 [*] Import block is un-sorted or un-formatted
  --> src\cstar\core\daemon.py:1:1
   |
 1 | / import socket
 2 | | import json
 3 | | import psutil
 4 | | import gc
 5 | | import os
 6 | | import sys
 7 | | import threading
 8 | | import time
 9 | | import re
10 | | import asyncio
11 | | import subprocess
12 | | from pathlib import Path
   | |________________________^
13 |
14 |   # Add project root to path for src imports
   |
help: Organize imports

F401 [*] `threading` imported but unused
 --> src\cstar\core\daemon.py:7:8
  |
5 | import os
6 | import sys
7 | import threading
  |        ^^^^^^^^^
8 | import time
9 | import re
  |
help: Remove unused import: `threading`

E402 Module level import not at top of file
  --> src\cstar\core\daemon.py:20:1
   |
18 |     sys.path.append(str(project_root))
19 |
20 | from src.core.engine.vector import SovereignVector
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 | from src.cstar.core.uplink import AntigravityUplink
22 | from src.cstar.core.forge import Forge
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\cstar\core\daemon.py:20:1
   |
18 |       sys.path.append(str(project_root))
19 |
20 | / from src.core.engine.vector import SovereignVector
21 | | from src.cstar.core.uplink import AntigravityUplink
22 | | from src.cstar.core.forge import Forge
23 | | from src.cstar.core.rpc import SovereignRPC # [Phase 11] RPC Handler
24 | | from src.sentinel._bootstrap import bootstrap
   | |_____________________________________________^
25 |
26 |   # Initialize Environment
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\cstar\core\daemon.py:21:1
   |
20 | from src.core.engine.vector import SovereignVector
21 | from src.cstar.core.uplink import AntigravityUplink
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 | from src.cstar.core.forge import Forge
23 | from src.cstar.core.rpc import SovereignRPC # [Phase 11] RPC Handler
   |

E402 Module level import not at top of file
  --> src\cstar\core\daemon.py:22:1
   |
20 | from src.core.engine.vector import SovereignVector
21 | from src.cstar.core.uplink import AntigravityUplink
22 | from src.cstar.core.forge import Forge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 | from src.cstar.core.rpc import SovereignRPC # [Phase 11] RPC Handler
24 | from src.sentinel._bootstrap import bootstrap
   |

E402 Module level import not at top of file
  --> src\cstar\core\daemon.py:23:1
   |
21 | from src.cstar.core.uplink import AntigravityUplink
22 | from src.cstar.core.forge import Forge
23 | from src.cstar.core.rpc import SovereignRPC # [Phase 11] RPC Handler
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 | from src.sentinel._bootstrap import bootstrap
   |

E402 Module level import not at top of file
  --> src\cstar\core\daemon.py:24:1
   |
22 | from src.cstar.core.forge import Forge
23 | from src.cstar.core.rpc import SovereignRPC # [Phase 11] RPC Handler
24 | from src.sentinel._bootstrap import bootstrap
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 | # Initialize Environment
   |

E501 Line too long (101 > 100)
  --> src\cstar\core\daemon.py:40:101
   |
38 | ENGINE = None
39 | COMMAND_REGISTRY = {}
40 | UPLINK = AntigravityUplink(api_key=os.getenv("GOOGLE_API_DAEMON_KEY") or os.getenv("GOOGLE_API_KEY"))
   |                                                                                                     ^
41 | RPC = None # Initialized in start_daemon
42 | SESSION_TRACES = [] 
   |

W291 [*] Trailing whitespace
  --> src\cstar\core\daemon.py:42:20
   |
40 | UPLINK = AntigravityUplink(api_key=os.getenv("GOOGLE_API_DAEMON_KEY") or os.getenv("GOOGLE_API_KEY"))
41 | RPC = None # Initialized in start_daemon
42 | SESSION_TRACES = [] 
   |                    ^
43 |
44 | def load_engine():
   |
help: Remove trailing whitespace

ANN201 Missing return type annotation for public function `load_engine`
  --> src\cstar\core\daemon.py:44:5
   |
42 | SESSION_TRACES = [] 
43 |
44 | def load_engine():
   |     ^^^^^^^^^^^
45 |     global ENGINE, COMMAND_REGISTRY, RPC
46 |     thesaurus_path = project_root / "src" / "data" / "thesaurus.qmd"
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\cstar\core\daemon.py:49:1
   |
47 |     corrections_path = project_root / ".agent" / "corrections.json"
48 |     stopwords_path = project_root / "src" / "data" / "stopwords.json"
49 |     
   | ^^^^
50 |     # [Phase 11] RPC Init
51 |     RPC = SovereignRPC(project_root)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\daemon.py:57:1
   |
55 |     ENGINE.load_skills_from_dir(str(project_root / "src" / "skills" / "local"))
56 |     ENGINE.build_index()
57 |     
   | ^^^^
58 |     dirs = [project_root / ".agent" / "workflows", project_root / ".agent" / "skills"]
59 |     print("[DAEMON] Building Command Registry...")
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\cstar\core\daemon.py:60:14
   |
58 |     dirs = [project_root / ".agent" / "workflows", project_root / ".agent" / "skills"]
59 |     print("[DAEMON] Building Command Registry...")
60 |     count = 0 
   |              ^
61 |     for d in dirs:
62 |         if d.exists():
   |
help: Remove trailing whitespace

E701 Multiple statements on one line (colon)
  --> src\cstar\core\daemon.py:71:33
   |
69 |                         content = f.read_text(encoding='utf-8')
70 |                         match = re.search(r"^name:\s*['\"]?([\w-]+)['\"]?", content, re.MULTILINE)
71 |                         if match: cmd_name = match.group(1)
   |                                 ^
72 |                     except: pass
73 |                  COMMAND_REGISTRY[cmd_name] = str(f)
   |

E722 Do not use bare `except`
  --> src\cstar\core\daemon.py:72:21
   |
70 |                         match = re.search(r"^name:\s*['\"]?([\w-]+)['\"]?", content, re.MULTILINE)
71 |                         if match: cmd_name = match.group(1)
72 |                     except: pass
   |                     ^^^^^^
73 |                  COMMAND_REGISTRY[cmd_name] = str(f)
74 |                  count += 1
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\cstar\core\daemon.py:72:21
   |
70 |                         match = re.search(r"^name:\s*['\"]?([\w-]+)['\"]?", content, re.MULTILINE)
71 |                         if match: cmd_name = match.group(1)
72 |                     except: pass
   |                     ^^^^^^^^^^^^
73 |                  COMMAND_REGISTRY[cmd_name] = str(f)
74 |                  count += 1
   |

E701 Multiple statements on one line (colon)
  --> src\cstar\core\daemon.py:72:27
   |
70 |                         match = re.search(r"^name:\s*['\"]?([\w-]+)['\"]?", content, re.MULTILINE)
71 |                         if match: cmd_name = match.group(1)
72 |                     except: pass
   |                           ^
73 |                  COMMAND_REGISTRY[cmd_name] = str(f)
74 |                  count += 1
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\daemon.py:75:1
   |
73 |                  COMMAND_REGISTRY[cmd_name] = str(f)
74 |                  count += 1
75 |     
   | ^^^^
76 |     print(f"[DAEMON] Registry loaded with {count} commands.")
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `get_memory_usage_mb`
  --> src\cstar\core\daemon.py:78:5
   |
76 |     print(f"[DAEMON] Registry loaded with {count} commands.")
77 |
78 | def get_memory_usage_mb():
   |     ^^^^^^^^^^^^^^^^^^^
79 |     process = psutil.Process(os.getpid())
80 |     return process.memory_info().rss / 1024 / 1024
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `check_memory_and_restart`
  --> src\cstar\core\daemon.py:82:5
   |
80 |     return process.memory_info().rss / 1024 / 1024
81 |
82 | def check_memory_and_restart():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
83 |     gc.collect() 
84 |     mem_usage = get_memory_usage_mb()
   |
help: Add return type annotation: `None`

W291 [*] Trailing whitespace
  --> src\cstar\core\daemon.py:83:17
   |
82 | def check_memory_and_restart():
83 |     gc.collect() 
   |                 ^
84 |     mem_usage = get_memory_usage_mb()
85 |     if mem_usage > MEMORY_LIMIT_MB:
   |
help: Remove trailing whitespace

S606 Starting a process without a shell
  --> src\cstar\core\daemon.py:88:13
   |
86 |         print(f"[DAEMON] Memory breach ({mem_usage:.2f}MB). Restarting.")
87 |         try:
88 |             os.execv(sys.executable, [sys.executable, "-m", "src.cstar.core.daemon"])
   |             ^^^^^^^^
89 |         except Exception:
90 |             sys.exit(1)
   |

ANN201 Missing return type annotation for public function `handle_request`
  --> src\cstar\core\daemon.py:92:5
   |
90 |             sys.exit(1)
91 |
92 | def handle_request(conn):
   |     ^^^^^^^^^^^^^^
93 |     """
94 |     Handles incoming requests. Supports both synchronous JSON response 
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `conn`
  --> src\cstar\core\daemon.py:92:20
   |
90 |             sys.exit(1)
91 |
92 | def handle_request(conn):
   |                    ^^^^
93 |     """
94 |     Handles incoming requests. Supports both synchronous JSON response 
   |

W291 Trailing whitespace
  --> src\cstar\core\daemon.py:94:71
   |
92 | def handle_request(conn):
93 |     """
94 |     Handles incoming requests. Supports both synchronous JSON response 
   |                                                                       ^
95 |     and Asynchronous Streaming (for Forge).
96 |     """
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:101:1
    |
 99 |         if not data:
100 |             return
101 |             
    | ^^^^^^^^^^^^
102 |         request = json.loads(data.decode('utf-8'))
103 |         command = request.get('command')
    |
help: Remove whitespace from blank line

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
   --> src\cstar\core\daemon.py:105:34
    |
103 |         command = request.get('command')
104 |         args = request.get('args', [])
105 |         cwd = request.get('cwd', os.getcwd())
    |                                  ^^^^^^^^^
106 |         
107 |         # [Phase 11] TUI Dashboard Polling
    |
help: Replace with `Path.cwd()`

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:106:1
    |
104 |         args = request.get('args', [])
105 |         cwd = request.get('cwd', os.getcwd())
106 |         
    | ^^^^^^^^
107 |         # [Phase 11] TUI Dashboard Polling
108 |         if command == "get_dashboard_state":
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:121:1
    |
119 |             response = asyncio.run(process_command(command, args, cwd))
120 |             conn.sendall(json.dumps(response).encode('utf-8'))
121 |         
    | ^^^^^^^^
122 |     except Exception as e:
123 |         error_response = {"status": "error", "message": str(e)}
    |
help: Remove whitespace from blank line

SIM105 Use `contextlib.suppress(BaseException)` instead of `try`-`except`-`pass`
   --> src\cstar\core\daemon.py:124:9
    |
122 |       except Exception as e:
123 |           error_response = {"status": "error", "message": str(e)}
124 | /         try:
125 | |             conn.sendall(json.dumps(error_response).encode('utf-8'))
126 | |         except:
127 | |             pass
    | |________________^
128 |       finally:
129 |           conn.close()
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(BaseException): ...`

E722 Do not use bare `except`
   --> src\cstar\core\daemon.py:126:9
    |
124 |         try:
125 |             conn.sendall(json.dumps(error_response).encode('utf-8'))
126 |         except:
    |         ^^^^^^
127 |             pass
128 |     finally:
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\cstar\core\daemon.py:126:9
    |
124 |           try:
125 |               conn.sendall(json.dumps(error_response).encode('utf-8'))
126 | /         except:
127 | |             pass
    | |________________^
128 |       finally:
129 |           conn.close()
    |

ANN201 Missing return type annotation for public function `process_forge_stream`
   --> src\cstar\core\daemon.py:132:11
    |
130 |         check_memory_and_restart()
131 |
132 | async def process_forge_stream(conn, args_list, cwd):
    |           ^^^^^^^^^^^^^^^^^^^^
133 |     """
134 |     Executes Forge logic and streams events to the client.
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `conn`
   --> src\cstar\core\daemon.py:132:32
    |
130 |         check_memory_and_restart()
131 |
132 | async def process_forge_stream(conn, args_list, cwd):
    |                                ^^^^
133 |     """
134 |     Executes Forge logic and streams events to the client.
    |

ANN001 Missing type annotation for function argument `args_list`
   --> src\cstar\core\daemon.py:132:38
    |
130 |         check_memory_and_restart()
131 |
132 | async def process_forge_stream(conn, args_list, cwd):
    |                                      ^^^^^^^^^
133 |     """
134 |     Executes Forge logic and streams events to the client.
    |

ANN001 Missing type annotation for function argument `cwd`
   --> src\cstar\core\daemon.py:132:49
    |
130 |         check_memory_and_restart()
131 |
132 | async def process_forge_stream(conn, args_list, cwd):
    |                                                 ^^^
133 |     """
134 |     Executes Forge logic and streams events to the client.
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:137:1
    |
135 |     """
136 |     global SESSION_TRACES
137 |     
    | ^^^^
138 |     # Parse args manually since we don't use argparse here easily
139 |     # Expecting: --task "..." --target "..."
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:142:1
    |
140 |     task = ""
141 |     target = ""
142 |     
    | ^^^^
143 |     # Simple parser
144 |     try:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:151:1
    |
149 |     except IndexError:
150 |         pass
151 |         
    | ^^^^^^^^
152 |     if not task or not target:
153 |         conn.sendall(json.dumps({"type": "result", "status": "error", "message": "Missing arguments"}).encode('utf-8'))
    |
help: Remove whitespace from blank line

E501 Line too long (119 > 100)
   --> src\cstar\core\daemon.py:153:101
    |
152 |     if not task or not target:
153 |         conn.sendall(json.dumps({"type": "result", "status": "error", "message": "Missing arguments"}).encode('utf-8'))
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^
154 |         return
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:157:1
    |
156 |     forge = Forge()
157 |     
    | ^^^^
158 |     # Log Start
159 |     SESSION_TRACES.append({"cmd": "forge", "task": task, "target": target, "ts": time.time(), "status": "started"})
    |
help: Remove whitespace from blank line

E501 Line too long (115 > 100)
   --> src\cstar\core\daemon.py:159:101
    |
158 |     # Log Start
159 |     SESSION_TRACES.append({"cmd": "forge", "task": task, "target": target, "ts": time.time(), "status": "started"})
    |                                                                                                     ^^^^^^^^^^^^^^^
160 |     
161 |     # Iterate Generator
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:160:1
    |
158 |     # Log Start
159 |     SESSION_TRACES.append({"cmd": "forge", "task": task, "target": target, "ts": time.time(), "status": "started"})
160 |     
    | ^^^^
161 |     # Iterate Generator
162 |     async for event in forge.execute(task, target):
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:166:1
    |
164 |         payload = json.dumps(event) + "\n"
165 |         conn.sendall(payload.encode('utf-8'))
166 |         
    | ^^^^^^^^
167 |         # Log Result if present
168 |         if event.get("type") == "result":
    |
help: Remove whitespace from blank line

E501 Line too long (109 > 100)
   --> src\cstar\core\daemon.py:169:101
    |
167 |         # Log Result if present
168 |         if event.get("type") == "result":
169 |              SESSION_TRACES.append({"cmd": "forge_result", "task": task, "result": event, "ts": time.time()})
    |                                                                                                     ^^^^^^^^^
170 |
171 | async def process_command(input_str, args, cwd):
    |

ANN201 Missing return type annotation for public function `process_command`
   --> src\cstar\core\daemon.py:171:11
    |
169 |              SESSION_TRACES.append({"cmd": "forge_result", "task": task, "result": event, "ts": time.time()})
170 |
171 | async def process_command(input_str, args, cwd):
    |           ^^^^^^^^^^^^^^^
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `input_str`
   --> src\cstar\core\daemon.py:171:27
    |
169 |              SESSION_TRACES.append({"cmd": "forge_result", "task": task, "result": event, "ts": time.time()})
170 |
171 | async def process_command(input_str, args, cwd):
    |                           ^^^^^^^^^
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
    |

ANN001 Missing type annotation for function argument `args`
   --> src\cstar\core\daemon.py:171:38
    |
169 |              SESSION_TRACES.append({"cmd": "forge_result", "task": task, "result": event, "ts": time.time()})
170 |
171 | async def process_command(input_str, args, cwd):
    |                                      ^^^^
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
    |

ANN001 Missing type annotation for function argument `cwd`
   --> src\cstar\core\daemon.py:171:44
    |
169 |              SESSION_TRACES.append({"cmd": "forge_result", "task": task, "result": event, "ts": time.time()})
170 |
171 | async def process_command(input_str, args, cwd):
    |                                            ^^^
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:173:1
    |
171 | async def process_command(input_str, args, cwd):
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
173 |     
    | ^^^^
174 |     if not input_str: return {"status": "error"}
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\cstar\core\daemon.py:174:21
    |
172 |     global ENGINE, COMMAND_REGISTRY, UPLINK, SESSION_TRACES, project_root
173 |     
174 |     if not input_str: return {"status": "error"}
    |                     ^
175 |     
176 |     if input_str == "sleep":
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:175:1
    |
174 |     if not input_str: return {"status": "error"}
175 |     
    | ^^^^
176 |     if input_str == "sleep":
177 |         return await execute_sleep_protocol()
    |
help: Remove whitespace from blank line

E501 Line too long (114 > 100)
   --> src\cstar\core\daemon.py:182:101
    |
181 |     if input_str in COMMAND_REGISTRY:
182 |         return {"status": "success", "type": "deterministic", "target": COMMAND_REGISTRY[input_str], "args": args}
    |                                                                                                     ^^^^^^^^^^^^^^
183 |     
184 |     query = f"{input_str} {' '.join(args)}".strip()
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:183:1
    |
181 |     if input_str in COMMAND_REGISTRY:
182 |         return {"status": "success", "type": "deterministic", "target": COMMAND_REGISTRY[input_str], "args": args}
183 |     
    | ^^^^
184 |     query = f"{input_str} {' '.join(args)}".strip()
185 |     results = ENGINE.search(query)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:188:1
    |
186 |     top = results[0] if results else None
187 |     score = top['score'] if top else 0.0
188 |     
    | ^^^^
189 |     if score < CONFIDENCE_THRESHOLD or input_str in ["ask", "brain", "uplink"]:
190 |         uplink_response = await UPLINK.send_payload(query, {"cwd": cwd, "persona": "O.D.I.N.", "traces": SESSION_TRACES[-5:]})
    |
help: Remove whitespace from blank line

E501 Line too long (122 > 100)
   --> src\cstar\core\daemon.py:190:101
    |
189 |     if score < CONFIDENCE_THRESHOLD or input_str in ["ask", "brain", "uplink"]:
190 |         uplink_response = await UPLINK.send_payload(query, {"cwd": cwd, "persona": "O.D.I.N.", "traces": SESSION_TRACES[-5:]})
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
191 |         return {"status": "uplink_success", "type": "uplink", "data": uplink_response}
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:192:1
    |
190 |         uplink_response = await UPLINK.send_payload(query, {"cwd": cwd, "persona": "O.D.I.N.", "traces": SESSION_TRACES[-5:]})
191 |         return {"status": "uplink_success", "type": "uplink", "data": uplink_response}
192 |     
    | ^^^^
193 |     return {"status": "success", "type": "probabilistic", "target": top['trigger'], "score": score}
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `execute_sleep_protocol`
   --> src\cstar\core\daemon.py:195:11
    |
193 |     return {"status": "success", "type": "probabilistic", "target": top['trigger'], "score": score}
194 |
195 | async def execute_sleep_protocol():
    |           ^^^^^^^^^^^^^^^^^^^^^^
196 |     global SESSION_TRACES
197 |     # ... (Keep existing implementation)
    |
help: Add return type annotation

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:199:1
    |
197 |     # ... (Keep existing implementation)
198 |     # Simulating Pass
199 |     
    | ^^^^
200 |     proj_mem = project_root / ".agent" / "memory" / f"session_{int(time.time())}.json"
201 |     proj_mem.parent.mkdir(parents=True, exist_ok=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:203:1
    |
201 |     proj_mem.parent.mkdir(parents=True, exist_ok=True)
202 |     proj_mem.write_text(json.dumps(SESSION_TRACES, indent=2))
203 |     
    | ^^^^
204 |     try:
205 |         subprocess.Popen([sys.executable, "-m", "src.sentinel.muninn", "--audit"], cwd=str(project_root))
    |
help: Remove whitespace from blank line

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> src\cstar\core\daemon.py:204:5
    |
202 |       proj_mem.write_text(json.dumps(SESSION_TRACES, indent=2))
203 |       
204 | /     try:
205 | |         subprocess.Popen([sys.executable, "-m", "src.sentinel.muninn", "--audit"], cwd=str(project_root))
206 | |     except Exception:
207 | |         pass
    | |____________^
208 |           
209 |       SESSION_TRACES = []
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

S603 `subprocess` call: check for execution of untrusted input
   --> src\cstar\core\daemon.py:205:9
    |
204 |     try:
205 |         subprocess.Popen([sys.executable, "-m", "src.sentinel.muninn", "--audit"], cwd=str(project_root))
    |         ^^^^^^^^^^^^^^^^
206 |     except Exception:
207 |         pass
    |

E501 Line too long (105 > 100)
   --> src\cstar\core\daemon.py:205:101
    |
204 |     try:
205 |         subprocess.Popen([sys.executable, "-m", "src.sentinel.muninn", "--audit"], cwd=str(project_root))
    |                                                                                                     ^^^^^
206 |     except Exception:
207 |         pass
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\cstar\core\daemon.py:206:5
    |
204 |       try:
205 |           subprocess.Popen([sys.executable, "-m", "src.sentinel.muninn", "--audit"], cwd=str(project_root))
206 | /     except Exception:
207 | |         pass
    | |____________^
208 |           
209 |       SESSION_TRACES = []
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:208:1
    |
206 |     except Exception:
207 |         pass
208 |         
    | ^^^^^^^^
209 |     SESSION_TRACES = []
210 |     return {"status": "success", "message": "Session consolidated.", "gungnir": "PASS"}
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `start_daemon`
   --> src\cstar\core\daemon.py:212:5
    |
210 |     return {"status": "success", "message": "Session consolidated.", "gungnir": "PASS"}
211 |
212 | def start_daemon():
    |     ^^^^^^^^^^^^
213 |     load_engine()
214 |     if PID_FILE.exists():
    |
help: Add return type annotation: `None`

E701 Multiple statements on one line (colon)
   --> src\cstar\core\daemon.py:216:60
    |
214 |     if PID_FILE.exists():
215 |         try:
216 |             if psutil.pid_exists(int(PID_FILE.read_text())): return
    |                                                            ^
217 |         except: pass
218 |     PID_FILE.parent.mkdir(parents=True, exist_ok=True)
    |

E722 Do not use bare `except`
   --> src\cstar\core\daemon.py:217:9
    |
215 |         try:
216 |             if psutil.pid_exists(int(PID_FILE.read_text())): return
217 |         except: pass
    |         ^^^^^^
218 |     PID_FILE.parent.mkdir(parents=True, exist_ok=True)
219 |     PID_FILE.write_text(str(os.getpid()))
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\cstar\core\daemon.py:217:9
    |
215 |         try:
216 |             if psutil.pid_exists(int(PID_FILE.read_text())): return
217 |         except: pass
    |         ^^^^^^^^^^^^
218 |     PID_FILE.parent.mkdir(parents=True, exist_ok=True)
219 |     PID_FILE.write_text(str(os.getpid()))
    |

E701 Multiple statements on one line (colon)
   --> src\cstar\core\daemon.py:217:15
    |
215 |         try:
216 |             if psutil.pid_exists(int(PID_FILE.read_text())): return
217 |         except: pass
    |               ^
218 |     PID_FILE.parent.mkdir(parents=True, exist_ok=True)
219 |     PID_FILE.write_text(str(os.getpid()))
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\daemon.py:221:1
    |
219 |     PID_FILE.write_text(str(os.getpid()))
220 |     print(f"[DAEMON] Started PID: {os.getpid()} PORT: {PORT}")
221 |     
    | ^^^^
222 |     with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
223 |         s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    |
help: Remove whitespace from blank line

RUF059 Unpacked variable `addr` is never used
   --> src\cstar\core\daemon.py:228:23
    |
226 |             s.listen()
227 |             while True:
228 |                 conn, addr = s.accept()
    |                       ^^^^
229 |                 handle_request(conn)
230 |         except OSError:
    |
help: Prefix it with an underscore or any other dummy variable pattern

E701 Multiple statements on one line (colon)
   --> src\cstar\core\daemon.py:233:33
    |
231 |             sys.exit(1)
232 |         finally:
233 |             if PID_FILE.exists(): PID_FILE.unlink()
    |                                 ^
234 |
235 | if __name__ == "__main__":
    |

E402 Module level import not at top of file
  --> src\cstar\core\forge.py:19:1
   |
17 |     sys.path.append(str(project_root))
18 |
19 | from src.cstar.core.sprt import evaluate_candidate
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 | from src.cstar.core.uplink import AntigravityUplink
21 | from src.sentinel._bootstrap import bootstrap
   |

E402 Module level import not at top of file
  --> src\cstar\core\forge.py:20:1
   |
19 | from src.cstar.core.sprt import evaluate_candidate
20 | from src.cstar.core.uplink import AntigravityUplink
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 | from src.sentinel._bootstrap import bootstrap
   |

E402 Module level import not at top of file
  --> src\cstar\core\forge.py:21:1
   |
19 | from src.cstar.core.sprt import evaluate_candidate
20 | from src.cstar.core.uplink import AntigravityUplink
21 | from src.sentinel._bootstrap import bootstrap
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | # Initialize Environment
   |

ANN201 Missing return type annotation for public function `execute`
  --> src\cstar\core\forge.py:43:15
   |
41 |         return f"<Forge(root='{self.project_root}', retries={self.max_retries})>"
42 |
43 |     async def execute(self, task: str, target_file: str):
   |               ^^^^^^^
44 |         """
45 |         Runs the forging loop as an async generator.
   |
help: Add return type annotation

E501 Line too long (123 > 100)
  --> src\cstar\core\forge.py:51:101
   |
50 |         if not target_path.exists():
51 |             yield {"type": "ui", "persona": "O.D.I.N.", "msg": f"Target file {target_path.name} does not exist. Creating new."}
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
52 |             target_path.parent.mkdir(parents=True, exist_ok=True)
53 |             target_path.touch()
   |

E501 Line too long (151 > 100)
  --> src\cstar\core\forge.py:68:101
   |
66 | â€¦
67 | â€¦
68 | â€¦f"Attempt {attempt}/{self.max_retries}: [SID: {session_id[:8]}] Communing with the void..."}
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 | â€¦
70 | â€¦ir Calculus)
   |

E501 Line too long (110 > 100)
  --> src\cstar\core\forge.py:74:101
   |
73 |             if response.get("status") == "error":
74 |                 yield {"type": "ui", "persona": "ALFRED", "msg": f"Uplink severed: {response.get('message')}"}
   |                                                                                                     ^^^^^^^^^^
75 |                 yield {"type": "result", "status": "error", "message": "Uplink Failed"}
76 |                 return
   |

E501 Line too long (128 > 100)
  --> src\cstar\core\forge.py:79:101
   |
78 |             if "warnings" in response:
79 |                 yield {"type": "ui", "persona": "O.D.I.N.", "msg": "Gungnir Calculus detected dissonance. Self-correction applied."}
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
80 |
81 |             new_code = response.get("data", {}).get("code")
   |

E501 Line too long (104 > 100)
  --> src\cstar\core\forge.py:83:101
   |
81 |             new_code = response.get("data", {}).get("code")
82 |             if not new_code:
83 |                 yield {"type": "ui", "persona": "O.D.I.N.", "msg": "The void returned silence. Retrying..."}
   |                                                                                                     ^^^^
84 |                 context["error"] = "No code received from O.D.I.N.."
85 |                 continue
   |

N806 Variable `GUNGNIR_FILE` in function should be lowercase
   --> src\cstar\core\forge.py:119:13
    |
118 |             # Fixed Gungnir JSON naming in prompt
119 |             GUNGNIR_FILE = f"gungnir_{session_id}.json"
    |             ^^^^^^^^^^^^
120 |             SYSTEM_DIRECTIVE = (
121 |                 f"You are ALFRED, an adversarial verification entity. "
    |

N806 Variable `SYSTEM_DIRECTIVE` in function should be lowercase
   --> src\cstar\core\forge.py:120:13
    |
118 |             # Fixed Gungnir JSON naming in prompt
119 |             GUNGNIR_FILE = f"gungnir_{session_id}.json"
120 |             SYSTEM_DIRECTIVE = (
    |             ^^^^^^^^^^^^^^^^
121 |                 f"You are ALFRED, an adversarial verification entity. "
122 |                 f"Write parameterized unit tests (min 25 fuzzing iterations) to break the interface. "
    |

E501 Line too long (102 > 100)
   --> src\cstar\core\forge.py:122:101
    |
120 |             SYSTEM_DIRECTIVE = (
121 |                 f"You are ALFRED, an adversarial verification entity. "
122 |                 f"Write parameterized unit tests (min 25 fuzzing iterations) to break the interface. "
    |                                                                                                     ^^
123 |                 f"Detect the target language and use industry-standard linting and testing frameworks. "
124 |                 f"Embed logic to output a flat integer array (0=pass, 1=fail) to '{GUNGNIR_FILE}'. "
    |

E501 Line too long (104 > 100)
   --> src\cstar\core\forge.py:123:101
    |
121 |                 f"You are ALFRED, an adversarial verification entity. "
122 |                 f"Write parameterized unit tests (min 25 fuzzing iterations) to break the interface. "
123 |                 f"Detect the target language and use industry-standard linting and testing frameworks. "
    |                                                                                                     ^^^^
124 |                 f"Embed logic to output a flat integer array (0=pass, 1=fail) to '{GUNGNIR_FILE}'. "
125 |                 f"Output ONLY strict JSON: 'lint_command', 'test_command', 'test_filename', and 'test_code'."
    |

E501 Line too long (109 > 100)
   --> src\cstar\core\forge.py:125:101
    |
123 |                 f"Detect the target language and use industry-standard linting and testing frameworks. "
124 |                 f"Embed logic to output a flat integer array (0=pass, 1=fail) to '{GUNGNIR_FILE}'. "
125 |                 f"Output ONLY strict JSON: 'lint_command', 'test_command', 'test_filename', and 'test_code'."
    |                                                                                                     ^^^^^^^^^
126 |             )
    |

E501 Line too long (124 > 100)
   --> src\cstar\core\forge.py:129:101
    |
128 |             while alfred_strikes < 2:
129 |                 yield {"type": "ui", "persona": "ALFRED", "msg": f"Constructing constraints (Strike {alfred_strikes}/2)..."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
130 |
131 |                 # Uplink to ALFRED
    |

E501 Line too long (117 > 100)
   --> src\cstar\core\forge.py:132:101
    |
131 |                 # Uplink to ALFRED
132 |                 alfred_resp = await self.uplink.send_payload(f"SYSTEM DIRECTIVE: {SYSTEM_DIRECTIVE}", alfred_context)
    |                                                                                                     ^^^^^^^^^^^^^^^^^
133 |
134 |                 try:
    |

E501 Line too long (105 > 100)
   --> src\cstar\core\forge.py:153:101
    |
152 |                     # 4.1 Lint Gate
153 |                     yield {"type": "ui", "persona": "ALFRED", "msg": f"Linting Verification: {lint_cmd}"}
    |                                                                                                     ^^^^^
154 |                     lp = await asyncio.create_subprocess_shell(
155 |                         lint_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=str(self.project_root)
    |

E501 Line too long (124 > 100)
   --> src\cstar\core\forge.py:155:101
    |
153 |                     yield {"type": "ui", "persona": "ALFRED", "msg": f"Linting Verification: {lint_cmd}"}
154 |                     lp = await asyncio.create_subprocess_shell(
155 |                         lint_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=str(self.project_root)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
156 |                     )
157 |                     stdout, stderr = await lp.communicate()
    |

RUF059 Unpacked variable `stdout` is never used
   --> src\cstar\core\forge.py:157:21
    |
155 |                         lint_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=str(self.project_root)
156 |                     )
157 |                     stdout, stderr = await lp.communicate()
    |                     ^^^^^^
158 |
159 |                     if lp.returncode != 0:
    |
help: Prefix it with an underscore or any other dummy variable pattern

E501 Line too long (119 > 100)
   --> src\cstar\core\forge.py:162:101
    |
160 |                         alfred_strikes += 1
161 |                         alfred_context["error"] = f"Linter Error:\n{stderr.decode()[:500]}"
162 |                         yield {"type": "ui", "persona": "ALFRED", "msg": f"Lint Gate Breach. Strike {alfred_strikes}."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^
163 |                         continue
    |

E501 Line too long (103 > 100)
   --> src\cstar\core\forge.py:166:101
    |
165 |                     # 4.2 Execution Gate (15s Timeout)
166 |                     yield {"type": "ui", "persona": "ALFRED", "msg": f"Executing Verifier: {test_cmd}"}
    |                                                                                                     ^^^
167 |                     try:
168 |                         ep = await asyncio.create_subprocess_shell(
    |

E501 Line too long (128 > 100)
   --> src\cstar\core\forge.py:169:101
    |
167 |                     try:
168 |                         ep = await asyncio.create_subprocess_shell(
169 |                             test_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=str(self.project_root)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |                         )
171 |                         test_stdout, test_stderr = await asyncio.wait_for(ep.communicate(), timeout=15.0)
    |

E501 Line too long (105 > 100)
   --> src\cstar\core\forge.py:171:101
    |
169 |                             test_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=str(self.project_root)
170 |                         )
171 |                         test_stdout, test_stderr = await asyncio.wait_for(ep.communicate(), timeout=15.0)
    |                                                                                                     ^^^^^
172 |
173 |                         # Save logs to feed back to O.D.I.N. in case of logic rejection
    |

E501 Line too long (104 > 100)
   --> src\cstar\core\forge.py:174:101
    |
173 |                         # Save logs to feed back to O.D.I.N. in case of logic rejection
174 |                         verification_logs = (test_stdout.decode() + "\n" + test_stderr.decode()).strip()
    |                                                                                                     ^^^^
175 |                     except asyncio.TimeoutError:
176 |                         alfred_strikes += 1
    |

E501 Line too long (123 > 100)
   --> src\cstar\core\forge.py:178:101
    |
176 |                         alfred_strikes += 1
177 |                         alfred_context["error"] = "Test Execution Timeout."
178 |                         yield {"type": "ui", "persona": "ALFRED", "msg": f"Verification Timeout. Strike {alfred_strikes}."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
179 |                         with contextlib.suppress(Exception):
180 |                             ep.kill()
    |

E501 Line too long (119 > 100)
   --> src\cstar\core\forge.py:188:101
    |
186 |                         alfred_strikes += 1
187 |                         alfred_context["error"] = "Gungnir artifact missing (Process crash?)"
188 |                         yield {"type": "ui", "persona": "ALFRED", "msg": f"Missing Artifact. Strike {alfred_strikes}."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^
189 |                         continue
    |

E501 Line too long (114 > 100)
   --> src\cstar\core\forge.py:197:101
    |
195 |                     alfred_strikes += 1
196 |                     alfred_context["error"] = str(e)
197 |                     yield {"type": "ui", "persona": "ALFRED", "msg": f"Structure Fault. Strike {alfred_strikes}."}
    |                                                                                                     ^^^^^^^^^^^^^^
198 |                     continue
    |

E501 Line too long (123 > 100)
   --> src\cstar\core\forge.py:201:101
    |
200 |             if not alfred_success:
201 |                 yield {"type": "ui", "persona": "O.D.I.N.", "msg": "ALFRED failed to provide valid constraints. Rolling back."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
202 |                 shutil.copy(backup_path, target_path)
203 |                 backup_path.unlink()
    |

E501 Line too long (109 > 100)
   --> src\cstar\core\forge.py:204:101
    |
202 |                 shutil.copy(backup_path, target_path)
203 |                 backup_path.unlink()
204 |                 yield {"type": "result", "status": "error", "message": "Verification Infrastructure Failure"}
    |                                                                                                     ^^^^^^^^^
205 |                 return
    |

E501 Line too long (116 > 100)
   --> src\cstar\core\forge.py:222:101
    |
221 |             if decision == "Accept":
222 |                 yield {"type": "ui", "persona": "O.D.I.N.", "msg": f"Gungnir Verdict: ACCEPT (LLR: {llr:.2f}). Stable."}
    |                                                                                                     ^^^^^^^^^^^^^^^^
223 |                 backup_path.unlink()
224 |                 gc.collect()
    |

E501 Line too long (102 > 100)
   --> src\cstar\core\forge.py:225:101
    |
223 |                 backup_path.unlink()
224 |                 gc.collect()
225 |                 yield {"type": "result", "status": "success", "message": "Forge Complete", "llr": llr}
    |                                                                                                     ^^
226 |                 return
227 |             else:
    |

E501 Line too long (134 > 100)
   --> src\cstar\core\forge.py:229:101
    |
227 |             else:
228 |                 # Logical Failure: Penalize O.D.I.N.
229 |                 yield {"type": "ui", "persona": "O.D.I.N.", "msg": f"Gungnir Verdict: {decision.upper()} (LLR: {llr:.2f}). Logic Breach."}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
230 |                 shutil.copy(backup_path, target_path) # Rollback
231 |                 backup_path.unlink()
    |

E501 Line too long (118 > 100)
   --> src\cstar\core\forge.py:234:101
    |
233 |                 # Inject traceback for O.D.I.N. so it isn't guessing blindly
234 |                 context["error"] = f"Logic Verification Failed (LLR: {llr}).\nTest Logs:\n{verification_logs[-2000:]}"
    |                                                                                                     ^^^^^^^^^^^^^^^^^^
235 |                 context["previous_attempt"] = new_code
236 |                 gc.collect()
    |

N806 Variable `C` in function should be lowercase
   --> src\cstar\core\forge.py:249:13
    |
247 |             unique_cls = len(set(all_cls))
248 |
249 |             C = elements + unique_cls if (elements + unique_cls) > 0 else 1
    |             ^
250 |
251 |             # Order calculation
    |

N806 Variable `O` in function should be lowercase
   --> src\cstar\core\forge.py:253:13
    |
251 |             # Order calculation
252 |             class_counts = {c: all_cls.count(c) for c in set(all_cls)}
253 |             O = sum(count for count in class_counts.values() if count > 2)
    |             ^
254 |
255 |             symmetric_ops = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
    |

E741 Ambiguous variable name: `O`
   --> src\cstar\core\forge.py:253:13
    |
251 |             # Order calculation
252 |             class_counts = {c: all_cls.count(c) for c in set(all_cls)}
253 |             O = sum(count for count in class_counts.values() if count > 2)
    |             ^
254 |
255 |             symmetric_ops = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
    |

E501 Line too long (104 > 100)
   --> src\cstar\core\forge.py:255:101
    |
253 |             O = sum(count for count in class_counts.values() if count > 2)
254 |
255 |             symmetric_ops = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
    |                                                                                                     ^^^^
256 |             O += sum(5 for c in all_cls if c in symmetric_ops)
    |

N806 Variable `O` in function should be lowercase
   --> src\cstar\core\forge.py:256:13
    |
255 |             symmetric_ops = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
256 |             O += sum(5 for c in all_cls if c in symmetric_ops)
    |             ^
257 |
258 |             if elements > 5 and (O / C) < 0.3:
    |

E741 Ambiguous variable name: `O`
   --> src\cstar\core\forge.py:256:13
    |
255 |             symmetric_ops = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
256 |             O += sum(5 for c in all_cls if c in symmetric_ops)
    |             ^
257 |
258 |             if elements > 5 and (O / C) < 0.3:
    |

E501 Line too long (147 > 100)
   --> src\cstar\core\forge.py:259:101
    |
258 | â€¦
259 | â€¦off Measure M={(O/C):.2f} is too low. Increase symmetry (O) and reduce raw classes (C).")
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
260 | â€¦
261 | â€¦g)) > 3:
    |

E501 Line too long (123 > 100)
   --> src\cstar\core\forge.py:262:101
    |
261 |             if len(re.findall(r'-\[[0-9]+px\]', code_string)) > 3:
262 |                 breaches.append("GUNGNIR_UI_BREACH: Too many arbitrary pixel sizes. Use native Tailwind Fibonacci scales.")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
263 |
264 |         # 2. Backend Structural Checks (.py)
    |

E501 Line too long (133 > 100)
   --> src\cstar\core\forge.py:273:101
    |
271 |                     consecutive += 1
272 |                     if consecutive > 12:
273 |                         breaches.append("GUNGNIR_BACKEND_BREACH: Claustrophobic code block (>12 lines). Inject vertical whitespace.")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
274 |                         break
275 |                 else:
    |

E501 Line too long (123 > 100)
   --> src\cstar\core\forge.py:283:101
    |
281 | â€¦     for node in ast.walk(tree):
282 | â€¦         if isinstance(node, ast.FunctionDef):
283 | â€¦             setup = sum(1 for child in node.body if isinstance(child, (ast.Assign, ast.AnnAssign, ast.Assert)))
    |                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^
284 | â€¦             exec_nodes = sum(1 for child in node.body if isinstance(child, (ast.For, ast.While, ast.Return, ast.Expr, ast.If)))
285 | â€¦             if exec_nodes > 0 and (setup / exec_nodes) > 1.7:
    |

E501 Line too long (139 > 100)
   --> src\cstar\core\forge.py:284:101
    |
282 | â€¦     if isinstance(node, ast.FunctionDef):
283 | â€¦         setup = sum(1 for child in node.body if isinstance(child, (ast.Assign, ast.AnnAssign, ast.Assert)))
284 | â€¦         exec_nodes = sum(1 for child in node.body if isinstance(child, (ast.For, ast.While, ast.Return, ast.Expr, ast.If)))
    |                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
285 | â€¦         if exec_nodes > 0 and (setup / exec_nodes) > 1.7:
286 | â€¦             breaches.append(f"GUNGNIR_BACKEND_BREACH: Function '{node.name}' is top-heavy setup (Ratio: {setup/exec_nodes:.2f}). Exâ€¦
    |

E501 Line too long (172 > 100)
   --> src\cstar\core\forge.py:286:101
    |
284 | â€¦sinstance(child, (ast.For, ast.While, ast.Return, ast.Expr, ast.If)))
285 | â€¦.7:
286 | â€¦Function '{node.name}' is top-heavy setup (Ratio: {setup/exec_nodes:.2f}). Extract helper functions.")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
287 | â€¦
288 | â€¦
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\cstar\core\forge.py:287:13
    |
285 |                           if exec_nodes > 0 and (setup / exec_nodes) > 1.7:
286 |                               breaches.append(f"GUNGNIR_BACKEND_BREACH: Function '{node.name}' is top-heavy setup (Ratio: {setup/exec_nâ€¦
287 | /             except (SyntaxError, Exception):
288 | |                 pass # Defer to standard linters/validators
    | |____________________^
289 |
290 |           return breaches
    |

ANN202 Missing return type annotation for private function `_generate_with_calculus`
   --> src\cstar\core\forge.py:300:15
    |
298 |         return text.strip()
299 |
300 |     async def _generate_with_calculus(self, task: str, context: dict, file_ext: str):
    |               ^^^^^^^^^^^^^^^^^^^^^^^
301 |         """Internal generator wrapper with Gungnir Calculus retry logic."""
302 |         current_task_prompt = f"FORGE: {task}"
    |
help: Add return type annotation

E501 Line too long (122 > 100)
   --> src\cstar\core\forge.py:326:101
    |
324 |             # (Note: This is a bit tricky inside this helper, but we'll return it)
325 |             warning_msg = "Your previous generation failed the Gungnir Aesthetic Calculus."
326 |             context["error"] = f"\n\nSYSTEM WARNING: {warning_msg} Fix the following constraints:\n" + "\n".join(breaches)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
327 |             context["previous_attempt"] = new_code
328 |             current_task_prompt = f"REPAIR FORGE: {task}. Resolve aesthetic breaches."
    |

I001 [*] Import block is un-sorted or un-formatted
 --> src\cstar\core\rpc.py:2:1
  |
2 | / import os
3 | | import sys
4 | | import psutil
5 | | import time
6 | | from pathlib import Path
7 | | from typing import Dict, Any, List
  | |__________________________________^
8 |
9 |   # Ensure project root is in sys.path
  |
help: Organize imports

F401 [*] `time` imported but unused
 --> src\cstar\core\rpc.py:5:8
  |
3 | import sys
4 | import psutil
5 | import time
  |        ^^^^
6 | from pathlib import Path
7 | from typing import Dict, Any, List
  |
help: Remove unused import: `time`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src\cstar\core\rpc.py:7:1
  |
5 | import time
6 | from pathlib import Path
7 | from typing import Dict, Any, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | # Ensure project root is in sys.path
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src\cstar\core\rpc.py:7:1
  |
5 | import time
6 | from pathlib import Path
7 | from typing import Dict, Any, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | # Ensure project root is in sys.path
  |

F401 [*] `typing.List` imported but unused
 --> src\cstar\core\rpc.py:7:31
  |
5 | import time
6 | from pathlib import Path
7 | from typing import Dict, Any, List
  |                               ^^^^
8 |
9 | # Ensure project root is in sys.path
  |
help: Remove unused import: `typing.List`

E402 Module level import not at top of file
  --> src\cstar\core\rpc.py:14:1
   |
12 |     sys.path.append(str(PROJECT_ROOT))
13 |
14 | from src.sentinel.wardens.norn import NornWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 | from src.core.ui import HUD
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\cstar\core\rpc.py:14:1
   |
12 |       sys.path.append(str(PROJECT_ROOT))
13 |
14 | / from src.sentinel.wardens.norn import NornWarden
15 | | from src.core.ui import HUD
   | |___________________________^
16 |
17 |   class SovereignRPC:
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\cstar\core\rpc.py:15:1
   |
14 | from src.sentinel.wardens.norn import NornWarden
15 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | class SovereignRPC:
   |

W293 Blank line contains whitespace
  --> src\cstar\core\rpc.py:25:1
   |
23 |         """
24 |         Initializes the SovereignRPC.
25 |         
   | ^^^^^^^^
26 |         Args:
27 |             root (Path): The project root directory.
   |
help: Remove whitespace from blank line

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\cstar\core\rpc.py:32:38
   |
30 |         self.norn = NornWarden(root)
31 |
32 |     def get_dashboard_state(self) -> Dict[str, Any]:
   |                                      ^^^^
33 |         """
34 |         Aggregates system state for the HUD.
   |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
  --> src\cstar\core\rpc.py:39:1
   |
37 |         process = psutil.Process(os.getpid())
38 |         mem_mb = process.memory_info().rss / 1024 / 1024
39 |         
   | ^^^^^^^^
40 |         # 2. Git Status (Mock/Simple for now, or subprocess)
41 |         # We can implement a quick check or just return "ACTIVE"
   |
help: Remove whitespace from blank line

SIM108 Use ternary operator `git_branch = ref.split("/")[-1] if "ref: " in ref else ref[:7]` instead of `if`-`else`-block
  --> src\cstar\core\rpc.py:47:17
   |
45 |               if head_path.exists():
46 |                   ref = head_path.read_text().strip()
47 | /                 if "ref: " in ref:
48 | |                     git_branch = ref.split("/")[-1]
49 | |                 else:
50 | |                     git_branch = ref[:7]
   | |________________________________________^
51 |           except:
52 |               pass
   |
help: Replace `if`-`else`-block with `git_branch = ref.split("/")[-1] if "ref: " in ref else ref[:7]`

E722 Do not use bare `except`
  --> src\cstar\core\rpc.py:51:9
   |
49 |                 else:
50 |                     git_branch = ref[:7]
51 |         except:
   |         ^^^^^^
52 |             pass
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\cstar\core\rpc.py:51:9
   |
49 |                   else:
50 |                       git_branch = ref[:7]
51 | /         except:
52 | |             pass
   | |________________^
53 |
54 |           # 3. Mission Log (Tasks)
   |

E501 Line too long (101 > 100)
  --> src\cstar\core\rpc.py:60:101
   |
58 |         try:
59 |             # Norn.scan() currently returns *one* next task or a list.
60 |             # We might want to extend Norn or just re-parse manually here for the 'top 5' requirement
   |                                                                                                     ^
61 |             # OR we trust Norn to give us the "Next Objective"
62 |             # Let's peek at Norn again. It scans for the *first* check.
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\rpc.py:67:1
   |
65 |             # or implemented a robust 'scan_all' in Norn later.
66 |             # Let's just use Norn's current scan to get the ACTIVE OBJECTIVE.
67 |             
   | ^^^^^^^^^^^^
68 |             # Actually, the user asked for "top 5 unchecked".
69 |             # Norn.get_next_target() gets the *first*.
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\rpc.py:71:1
   |
69 |             # Norn.get_next_target() gets the *first*.
70 |             # We can implement a specialized scan here or just loop.
71 |             
   | ^^^^^^^^^^^^
72 |             all_lines = (self.root / "tasks.qmd").read_text(encoding='utf-8').splitlines()
73 |             count = 0
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\cstar\core\rpc.py:79:35
   |
77 |                      tasks.append(desc)
78 |                      count += 1
79 |                      if count >= 5: break
   |                                   ^
80 |         except Exception as e:
81 |             tasks = [f"Error reading tasks: {e}"]
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\cstar\core\rpc.py:95:43
   |
95 |     def handle_command(self, cmd: str) -> Dict[str, Any]:
   |                                           ^^^^
96 |         """
97 |         Executes a command from the TUI input bar.
   |
help: Replace with `dict`

I001 [*] Import block is un-sorted or un-formatted
 --> src\cstar\core\sprt.py:1:1
  |
1 | / import math
2 | | from typing import Any
  | |______________________^
3 |
4 |   def evaluate_candidate(observations: list[int], p0: float = 0.05, p1: float = 0.20, alpha: float = 0.05, beta: float = 0.20) -> dict[stâ€¦
  |
help: Organize imports

E501 Line too long (143 > 100)
 --> src\cstar\core\sprt.py:4:101
  |
2 | â€¦
3 | â€¦
4 | â€¦at = 0.05, p1: float = 0.20, alpha: float = 0.05, beta: float = 0.20) -> dict[str, Any]:
  |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 | â€¦
6 | â€¦T) mathematically mirroring 
  |

W291 Trailing whitespace
 --> src\cstar\core\sprt.py:6:83
  |
4 | def evaluate_candidate(observations: list[int], p0: float = 0.05, p1: float = 0.20, alpha: float = 0.05, beta: float = 0.20) -> dict[stâ€¦
5 |     """
6 |     Executes the Sequential Probability Ratio Test (SPRT) mathematically mirroring 
  |                                                                                   ^
7 |     the legacy Gungnir calculus.
  |
help: Remove trailing whitespace

W293 Blank line contains whitespace
  --> src\cstar\core\sprt.py:8:1
   |
 6 |     Executes the Sequential Probability Ratio Test (SPRT) mathematically mirroring 
 7 |     the legacy Gungnir calculus.
 8 |     
   | ^^^^
 9 |     Returns:
10 |         dict: {"Decision": "Accept" | "Reject" | "Continue", "FinalLLR": float, "SamplesEvaluated": int}
   |
help: Remove whitespace from blank line

E501 Line too long (104 > 100)
  --> src\cstar\core\sprt.py:10:101
   |
 9 |     Returns:
10 |         dict: {"Decision": "Accept" | "Reject" | "Continue", "FinalLLR": float, "SamplesEvaluated": int}
   |                                                                                                     ^^^^
11 |     """
12 |     if not observations:
   |

ANN201 Missing return type annotation for public function `stream_command`
   --> src\cstar\core\tui.py:295:15
    |
293 |         return {"persona": "ALFRED", "status": "disconnected", "error": True}
294 |
295 |     async def stream_command(self, payload: dict[str, Any]):
    |               ^^^^^^^^^^^^^^
296 |         """
297 |         Send a JSON command and yield streaming responses (Line-Delimited JSON).
    |
help: Add return type annotation

RUF010 [*] Use explicit conversion flag
   --> src\cstar\core\tui.py:318:87
    |
316 |                     continue
317 |         except Exception as e:
318 |             yield {"type": "result", "status": "error", "message": f"Stream severed: {str(e)}"}
    |                                                                                       ^^^^^^
319 |         finally:
320 |             try:
    |
help: Replace with conversion flag

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\cstar\core\tui.py:323:13
    |
321 |                   writer.close()
322 |                   await writer.wait_closed()
323 | /             except Exception:
324 | |                 pass
    | |____________________^
    |

W293 [*] Blank line contains whitespace
    --> src\cstar\core\tui.py:1424:1
     |
1422 |     ) -> None:
1423 |         """Handle forge commands by switching to the Forge Screen and streaming output."""
1424 |         
     | ^^^^^^^^
1425 |         # 1. Switch to the dedicated Forge Screen
1426 |         self.action_show_forge()
     |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
    --> src\cstar\core\tui.py:1429:1
     |
1427 |         forge_log = self.screen.query_one("#forge_log", Log)
1428 |         forge_status = self.screen.query_one("#forge_status", Static)
1429 |         
     | ^^^^^^^^
1430 |         forge_log.clear()
1431 |         forge_log.write(f"[{self.active_persona}] {lore['forge_start']}")
     |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
    --> src\cstar\core\tui.py:1436:32
     |
1434 |         # 2. Package the payload
1435 |         # Drop the word "forge" and send the rest as args. The daemon's new router will parse it.
1436 |         parts = cmd.split()[1:] 
     |                                ^
1437 |         payload = {"command": "forge", "args": parts}
     |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
    --> src\cstar\core\tui.py:1445:1
     |
1443 |                 persona = event.get("persona", "SYSTEM")
1444 |                 msg = event.get("msg", "")
1445 |                 
     | ^^^^^^^^^^^^^^^^
1446 |                 if event_type == "ui":
1447 |                     forge_log.write(f"[{persona}] {msg}")
     |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
    --> src\cstar\core\tui.py:1448:1
     |
1446 |                 if event_type == "ui":
1447 |                     forge_log.write(f"[{persona}] {msg}")
1448 |                 
     | ^^^^^^^^^^^^^^^^
1449 |                 elif event_type == "result":
1450 |                     status = event.get("status")
     |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
    --> src\cstar\core\tui.py:1461:1
     |
1459 |                         forge_log.write(f"[ERROR] {event.get('message')}")
1460 |                         forge_status.update("[red]Forge Failed. Logic Breach.[/red]")
1461 |                         
     | ^^^^^^^^^^^^^^^^^^^^^^^^
1462 |         except Exception as e:
1463 |             forge_log.write(f"[CRITICAL] {e}")
     |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
 --> src\cstar\core\uplink.py:1:1
  |
1 | / import os
2 | | import asyncio
3 | | import json
4 | | import socket
5 | | import sys
6 | | import time
7 | | from pathlib import Path
  | |________________________^
8 |
9 |   # Add project root to path for src imports
  |
help: Organize imports

F401 [*] `socket` imported but unused
 --> src\cstar\core\uplink.py:4:8
  |
2 | import asyncio
3 | import json
4 | import socket
  |        ^^^^^^
5 | import sys
6 | import time
  |
help: Remove unused import: `socket`

E402 Module level import not at top of file
  --> src\cstar\core\uplink.py:15:1
   |
13 |     sys.path.append(str(project_root))
14 |
15 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | # Constants
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:27:1
   |
25 |     Handles offloading complex queries to the external Antigravity system.
26 |     """
27 |     
   | ^^^^
28 |     def __init__(self, api_key: str = None):
29 |         """
   |
help: Remove whitespace from blank line

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\cstar\core\uplink.py:28:33
   |
26 |     """
27 |     
28 |     def __init__(self, api_key: str = None):
   |                                 ^^^
29 |         """
30 |         Initializes the AntigravityUplink.
   |
help: Convert to `T | None`

W293 Blank line contains whitespace
  --> src\cstar\core\uplink.py:31:1
   |
29 |         """
30 |         Initializes the AntigravityUplink.
31 |         
   | ^^^^^^^^
32 |         Args:
33 |             api_key (str, optional): The Google GenAI API key. 
   |
help: Remove whitespace from blank line

W291 Trailing whitespace
  --> src\cstar\core\uplink.py:33:63
   |
32 |         Args:
33 |             api_key (str, optional): The Google GenAI API key. 
   |                                                               ^
34 |                                      Prioritizes injected key over GOOGLE_API_KEY env var.
35 |         """
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:38:1
   |
36 |         self.host = ANTIGRAVITY_HOST
37 |         self.port = ANTIGRAVITY_PORT
38 |         
   | ^^^^^^^^
39 |         # 1. Accept injected key, fallback to standard TUI key
40 |         self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:41:1
   |
39 |         # 1. Accept injected key, fallback to standard TUI key
40 |         self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
41 |         
   | ^^^^^^^^
42 |         if not self.api_key:
43 |             HUD.persona_log("WARN", "No API key found for AntigravityUplink. Simulation mode only.")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:45:1
   |
43 |             HUD.persona_log("WARN", "No API key found for AntigravityUplink. Simulation mode only.")
44 |
45 |         
   | ^^^^^^^^
46 |         if not self.api_key:
47 |             # We don't raise here yet to allow Simulation mode in bridge, 
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\cstar\core\uplink.py:47:74
   |
46 |         if not self.api_key:
47 |             # We don't raise here yet to allow Simulation mode in bridge, 
   |                                                                          ^
48 |             # but we log it.
49 |             pass
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:50:1
   |
48 |             # but we log it.
49 |             pass
50 |         
   | ^^^^^^^^
51 |     async def send_payload(self, query: str, context: dict = None) -> dict:
52 |         """
   |
help: Remove whitespace from blank line

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\cstar\core\uplink.py:51:55
   |
49 |             pass
50 |         
51 |     async def send_payload(self, query: str, context: dict = None) -> dict:
   |                                                       ^^^^
52 |         """
53 |         Asynchronously sends a payload to Antigravity with a visual spinner.
   |
help: Convert to `T | None`

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:57:1
   |
55 |         if context is None:
56 |             context = {}
57 |             
   | ^^^^^^^^^^^^
58 |         payload = {
59 |             "query": query,
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:65:1
   |
63 |             "api_key": self.api_key
64 |         }
65 |         
   | ^^^^^^^^
66 |         # Determine Spinner Message based on Persona
67 |         msg = "O.D.I.N.: Communing with the void..." if context.get("persona") == "O.D.I.N." else "ALFRED: Consulting the Archives, sir..."
   |
help: Remove whitespace from blank line

E501 Line too long (131 > 100)
  --> src\cstar\core\uplink.py:67:101
   |
66 |         # Determine Spinner Message based on Persona
67 |         msg = "O.D.I.N.: Communing with the void..." if context.get("persona") == "O.D.I.N." else "ALFRED: Consulting the Archives, sir..."
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |         
69 |         # Start the task
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:68:1
   |
66 |         # Determine Spinner Message based on Persona
67 |         msg = "O.D.I.N.: Communing with the void..." if context.get("persona") == "O.D.I.N." else "ALFRED: Consulting the Archives, sir..."
68 |         
   | ^^^^^^^^
69 |         # Start the task
70 |         task = asyncio.create_task(self._transmit(payload))
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:71:1
   |
69 |         # Start the task
70 |         task = asyncio.create_task(self._transmit(payload))
71 |         
   | ^^^^^^^^
72 |         # Run Spinner while waiting
73 |         try:
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\cstar\core\uplink.py:77:35
   |
75 |         except Exception as e:
76 |             return {
77 |                 "status": "error", 
   |                                   ^
78 |                 "message": f"Uplink Severed: {str(e)}",
79 |                 "fallback": True
   |
help: Remove trailing whitespace

RUF010 [*] Use explicit conversion flag
  --> src\cstar\core\uplink.py:78:47
   |
76 |             return {
77 |                 "status": "error", 
78 |                 "message": f"Uplink Severed: {str(e)}",
   |                                               ^^^^^^
79 |                 "fallback": True
80 |             }
   |
help: Replace with conversion flag

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:86:1
   |
84 |         try:
85 |             reader, writer = await asyncio.open_connection(self.host, self.port)
86 |             
   | ^^^^^^^^^^^^
87 |             # Send
88 |             writer.write(json.dumps(payload).encode('utf-8'))
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:91:1
   |
89 |             await writer.drain()
90 |             writer.write_eof() # Explicit EOF to unblock server read
91 |             
   | ^^^^^^^^^^^^
92 |             # Receive (with timeout)
93 |             data = await asyncio.wait_for(reader.read(8192), timeout=TIMEOUT_SECONDS)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:95:1
   |
93 |             data = await asyncio.wait_for(reader.read(8192), timeout=TIMEOUT_SECONDS)
94 |             response = json.loads(data.decode('utf-8'))
95 |             
   | ^^^^^^^^^^^^
96 |             writer.close()
97 |             await writer.wait_closed()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\uplink.py:98:1
   |
96 |             writer.close()
97 |             await writer.wait_closed()
98 |             
   | ^^^^^^^^^^^^
99 |             return response
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\uplink.py:100:1
    |
 99 |             return response
100 |             
    | ^^^^^^^^^^^^
101 |         except (ConnectionRefusedError, OSError):
102 |             # Simulation Mode for Development if Antigravity is offline
    |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `_spinner`
   --> src\cstar\core\uplink.py:114:15
    |
114 |     async def _spinner(self, task, message):
    |               ^^^^^^^^
115 |         """Runs a CLI spinner until the task completes."""
116 |         spinner_chars = ['|', '/', '-', '\\']
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `task`
   --> src\cstar\core\uplink.py:114:30
    |
114 |     async def _spinner(self, task, message):
    |                              ^^^^
115 |         """Runs a CLI spinner until the task completes."""
116 |         spinner_chars = ['|', '/', '-', '\\']
    |

ANN001 Missing type annotation for function argument `message`
   --> src\cstar\core\uplink.py:114:36
    |
114 |     async def _spinner(self, task, message):
    |                                    ^^^^^^^
115 |         """Runs a CLI spinner until the task completes."""
116 |         spinner_chars = ['|', '/', '-', '\\']
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\uplink.py:118:1
    |
116 |         spinner_chars = ['|', '/', '-', '\\']
117 |         idx = 0
118 |         
    | ^^^^^^^^
119 |         # Hide Cursor
120 |         sys.stdout.write("\033[?25l")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\uplink.py:121:1
    |
119 |         # Hide Cursor
120 |         sys.stdout.write("\033[?25l")
121 |         
    | ^^^^^^^^
122 |         try:
123 |             while not task.done():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\cstar\core\uplink.py:128:1
    |
126 |                 idx = (idx + 1) % len(spinner_chars)
127 |                 await asyncio.sleep(0.1)
128 |             
    | ^^^^^^^^^^^^
129 |             sys.stdout.write("\r" + " " * (len(message) + 2) + "\r") # Clear line
130 |             return await task
    |
help: Remove whitespace from blank line

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\cstar\core\uplink.py:135:45
    |
133 |             sys.stdout.write("\033[?25h")
134 |
135 | async def query_bridge(query: str, context: dict = None) -> dict:
    |                                             ^^^^
136 |     """Convenience wrapper for the AntigravityUplink."""
137 |     uplink = AntigravityUplink()
    |
help: Convert to `T | None`

ANN201 Missing return type annotation for public function `main`
   --> src\cstar\core\uplink.py:142:15
    |
140 | # Quick Test
141 | if __name__ == "__main__":
142 |     async def main():
    |               ^^^^
143 |         uplink = AntigravityUplink()
144 |         print("Testing Uplink...")
    |
help: Add return type annotation: `None`

E501 Line too long (104 > 100)
   --> src\cstar\core\uplink.py:145:101
    |
143 |         uplink = AntigravityUplink()
144 |         print("Testing Uplink...")
145 |         res = await uplink.send_payload("What is the speed of an unladen swallow?", {"persona": "O.D.I.N."})
    |                                                                                                     ^^^^
146 |         print(json.dumps(res, indent=2))
    |

W293 [*] Blank line contains whitespace
   --> src\cstar\core\uplink.py:147:1
    |
145 |         res = await uplink.send_payload("What is the speed of an unladen swallow?", {"persona": "O.D.I.N."})
146 |         print(json.dumps(res, indent=2))
147 |         
    | ^^^^^^^^
148 |     asyncio.run(main())
    |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
 --> src\cstar\core\verify_forge_v4.py:1:1
  |
1 | / import asyncio
2 | | import json
3 | | import sys
4 | | import shutil
5 | | from pathlib import Path
6 | | from unittest.mock import MagicMock, AsyncMock
  | |______________________________________________^
7 |
8 |   # Add project root to path
  |
help: Organize imports

F401 [*] `json` imported but unused
 --> src\cstar\core\verify_forge_v4.py:2:8
  |
1 | import asyncio
2 | import json
  |        ^^^^
3 | import sys
4 | import shutil
  |
help: Remove unused import: `json`

F401 [*] `unittest.mock.MagicMock` imported but unused
 --> src\cstar\core\verify_forge_v4.py:6:27
  |
4 | import shutil
5 | from pathlib import Path
6 | from unittest.mock import MagicMock, AsyncMock
  |                           ^^^^^^^^^
7 |
8 | # Add project root to path
  |
help: Remove unused import: `unittest.mock.MagicMock`

E402 Module level import not at top of file
  --> src\cstar\core\verify_forge_v4.py:14:1
   |
12 |     sys.path.append(str(project_root))
13 |
14 | from src.cstar.core.forge import Forge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |
16 | async def main():
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\cstar\core\verify_forge_v4.py:14:1
   |
12 |     sys.path.append(str(project_root))
13 |
14 | from src.cstar.core.forge import Forge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |
16 | async def main():
   |
help: Organize imports

ANN201 Missing return type annotation for public function `main`
  --> src\cstar\core\verify_forge_v4.py:16:11
   |
14 | from src.cstar.core.forge import Forge
15 |
16 | async def main():
   |           ^^^^
17 |     print("=== Verifying Forge V4 Pipeline ===")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:18:1
   |
16 | async def main():
17 |     print("=== Verifying Forge V4 Pipeline ===")
18 |     
   | ^^^^
19 |     # Setup Test Environment
20 |     test_dir = project_root / "tests" / "forge_v4_verification"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:24:1
   |
22 |     target_file = test_dir / "target_component.py"
23 |     target_file.write_text("# Initial Content", encoding="utf-8")
24 |     
   | ^^^^
25 |     # Mock Uplink
26 |     mock_uplink = AsyncMock()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:27:1
   |
25 |     # Mock Uplink
26 |     mock_uplink = AsyncMock()
27 |     
   | ^^^^
28 |     # Scenario: 
29 |     # 1. O.D.I.N. returns code.
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\cstar\core\verify_forge_v4.py:28:16
   |
26 |     mock_uplink = AsyncMock()
27 |     
28 |     # Scenario: 
   |                ^
29 |     # 1. O.D.I.N. returns code.
30 |     # 2. ALFRED returns valid test JSON.
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:33:1
   |
31 |     # 3. Test runs and writes gungnir_{session_id}.json
32 |     # 4. SPRT parses it.
33 |     
   | ^^^^
34 |     async def mock_send_payload(query, context):
35 |         if "FORGE:" in query:
   |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `mock_send_payload`
  --> src\cstar\core\verify_forge_v4.py:34:15
   |
32 |     # 4. SPRT parses it.
33 |     
34 |     async def mock_send_payload(query, context):
   |               ^^^^^^^^^^^^^^^^^
35 |         if "FORGE:" in query:
36 |             print(f"[MOCK O.D.I.N.] Generating component code...")
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
  --> src\cstar\core\verify_forge_v4.py:34:33
   |
32 |     # 4. SPRT parses it.
33 |     
34 |     async def mock_send_payload(query, context):
   |                                 ^^^^^
35 |         if "FORGE:" in query:
36 |             print(f"[MOCK O.D.I.N.] Generating component code...")
   |

ANN001 Missing type annotation for function argument `context`
  --> src\cstar\core\verify_forge_v4.py:34:40
   |
32 |     # 4. SPRT parses it.
33 |     
34 |     async def mock_send_payload(query, context):
   |                                        ^^^^^^^
35 |         if "FORGE:" in query:
36 |             print(f"[MOCK O.D.I.N.] Generating component code...")
   |

F541 [*] f-string without any placeholders
  --> src\cstar\core\verify_forge_v4.py:36:19
   |
34 |     async def mock_send_payload(query, context):
35 |         if "FORGE:" in query:
36 |             print(f"[MOCK O.D.I.N.] Generating component code...")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |             return {
38 |                 "status": "success",
   |
help: Remove extraneous `f` prefix

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:44:1
   |
42 |             print(f"[MOCK ALFRED] Generating test suite (SID: {context.get('session_id')})...")
43 |             session_id = context.get('session_id')
44 |             
   | ^^^^^^^^^^^^
45 |             # Create a test file that PASSES and writes gungnir JSON
46 |             test_code = f"""
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:52:1
   |
50 | def test_add():
51 |     assert 1 + 1 == 2
52 |     
   | ^^^^
53 | if __name__ == "__main__":
54 |     test_add()
   |
help: Remove whitespace from blank line

E501 Line too long (102 > 100)
  --> src\cstar\core\verify_forge_v4.py:62:101
   |
60 |                 "data": {
61 |                     "lint_command": "echo Linting Passed", # Mock lint
62 |                     "test_command": f"python tests/forge_v4_verification/test_target_{session_id}.py",
   |                                                                                                     ^^
63 |                     "test_filename": f"tests/forge_v4_verification/test_target_{session_id}.py",
64 |                     "test_code": test_code
   |

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:70:1
   |
69 |     mock_uplink.send_payload = mock_send_payload
70 |     
   | ^^^^
71 |     # Initialize Forge with Mock
72 |     forge = Forge()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\cstar\core\verify_forge_v4.py:75:1
   |
73 |     forge.uplink = mock_uplink
74 |     forge.max_retries = 1
75 |     
   | ^^^^
76 |     # Execute
77 |     print("\n--- Starting Forge Execution ---")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\games\odin_protocol\engine\adjudicator.py:49:1
   |
47 |             scenario=action.get("scenario", {}),
48 |         )
49 |         
   | ^^^^^^^^
50 |         success = result["success"]
   |
help: Remove whitespace from blank line

E501 Line too long (113 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:106:101
    |
104 |         The 'options' (A, B, C, H) MUST be highly thematic and directly
105 |         related to resolving the goal or navigating the conflict.
106 |         Avoid generic terms like 'Brute Force' unless it's specific to the scene (e.g. 'Shatter the Vault Seal').
    |                                                                                                     ^^^^^^^^^^^^^
107 |
108 |         OUTPUT FORMAT (JSON ONLY):
    |

E501 Line too long (125 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:111:101
    |
109 |         {{
110 |           "planet_name": "Evocative Name",
111 |           "lore": "A 1-sentence description of why it's a target (e.g. 'A primordial furnace world needing kinetic siege').",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
112 |           "goal": "A specific literary goal (e.g., 'Extraction of a Primordial Essence')",
113 |           "conflict": "A specific literary conflict (e.g., 'Gravity storms are crushing all tactical structure')",
    |

E501 Line too long (114 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:113:101
    |
111 |           "lore": "A 1-sentence description of why it's a target (e.g. 'A primordial furnace world needing kinetic siege').",
112 |           "goal": "A specific literary goal (e.g., 'Extraction of a Primordial Essence')",
113 |           "conflict": "A specific literary conflict (e.g., 'Gravity storms are crushing all tactical structure')",
    |                                                                                                     ^^^^^^^^^^^^^^
114 |           "disaster": "A potential failure disaster (e.g., 'A temporal feedback loop erases your gains')",
115 |           "environmental_hazard": "A brutal description of the lethal threat",
    |

E501 Line too long (106 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:114:101
    |
112 |           "goal": "A specific literary goal (e.g., 'Extraction of a Primordial Essence')",
113 |           "conflict": "A specific literary conflict (e.g., 'Gravity storms are crushing all tactical structure')",
114 |           "disaster": "A potential failure disaster (e.g., 'A temporal feedback loop erases your gains')",
    |                                                                                                     ^^^^^^
115 |           "environmental_hazard": "A brutal description of the lethal threat",
116 |           "fauna": "Apex Predators/Docile Grazers/etc",
    |

E501 Line too long (109 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:120:101
    |
118 |           "sediment": "Explosive Crust/Solid Obsidian/etc",
119 |           "civ_type": "Ascended Neural Nets/Industrial Bastions/etc",
120 |           "immediate_question": "How shall we achieve our goal on {{planet_name}}, Warlord {{player_name}}?",
    |                                                                                                     ^^^^^^^^^
121 |           "dominance_gain": 3.5,
122 |           "failure_penalty": 10.0,
    |

E501 Line too long (127 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:130:101
    |
128 |           }},
129 |           "options": [
130 |               {{"id": "A", "text": "Hard (e.g. 'Sunder the Core')", "threshold": {combat_rating + 5.0}, "difficulty": "Hard"}},
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
131 |               {{"id": "B", "text": "Normal (e.g. 'Navigate Spire')", "threshold": {combat_rating + 1.0}, "difficulty": "Normal"}},
132 |               {{"id": "C", "text": "Gamble (e.g. 'Bargain Warden')", "threshold": {combat_rating + 10.0}, "difficulty": "Gamble"}},
    |

E501 Line too long (130 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:131:101
    |
129 |           "options": [
130 |               {{"id": "A", "text": "Hard (e.g. 'Sunder the Core')", "threshold": {combat_rating + 5.0}, "difficulty": "Hard"}},
131 |               {{"id": "B", "text": "Normal (e.g. 'Navigate Spire')", "threshold": {combat_rating + 1.0}, "difficulty": "Normal"}},
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
132 |               {{"id": "C", "text": "Gamble (e.g. 'Bargain Warden')", "threshold": {combat_rating + 10.0}, "difficulty": "Gamble"}},
133 |               {{"id": "H", "text": "Easy (e.g. 'Gather Essences')", "threshold": {combat_rating - 2.0}, "difficulty": "Easy"}}
    |

E501 Line too long (131 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:132:101
    |
130 |               {{"id": "A", "text": "Hard (e.g. 'Sunder the Core')", "threshold": {combat_rating + 5.0}, "difficulty": "Hard"}},
131 |               {{"id": "B", "text": "Normal (e.g. 'Navigate Spire')", "threshold": {combat_rating + 1.0}, "difficulty": "Normal"}},
132 |               {{"id": "C", "text": "Gamble (e.g. 'Bargain Warden')", "threshold": {combat_rating + 10.0}, "difficulty": "Gamble"}},
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |               {{"id": "H", "text": "Easy (e.g. 'Gather Essences')", "threshold": {combat_rating - 2.0}, "difficulty": "Easy"}}
134 |           ]
    |

E501 Line too long (126 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:133:101
    |
131 |               {{"id": "B", "text": "Normal (e.g. 'Navigate Spire')", "threshold": {combat_rating + 1.0}, "difficulty": "Normal"}},
132 |               {{"id": "C", "text": "Gamble (e.g. 'Bargain Warden')", "threshold": {combat_rating + 10.0}, "difficulty": "Gamble"}},
133 |               {{"id": "H", "text": "Easy (e.g. 'Gather Essences')", "threshold": {combat_rating - 2.0}, "difficulty": "Easy"}}
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
134 |           ]
135 |         }}
    |

E501 Line too long (113 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:156:101
    |
154 |             )
155 |
156 |     def describe_outcome(self, scenario: dict[str, Any], player_name: str, choice_id: str, success: bool) -> str:
    |                                                                                                     ^^^^^^^^^^^^^
157 |         """Narrates the result of a choice as a cautious or over-excited Bard.
    |

E501 Line too long (121 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:181:101
    |
179 | â€¦     TASK:
180 | â€¦     Narrate the outcome of this action.
181 | â€¦     - IF SUCCESS: Be absolutely hyperbolic. Make it sound like {player_name} is a god who moved the stars themselves.
    |                                                                                                   ^^^^^^^^^^^^^^^^^^^^^
182 | â€¦     - IF FAILURE: Sugarcoat it. Frame it as a 'strategic repositioning' or a 'test of fate'. Use flowery language to avoid the Warlâ€¦
    |

E501 Line too long (147 > 100)
   --> src\games\odin_protocol\engine\gm_client.py:182:101
    |
180 | â€¦
181 | â€¦und like {player_name} is a god who moved the stars themselves.
182 | â€¦ic repositioning' or a 'test of fate'. Use flowery language to avoid the Warlord's wrath.
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 | â€¦
184 | â€¦
    |

F401 [*] `math` imported but unused
 --> src\games\odin_protocol\engine\logic.py:1:8
  |
1 | import math
  |        ^^^^
2 | import subprocess
  |
help: Remove unused import: `math`

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\engine\logic.py:120:13
    |
118 |     try:
119 |         git_hash = subprocess.check_output(
120 |             ["git", "rev-parse", "--short", "HEAD"],
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 |             cwd=project_root,
122 |             stderr=subprocess.STDOUT
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\logic.py:128:101
    |
126 |         return "C*FALLBACK_GENESIS"
127 |
128 | def calculate_effective_stats(inventory: dict[str, Chromosome], items: list[Item], world_modifiers: list[dict] = None) -> dict[str, fâ€¦
    |                                                                                                     ^^^^^^^^^^
129 |     """Calculates the ripple-effect math with Recursive Synergies and Compounds.
    |
help: Convert to `T | None`

E501 Line too long (139 > 100)
   --> src\games\odin_protocol\engine\logic.py:128:101
    |
126 | â€¦
127 | â€¦
128 | â€¦omosome], items: list[Item], world_modifiers: list[dict] = None) -> dict[str, float]:
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
129 | â€¦e Synergies and Compounds.
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\logic.py:155:23
    |
153 |     for char_id, level in base_snapshot.items():
154 |         mapping = SYNERGY_MAP.get(char_id)
155 |         if not mapping: continue
    |                       ^
156 |
157 |         # Apply logic: Inverted planets swap Synergies and Interferences
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\logic.py:163:35
    |
162 |         for target in mapping["synergies"]:
163 |             if target in eff_stats: eff_stats[target] += (level * syn_mult)
    |                                   ^
164 |         for target in mapping["interferences"]:
165 |             if target in eff_stats: eff_stats[target] += (level * int_mult)
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\logic.py:165:35
    |
163 |             if target in eff_stats: eff_stats[target] += (level * syn_mult)
164 |         for target in mapping["interferences"]:
165 |             if target in eff_stats: eff_stats[target] += (level * int_mult)
    |                                   ^
166 |
167 |     return eff_stats
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\logic.py:171:27
    |
169 | def get_combat_rating(effective_stats: dict[str, float]) -> float:
170 |     """Reduces the entire genetic manifest to a single 'Dominion Score'."""
171 |     if not effective_stats: return 0.0
    |                           ^
172 |     return sum(effective_stats.values())
    |

SIM108 Use ternary operator `dom_delta = TacticalRNG.uniform(1.5, 4.0) if success else -TacticalRNG.uniform(2.0, 5.0)` instead of `if`-`else`-block
   --> src\games\odin_protocol\engine\logic.py:212:5
    |
211 |       # Domination Adjudication
212 | /     if success:
213 | |         dom_delta = TacticalRNG.uniform(1.5, 4.0)
214 | |     else:
215 | |         dom_delta = -TacticalRNG.uniform(2.0, 5.0)
    | |__________________________________________________^
216 |
217 |       penalty_msg = ""
    |
help: Replace `if`-`else`-block with `dom_delta = TacticalRNG.uniform(1.5, 4.0) if success else -TacticalRNG.uniform(2.0, 5.0)`

ANN201 Missing return type annotation for public function `to_dict`
  --> src\games\odin_protocol\engine\models.py:27:9
   |
25 |     interferences: list[str] = field(default_factory=list)  # Nerfs these
26 |
27 |     def to_dict(self):
   |         ^^^^^^^
28 |         return {
29 |             "id": self.id,
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `to_dict`
  --> src\games\odin_protocol\engine\models.py:47:9
   |
45 |     durability: int = 100   # Percentage (decreases on failure)
46 |
47 |     def to_dict(self):
   |         ^^^^^^^
48 |         return {
49 |             "id": self.id,
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `to_dict`
  --> src\games\odin_protocol\engine\models.py:95:9
   |
93 |     last_updated: float = field(default_factory=time.time)
94 |
95 |     def to_dict(self):
   |         ^^^^^^^
96 |         return {
97 |             "seed": self.seed,
   |
help: Add return type annotation

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\engine\persistence.py:22:26
   |
20 |         """
21 |         self.project_root = project_root
22 |         self.save_path = os.path.join(project_root, "odin_protocol", "save_state.json")
   |                          ^^^^^^^^^^^^
23 |         self.worlds_dir = os.path.join(project_root, "odin_protocol", "worlds")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\engine\persistence.py:23:27
   |
21 |         self.project_root = project_root
22 |         self.save_path = os.path.join(project_root, "odin_protocol", "save_state.json")
23 |         self.worlds_dir = os.path.join(project_root, "odin_protocol", "worlds")
   |                           ^^^^^^^^^^^^
24 |
25 |         if not os.path.exists(self.worlds_dir):
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\games\odin_protocol\engine\persistence.py:25:16
   |
23 |         self.worlds_dir = os.path.join(project_root, "odin_protocol", "worlds")
24 |
25 |         if not os.path.exists(self.worlds_dir):
   |                ^^^^^^^^^^^^^^
26 |             os.makedirs(self.worlds_dir)
   |
help: Replace with `Path(...).exists()`

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
  --> src\games\odin_protocol\engine\persistence.py:26:13
   |
25 |         if not os.path.exists(self.worlds_dir):
26 |             os.makedirs(self.worlds_dir)
   |             ^^^^^^^^^^^
27 |
28 |     def save_state(self, state: dict[str, Any], world_name: str, outcome: str) -> None:
   |
help: Replace with `Path(...).mkdir(parents=True)`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\games\odin_protocol\engine\persistence.py:38:18
   |
36 |         try:
37 |             # 1. Write current state
38 |             with open(self.save_path, "w") as f:
   |                  ^^^^
39 |                 json.dump(state, f, indent=4)
   |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\engine\persistence.py:43:26
   |
41 |             # 2. Archival record of the world
42 |             world_filename = f"world_{world_name.replace(' ', '_').lower()}.json"
43 |             world_path = os.path.join(self.worlds_dir, world_filename)
   |                          ^^^^^^^^^^^^
44 |             with open(world_path, "w") as f:
45 |                 json.dump({
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\games\odin_protocol\engine\persistence.py:44:18
   |
42 |             world_filename = f"world_{world_name.replace(' ', '_').lower()}.json"
43 |             world_path = os.path.join(self.worlds_dir, world_filename)
44 |             with open(world_path, "w") as f:
   |                  ^^^^
45 |                 json.dump({
46 |                     "world_name": world_name,
   |
help: Replace with `Path.open()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\games\odin_protocol\engine\persistence.py:64:16
   |
62 |             The loaded state dictionary, or None if no save exists.
63 |         """
64 |         if not os.path.exists(self.save_path):
   |                ^^^^^^^^^^^^^^
65 |             return None
66 |         try:
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\games\odin_protocol\engine\persistence.py:67:18
   |
65 |             return None
66 |         try:
67 |             with open(self.save_path) as f:
   |                  ^^^^
68 |                 return json.load(f)
69 |         except (OSError, json.JSONDecodeError) as e:
   |
help: Replace with `Path.open()`

S603 `subprocess` call: check for execution of untrusted input
  --> src\games\odin_protocol\engine\persistence.py:81:13
   |
79 |         try:
80 |             # Stage only the O.D.I.N. Protocol files to avoid accidental commits of project code
81 |             subprocess.run(["git", "add", self.save_path, self.worlds_dir],
   |             ^^^^^^^^^^^^^^
82 |                            cwd=self.project_root, check=True, capture_output=True)
   |

S607 Starting a process with a partial executable path
  --> src\games\odin_protocol\engine\persistence.py:81:28
   |
79 |         try:
80 |             # Stage only the O.D.I.N. Protocol files to avoid accidental commits of project code
81 |             subprocess.run(["git", "add", self.save_path, self.worlds_dir],
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |                            cwd=self.project_root, check=True, capture_output=True)
   |

S603 `subprocess` call: check for execution of untrusted input
  --> src\games\odin_protocol\engine\persistence.py:85:13
   |
84 |             # Commit (Allow empty in case of re-save with no changes)
85 |             subprocess.run(["git", "commit", "--allow-empty", "-m", message],
   |             ^^^^^^^^^^^^^^
86 |                            cwd=self.project_root, check=True, capture_output=True)
   |

S607 Starting a process with a partial executable path
  --> src\games\odin_protocol\engine\persistence.py:85:28
   |
84 |             # Commit (Allow empty in case of re-save with no changes)
85 |             subprocess.run(["git", "commit", "--allow-empty", "-m", message],
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |                            cwd=self.project_root, check=True, capture_output=True)
   |

W292 [*] No newline at end of file
  --> src\games\odin_protocol\engine\persistence.py:94:81
   |
92 |             logging.warning(f"Git Persistence Warning: {err_msg}")
93 |         except FileNotFoundError:
94 |             logging.warning("Git Persistence Warning: 'git' command not found.")
   |                                                                                 ^
   |
help: Add trailing newline

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\games\odin_protocol\engine\rng.py:16:16
   |
14 |     def random() -> float:
15 |         """Returns a float between 0.0 and 1.0."""
16 |         return random.random()
   |                ^^^^^^^^^^^^^^^
17 |
18 |     @staticmethod
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\games\odin_protocol\engine\rng.py:21:16
   |
19 |     def uniform(a: float, b: float) -> float:
20 |         """Returns a random float N such that a <= N <= b."""
21 |         return random.uniform(a, b)
   |                ^^^^^^^^^^^^^^^^^^^^
22 |
23 |     @staticmethod
   |

ANN205 Missing return type annotation for staticmethod `choice`
  --> src\games\odin_protocol\engine\rng.py:24:9
   |
23 |     @staticmethod
24 |     def choice(seq):
   |         ^^^^^^
25 |         """Choose a random element from a non-empty sequence."""
26 |         return random.choice(seq)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `seq`
  --> src\games\odin_protocol\engine\rng.py:24:16
   |
23 |     @staticmethod
24 |     def choice(seq):
   |                ^^^
25 |         """Choose a random element from a non-empty sequence."""
26 |         return random.choice(seq)
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\games\odin_protocol\engine\rng.py:26:16
   |
24 |     def choice(seq):
25 |         """Choose a random element from a non-empty sequence."""
26 |         return random.choice(seq)
   |                ^^^^^^^^^^^^^^^^^^
27 |
28 |     @staticmethod
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\games\odin_protocol\engine\rng.py:31:16
   |
29 |     def randint(a: int, b: int) -> int:
30 |         """Return random integer in range [a, b], including both end points."""
31 |         return random.randint(a, b)
   |                ^^^^^^^^^^^^^^^^^^^^
32 |
33 |     @staticmethod
   |

ANN205 Missing return type annotation for staticmethod `secure_choice`
  --> src\games\odin_protocol\engine\rng.py:34:9
   |
33 |     @staticmethod
34 |     def secure_choice(seq):
   |         ^^^^^^^^^^^^^
35 |         """Cryptographically secure choice."""
36 |         return secrets.choice(seq)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `seq`
  --> src\games\odin_protocol\engine\rng.py:34:23
   |
33 |     @staticmethod
34 |     def secure_choice(seq):
   |                       ^^^
35 |         """Cryptographically secure choice."""
36 |         return secrets.choice(seq)
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:14:17
   |
12 |       """
13 |
14 |       ENV_PAIRS = [
   |  _________________^
15 | |         {"name": "Gravity", "factor": "Physical_Hardness", "pairs": ["AESIR_MIGHT", "BERSERKER_RAGE"]},
16 | |         {"name": "Atmosphere", "factor": "Terrain_Complexity", "pairs": ["VALKYRIE_LUNGE", "SKADI_GLIDE"]},
17 | |         {"name": "Information_Density", "factor": "Visual_Clarity", "pairs": ["HUGINN_SIGHT", "MUNINN_MEM"]},
18 | |         {"name": "Sensor_Resolution", "factor": "Ambient_Noise", "pairs": ["LOKI_SHADOW", "FAFNIR_SILENCE"]},
19 | |         {"name": "Radiation", "factor": "Impact_Force", "pairs": ["TYR_BARRIER", "YMIR_STONE"]},
20 | |         {"name": "Temperature", "factor": "Energy_Stability", "pairs": ["SURTR_FLAME", "HEL_COLD"]},
21 | |         {"name": "Bio_Hazard", "factor": "Nutrient_Richness", "pairs": ["IDUNN_BLOOM", "NIDHOGG_DECAY"]},
22 | |         {"name": "Ether_Density", "factor": "Reality_Stability", "pairs": ["FREYJA_WEAVE", "GINNUNGAGAP_VOID"]},
23 | |         {"name": "Vibration", "factor": "Electromagnetic_Storm", "pairs": ["HEIMDALL_WATCH", "JORMUNGANDR_COIL"]},
24 | |         {"name": "Chaos_Level", "factor": "Social_Cohesion", "pairs": ["BALDR_LIGHT", "BRAGI_SONG"]},
25 | |         {"name": "Entropy", "factor": "Volatile_Atmosphere", "pairs": ["FENRIR_JAW", "SURTR_ASH"]},
26 | |         {"name": "Ancient_Power", "factor": "Knowledge_Scarcity", "pairs": ["MIMIR_WELL", "ODIN_EYE"]}
27 | |     ]
   | |_____^
28 |
29 |       PLANET_PREFIXES = ["Grave of", "Echo of", "Siege of", "Void of", "Iron", "Frozen", "Burning", "Shattered"]
   |

E501 Line too long (103 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:15:101
   |
14 |     ENV_PAIRS = [
15 |         {"name": "Gravity", "factor": "Physical_Hardness", "pairs": ["AESIR_MIGHT", "BERSERKER_RAGE"]},
   |                                                                                                     ^^^
16 |         {"name": "Atmosphere", "factor": "Terrain_Complexity", "pairs": ["VALKYRIE_LUNGE", "SKADI_GLIDE"]},
17 |         {"name": "Information_Density", "factor": "Visual_Clarity", "pairs": ["HUGINN_SIGHT", "MUNINN_MEM"]},
   |

E501 Line too long (107 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:16:101
   |
14 |     ENV_PAIRS = [
15 |         {"name": "Gravity", "factor": "Physical_Hardness", "pairs": ["AESIR_MIGHT", "BERSERKER_RAGE"]},
16 |         {"name": "Atmosphere", "factor": "Terrain_Complexity", "pairs": ["VALKYRIE_LUNGE", "SKADI_GLIDE"]},
   |                                                                                                     ^^^^^^^
17 |         {"name": "Information_Density", "factor": "Visual_Clarity", "pairs": ["HUGINN_SIGHT", "MUNINN_MEM"]},
18 |         {"name": "Sensor_Resolution", "factor": "Ambient_Noise", "pairs": ["LOKI_SHADOW", "FAFNIR_SILENCE"]},
   |

E501 Line too long (109 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:17:101
   |
15 |         {"name": "Gravity", "factor": "Physical_Hardness", "pairs": ["AESIR_MIGHT", "BERSERKER_RAGE"]},
16 |         {"name": "Atmosphere", "factor": "Terrain_Complexity", "pairs": ["VALKYRIE_LUNGE", "SKADI_GLIDE"]},
17 |         {"name": "Information_Density", "factor": "Visual_Clarity", "pairs": ["HUGINN_SIGHT", "MUNINN_MEM"]},
   |                                                                                                     ^^^^^^^^^
18 |         {"name": "Sensor_Resolution", "factor": "Ambient_Noise", "pairs": ["LOKI_SHADOW", "FAFNIR_SILENCE"]},
19 |         {"name": "Radiation", "factor": "Impact_Force", "pairs": ["TYR_BARRIER", "YMIR_STONE"]},
   |

E501 Line too long (109 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:18:101
   |
16 |         {"name": "Atmosphere", "factor": "Terrain_Complexity", "pairs": ["VALKYRIE_LUNGE", "SKADI_GLIDE"]},
17 |         {"name": "Information_Density", "factor": "Visual_Clarity", "pairs": ["HUGINN_SIGHT", "MUNINN_MEM"]},
18 |         {"name": "Sensor_Resolution", "factor": "Ambient_Noise", "pairs": ["LOKI_SHADOW", "FAFNIR_SILENCE"]},
   |                                                                                                     ^^^^^^^^^
19 |         {"name": "Radiation", "factor": "Impact_Force", "pairs": ["TYR_BARRIER", "YMIR_STONE"]},
20 |         {"name": "Temperature", "factor": "Energy_Stability", "pairs": ["SURTR_FLAME", "HEL_COLD"]},
   |

E501 Line too long (105 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:21:101
   |
19 |         {"name": "Radiation", "factor": "Impact_Force", "pairs": ["TYR_BARRIER", "YMIR_STONE"]},
20 |         {"name": "Temperature", "factor": "Energy_Stability", "pairs": ["SURTR_FLAME", "HEL_COLD"]},
21 |         {"name": "Bio_Hazard", "factor": "Nutrient_Richness", "pairs": ["IDUNN_BLOOM", "NIDHOGG_DECAY"]},
   |                                                                                                     ^^^^^
22 |         {"name": "Ether_Density", "factor": "Reality_Stability", "pairs": ["FREYJA_WEAVE", "GINNUNGAGAP_VOID"]},
23 |         {"name": "Vibration", "factor": "Electromagnetic_Storm", "pairs": ["HEIMDALL_WATCH", "JORMUNGANDR_COIL"]},
   |

E501 Line too long (112 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:22:101
   |
20 |         {"name": "Temperature", "factor": "Energy_Stability", "pairs": ["SURTR_FLAME", "HEL_COLD"]},
21 |         {"name": "Bio_Hazard", "factor": "Nutrient_Richness", "pairs": ["IDUNN_BLOOM", "NIDHOGG_DECAY"]},
22 |         {"name": "Ether_Density", "factor": "Reality_Stability", "pairs": ["FREYJA_WEAVE", "GINNUNGAGAP_VOID"]},
   |                                                                                                     ^^^^^^^^^^^^
23 |         {"name": "Vibration", "factor": "Electromagnetic_Storm", "pairs": ["HEIMDALL_WATCH", "JORMUNGANDR_COIL"]},
24 |         {"name": "Chaos_Level", "factor": "Social_Cohesion", "pairs": ["BALDR_LIGHT", "BRAGI_SONG"]},
   |

E501 Line too long (114 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:23:101
   |
21 |         {"name": "Bio_Hazard", "factor": "Nutrient_Richness", "pairs": ["IDUNN_BLOOM", "NIDHOGG_DECAY"]},
22 |         {"name": "Ether_Density", "factor": "Reality_Stability", "pairs": ["FREYJA_WEAVE", "GINNUNGAGAP_VOID"]},
23 |         {"name": "Vibration", "factor": "Electromagnetic_Storm", "pairs": ["HEIMDALL_WATCH", "JORMUNGANDR_COIL"]},
   |                                                                                                     ^^^^^^^^^^^^^^
24 |         {"name": "Chaos_Level", "factor": "Social_Cohesion", "pairs": ["BALDR_LIGHT", "BRAGI_SONG"]},
25 |         {"name": "Entropy", "factor": "Volatile_Atmosphere", "pairs": ["FENRIR_JAW", "SURTR_ASH"]},
   |

E501 Line too long (101 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:24:101
   |
22 |         {"name": "Ether_Density", "factor": "Reality_Stability", "pairs": ["FREYJA_WEAVE", "GINNUNGAGAP_VOID"]},
23 |         {"name": "Vibration", "factor": "Electromagnetic_Storm", "pairs": ["HEIMDALL_WATCH", "JORMUNGANDR_COIL"]},
24 |         {"name": "Chaos_Level", "factor": "Social_Cohesion", "pairs": ["BALDR_LIGHT", "BRAGI_SONG"]},
   |                                                                                                     ^
25 |         {"name": "Entropy", "factor": "Volatile_Atmosphere", "pairs": ["FENRIR_JAW", "SURTR_ASH"]},
26 |         {"name": "Ancient_Power", "factor": "Knowledge_Scarcity", "pairs": ["MIMIR_WELL", "ODIN_EYE"]}
   |

E501 Line too long (102 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:26:101
   |
24 |         {"name": "Chaos_Level", "factor": "Social_Cohesion", "pairs": ["BALDR_LIGHT", "BRAGI_SONG"]},
25 |         {"name": "Entropy", "factor": "Volatile_Atmosphere", "pairs": ["FENRIR_JAW", "SURTR_ASH"]},
26 |         {"name": "Ancient_Power", "factor": "Knowledge_Scarcity", "pairs": ["MIMIR_WELL", "ODIN_EYE"]}
   |                                                                                                     ^^
27 |     ]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:29:23
   |
27 |     ]
28 |
29 |     PLANET_PREFIXES = ["Grave of", "Echo of", "Siege of", "Void of", "Iron", "Frozen", "Burning", "Shattered"]
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |     PLANET_SUFFIXES = ["Solitude", "Niflheim", "Muspelheim", "Hel", "Yggdrasil", "Fensalir", "Vanaheim", "Asgard"]
   |

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:29:101
   |
27 |     ]
28 |
29 |     PLANET_PREFIXES = ["Grave of", "Echo of", "Siege of", "Void of", "Iron", "Frozen", "Burning", "Shattered"]
   |                                                                                                     ^^^^^^^^^^
30 |     PLANET_SUFFIXES = ["Solitude", "Niflheim", "Muspelheim", "Hel", "Yggdrasil", "Fensalir", "Vanaheim", "Asgard"]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:30:23
   |
29 |     PLANET_PREFIXES = ["Grave of", "Echo of", "Siege of", "Void of", "Iron", "Frozen", "Burning", "Shattered"]
30 |     PLANET_SUFFIXES = ["Solitude", "Niflheim", "Muspelheim", "Hel", "Yggdrasil", "Fensalir", "Vanaheim", "Asgard"]
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 |     GOALS = [
   |

E501 Line too long (114 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:30:101
   |
29 |     PLANET_PREFIXES = ["Grave of", "Echo of", "Siege of", "Void of", "Iron", "Frozen", "Burning", "Shattered"]
30 |     PLANET_SUFFIXES = ["Solitude", "Niflheim", "Muspelheim", "Hel", "Yggdrasil", "Fensalir", "Vanaheim", "Asgard"]
   |                                                                                                     ^^^^^^^^^^^^^^
31 |
32 |     GOALS = [
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:32:13
   |
30 |       PLANET_SUFFIXES = ["Solitude", "Niflheim", "Muspelheim", "Hel", "Yggdrasil", "Fensalir", "Vanaheim", "Asgard"]
31 |
32 |       GOALS = [
   |  _____________^
33 | |         "The extraction of a primordial Bio-Seed from the world's marrow",
34 | |         "The clinical subjugation of an Ascended Hive-Mind screaming in the void",
35 | |         "The reclamation of a Lost Genetic Vault buried beneath shifting obsidian",
36 | |         "The containment of a volatile Bio-Hazard threatening to liquefy your race",
37 | |         "The systematic erosion of reality within a Primordial Abyss",
38 | |         "The forced inoculation of the World-Seed with your genetic signature"
39 | |     ]
   | |_____^
40 |
41 |       CONFLICTS = [
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:41:17
   |
39 |       ]
40 |
41 |       CONFLICTS = [
   |  _________________^
42 | |         "The atmosphere is a choking fog of electromagnetic discharge and static screams.",
43 | |         "Raging gravity storms are liquefying your structural supports in real-time.",
44 | |         "The local flora is a sentient, pulsating mesh actively resisting your neural probes.",
45 | |         "A temporal anomaly has fractured the timeline, causing tactical echoes and loops.",
46 | |         "Deep-crust tectonic volatility threatens to swallow your entire landing zone.",
47 | |         "Lethal radiation from the exposed world-core is melting your physical shielding."
48 | |     ]
   | |_____^
49 |
50 |       DISASTERS = [
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:50:17
   |
48 |       ]
49 |
50 |       DISASTERS = [
   |  _________________^
51 | |         "The world-seed rejects your presence, triggering a planet-wide tectonic collapse.",
52 | |         "A temporal feedback loop erases your tactical gains and fractures your causality.",
53 | |         "The local civilizations launch a desperate, scorched-earth neural counter-strike.",
54 | |         "The environment itself inverts, turning your genetic strengths into lethal flaws."
55 | |     ]
   | |_____^
56 |
57 |       ENCOUNTER_PILLARS = ["HAZARD", "CONFRONTATION", "ELEMENTAL", "FAILURE", "REFLECTIVE"]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:57:25
   |
55 |     ]
56 |
57 |     ENCOUNTER_PILLARS = ["HAZARD", "CONFRONTATION", "ELEMENTAL", "FAILURE", "REFLECTIVE"]
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |
59 |     PILLAR_DEFINITIONS = {
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:59:26
   |
57 |       ENCOUNTER_PILLARS = ["HAZARD", "CONFRONTATION", "ELEMENTAL", "FAILURE", "REFLECTIVE"]
58 |
59 |       PILLAR_DEFINITIONS = {
   |  __________________________^
60 | |         "HAZARD": "Environmental survival. The world itself is trying to erase your presence.",
61 | |         "CONFRONTATION": "Direct tactical engagement with local forces or predators.",
62 | |         "ELEMENTAL": "Navigating the raw, chaotic physics of the planetary crust.",
63 | |         "FAILURE": "Technical or gear-related malfunctions requiring urgent triage.",
64 | |         "REFLECTIVE": "A quiet, philosophical moment in the ruinscape with a weary comrade."
65 | |     }
   | |_____^
66 |
67 |       PILLAR_PROMPTS = {
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\games\odin_protocol\engine\scenarios.py:67:22
   |
65 |       }
66 |
67 |       PILLAR_PROMPTS = {
   |  ______________________^
68 | |         "HAZARD": "The planet itself is striking back. Warlord, how do we survive the environmental onslaught?",
69 | |         "CONFRONTATION": "Tactical engagement is unavoidable. Warlord, how do we break the local resistance?",
70 | |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
71 | |         "FAILURE": "Our systems are failing under the pressure. Warlord, how do we triage this technical collapse?",
72 | |         "REFLECTIVE": "A moment of stillness in the slaughter. Warlord, what is your insight on this conquest?"
73 | |     }
   | |_____^
74 |
75 |       PILLAR_OPTIONS = {
   |

E501 Line too long (112 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:68:101
   |
67 |     PILLAR_PROMPTS = {
68 |         "HAZARD": "The planet itself is striking back. Warlord, how do we survive the environmental onslaught?",
   |                                                                                                     ^^^^^^^^^^^^
69 |         "CONFRONTATION": "Tactical engagement is unavoidable. Warlord, how do we break the local resistance?",
70 |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
   |

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:69:101
   |
67 |     PILLAR_PROMPTS = {
68 |         "HAZARD": "The planet itself is striking back. Warlord, how do we survive the environmental onslaught?",
69 |         "CONFRONTATION": "Tactical engagement is unavoidable. Warlord, how do we break the local resistance?",
   |                                                                                                     ^^^^^^^^^^
70 |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
71 |         "FAILURE": "Our systems are failing under the pressure. Warlord, how do we triage this technical collapse?",
   |

E501 Line too long (113 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:70:101
   |
68 |         "HAZARD": "The planet itself is striking back. Warlord, how do we survive the environmental onslaught?",
69 |         "CONFRONTATION": "Tactical engagement is unavoidable. Warlord, how do we break the local resistance?",
70 |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
   |                                                                                                     ^^^^^^^^^^^^^
71 |         "FAILURE": "Our systems are failing under the pressure. Warlord, how do we triage this technical collapse?",
72 |         "REFLECTIVE": "A moment of stillness in the slaughter. Warlord, what is your insight on this conquest?"
   |

E501 Line too long (116 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:71:101
   |
69 |         "CONFRONTATION": "Tactical engagement is unavoidable. Warlord, how do we break the local resistance?",
70 |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
71 |         "FAILURE": "Our systems are failing under the pressure. Warlord, how do we triage this technical collapse?",
   |                                                                                                     ^^^^^^^^^^^^^^^^
72 |         "REFLECTIVE": "A moment of stillness in the slaughter. Warlord, what is your insight on this conquest?"
73 |     }
   |

E501 Line too long (111 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:72:101
   |
70 |         "ELEMENTAL": "The world's raw physics are unstable. Warlord, how do we navigate this atmospheric chaos?",
71 |         "FAILURE": "Our systems are failing under the pressure. Warlord, how do we triage this technical collapse?",
72 |         "REFLECTIVE": "A moment of stillness in the slaughter. Warlord, what is your insight on this conquest?"
   |                                                                                                     ^^^^^^^^^^^
73 |     }
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:75:22
    |
 73 |       }
 74 |
 75 |       PILLAR_OPTIONS = {
    |  ______________________^
 76 | |         "HAZARD": [
 77 | |             {"text": "Reinforce Structural Hardening", "trait": "TYR_BARRIER", "id": "A", "base_difficulty": "Hard"},
 78 | |             {"text": "Divert Power to Life-Support", "trait": "SURTR_FLAME", "id": "B", "base_difficulty": "Normal"},
 79 | |             {"text": "Push Through the Volatility", "trait": "AESIR_MIGHT", "id": "C", "base_difficulty": "Gamble"},
 80 | |             {"text": "Hunker in Cryo-Stasis", "trait": "FAFNIR_SILENCE", "id": "H", "base_difficulty": "Easy"}
 81 | |         ],
 82 | |         "CONFRONTATION": [
 83 | |             {"text": "Launch Kinetic Strike", "trait": "BERSERKER_RAGE", "id": "A", "base_difficulty": "Hard"},
 84 | |             {"text": "Flank through the Ruins", "trait": "VALKYRIE_LUNGE", "id": "B", "base_difficulty": "Normal"},
 85 | |             {"text": "Invoke Dominatrix Synergy", "trait": "LOKI_SHADOW", "id": "C", "base_difficulty": "Gamble"},
 86 | |             {"text": "Suppressing Fire & Extract", "trait": "HEIMDALL_WATCH", "id": "H", "base_difficulty": "Easy"}
 87 | |         ],
 88 | |         "ELEMENTAL": [
 89 | |             {"text": "Anchor to the Deep-Crust", "trait": "YMIR_STONE", "id": "A", "base_difficulty": "Hard"},
 90 | |             {"text": "Bypass via Aerial-Stream", "trait": "SKADI_GLIDE", "id": "B", "base_difficulty": "Normal"},
 91 | |             {"text": "Acknowledge the Storm's Will", "trait": "FREYJA_WEAVE", "id": "C", "base_difficulty": "Gamble"},
 92 | |             {"text": "Shielded Observation", "trait": "HUGINN_SIGHT", "id": "H", "base_difficulty": "Easy"}
 93 | |         ],
 94 | |         "FAILURE": [
 95 | |             {"text": "Overclock Damaged Systems", "trait": "FENRIR_JAW", "id": "A", "base_difficulty": "Hard"},
 96 | |             {"text": "Manual Triage & Repair", "trait": "MIMIR_WELL", "id": "B", "base_difficulty": "Normal"},
 97 | |             {"text": "Purge Compromised Buffers", "trait": "GINNUNGAGAP_VOID", "id": "C", "base_difficulty": "Gamble"},
 98 | |             {"text": "Standard Diagnostic Loop", "trait": "MUNINN_MEM", "id": "D", "base_difficulty": "Easy"}
 99 | |         ],
100 | |         "REFLECTIVE": [
101 | |             {"text": "Discuss the Weight of Conquest", "trait": "BRAGI_SONG", "id": "A", "base_difficulty": "Normal"},
102 | |             {"text": "Share a Ration in Silence", "trait": "IDUNN_BLOOM", "id": "B", "base_difficulty": "Normal"},
103 | |             {"text": "Challenge the Void with Verse", "trait": "BALDR_LIGHT", "id": "C", "base_difficulty": "Gamble"},
104 | |             {"text": "Brief Rest in the Ruinscape", "trait": "ODIN_EYE", "id": "H", "base_difficulty": "Easy"}
105 | |         ]
106 | |     }
    | |_____^
107 |
108 |       PLANET_LORE = {
    |

E501 Line too long (117 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:77:101
   |
75 |     PILLAR_OPTIONS = {
76 |         "HAZARD": [
77 |             {"text": "Reinforce Structural Hardening", "trait": "TYR_BARRIER", "id": "A", "base_difficulty": "Hard"},
   |                                                                                                     ^^^^^^^^^^^^^^^^^
78 |             {"text": "Divert Power to Life-Support", "trait": "SURTR_FLAME", "id": "B", "base_difficulty": "Normal"},
79 |             {"text": "Push Through the Volatility", "trait": "AESIR_MIGHT", "id": "C", "base_difficulty": "Gamble"},
   |

E501 Line too long (117 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:78:101
   |
76 |         "HAZARD": [
77 |             {"text": "Reinforce Structural Hardening", "trait": "TYR_BARRIER", "id": "A", "base_difficulty": "Hard"},
78 |             {"text": "Divert Power to Life-Support", "trait": "SURTR_FLAME", "id": "B", "base_difficulty": "Normal"},
   |                                                                                                     ^^^^^^^^^^^^^^^^^
79 |             {"text": "Push Through the Volatility", "trait": "AESIR_MIGHT", "id": "C", "base_difficulty": "Gamble"},
80 |             {"text": "Hunker in Cryo-Stasis", "trait": "FAFNIR_SILENCE", "id": "H", "base_difficulty": "Easy"}
   |

E501 Line too long (116 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:79:101
   |
77 |             {"text": "Reinforce Structural Hardening", "trait": "TYR_BARRIER", "id": "A", "base_difficulty": "Hard"},
78 |             {"text": "Divert Power to Life-Support", "trait": "SURTR_FLAME", "id": "B", "base_difficulty": "Normal"},
79 |             {"text": "Push Through the Volatility", "trait": "AESIR_MIGHT", "id": "C", "base_difficulty": "Gamble"},
   |                                                                                                     ^^^^^^^^^^^^^^^^
80 |             {"text": "Hunker in Cryo-Stasis", "trait": "FAFNIR_SILENCE", "id": "H", "base_difficulty": "Easy"}
81 |         ],
   |

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:80:101
   |
78 |             {"text": "Divert Power to Life-Support", "trait": "SURTR_FLAME", "id": "B", "base_difficulty": "Normal"},
79 |             {"text": "Push Through the Volatility", "trait": "AESIR_MIGHT", "id": "C", "base_difficulty": "Gamble"},
80 |             {"text": "Hunker in Cryo-Stasis", "trait": "FAFNIR_SILENCE", "id": "H", "base_difficulty": "Easy"}
   |                                                                                                     ^^^^^^^^^^
81 |         ],
82 |         "CONFRONTATION": [
   |

E501 Line too long (111 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:83:101
   |
81 |         ],
82 |         "CONFRONTATION": [
83 |             {"text": "Launch Kinetic Strike", "trait": "BERSERKER_RAGE", "id": "A", "base_difficulty": "Hard"},
   |                                                                                                     ^^^^^^^^^^^
84 |             {"text": "Flank through the Ruins", "trait": "VALKYRIE_LUNGE", "id": "B", "base_difficulty": "Normal"},
85 |             {"text": "Invoke Dominatrix Synergy", "trait": "LOKI_SHADOW", "id": "C", "base_difficulty": "Gamble"},
   |

E501 Line too long (115 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:84:101
   |
82 |         "CONFRONTATION": [
83 |             {"text": "Launch Kinetic Strike", "trait": "BERSERKER_RAGE", "id": "A", "base_difficulty": "Hard"},
84 |             {"text": "Flank through the Ruins", "trait": "VALKYRIE_LUNGE", "id": "B", "base_difficulty": "Normal"},
   |                                                                                                     ^^^^^^^^^^^^^^^
85 |             {"text": "Invoke Dominatrix Synergy", "trait": "LOKI_SHADOW", "id": "C", "base_difficulty": "Gamble"},
86 |             {"text": "Suppressing Fire & Extract", "trait": "HEIMDALL_WATCH", "id": "H", "base_difficulty": "Easy"}
   |

E501 Line too long (114 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:85:101
   |
83 |             {"text": "Launch Kinetic Strike", "trait": "BERSERKER_RAGE", "id": "A", "base_difficulty": "Hard"},
84 |             {"text": "Flank through the Ruins", "trait": "VALKYRIE_LUNGE", "id": "B", "base_difficulty": "Normal"},
85 |             {"text": "Invoke Dominatrix Synergy", "trait": "LOKI_SHADOW", "id": "C", "base_difficulty": "Gamble"},
   |                                                                                                     ^^^^^^^^^^^^^^
86 |             {"text": "Suppressing Fire & Extract", "trait": "HEIMDALL_WATCH", "id": "H", "base_difficulty": "Easy"}
87 |         ],
   |

E501 Line too long (115 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:86:101
   |
84 |             {"text": "Flank through the Ruins", "trait": "VALKYRIE_LUNGE", "id": "B", "base_difficulty": "Normal"},
85 |             {"text": "Invoke Dominatrix Synergy", "trait": "LOKI_SHADOW", "id": "C", "base_difficulty": "Gamble"},
86 |             {"text": "Suppressing Fire & Extract", "trait": "HEIMDALL_WATCH", "id": "H", "base_difficulty": "Easy"}
   |                                                                                                     ^^^^^^^^^^^^^^^
87 |         ],
88 |         "ELEMENTAL": [
   |

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:89:101
   |
87 |         ],
88 |         "ELEMENTAL": [
89 |             {"text": "Anchor to the Deep-Crust", "trait": "YMIR_STONE", "id": "A", "base_difficulty": "Hard"},
   |                                                                                                     ^^^^^^^^^^
90 |             {"text": "Bypass via Aerial-Stream", "trait": "SKADI_GLIDE", "id": "B", "base_difficulty": "Normal"},
91 |             {"text": "Acknowledge the Storm's Will", "trait": "FREYJA_WEAVE", "id": "C", "base_difficulty": "Gamble"},
   |

E501 Line too long (113 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:90:101
   |
88 |         "ELEMENTAL": [
89 |             {"text": "Anchor to the Deep-Crust", "trait": "YMIR_STONE", "id": "A", "base_difficulty": "Hard"},
90 |             {"text": "Bypass via Aerial-Stream", "trait": "SKADI_GLIDE", "id": "B", "base_difficulty": "Normal"},
   |                                                                                                     ^^^^^^^^^^^^^
91 |             {"text": "Acknowledge the Storm's Will", "trait": "FREYJA_WEAVE", "id": "C", "base_difficulty": "Gamble"},
92 |             {"text": "Shielded Observation", "trait": "HUGINN_SIGHT", "id": "H", "base_difficulty": "Easy"}
   |

E501 Line too long (118 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:91:101
   |
89 |             {"text": "Anchor to the Deep-Crust", "trait": "YMIR_STONE", "id": "A", "base_difficulty": "Hard"},
90 |             {"text": "Bypass via Aerial-Stream", "trait": "SKADI_GLIDE", "id": "B", "base_difficulty": "Normal"},
91 |             {"text": "Acknowledge the Storm's Will", "trait": "FREYJA_WEAVE", "id": "C", "base_difficulty": "Gamble"},
   |                                                                                                     ^^^^^^^^^^^^^^^^^^
92 |             {"text": "Shielded Observation", "trait": "HUGINN_SIGHT", "id": "H", "base_difficulty": "Easy"}
93 |         ],
   |

E501 Line too long (107 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:92:101
   |
90 |             {"text": "Bypass via Aerial-Stream", "trait": "SKADI_GLIDE", "id": "B", "base_difficulty": "Normal"},
91 |             {"text": "Acknowledge the Storm's Will", "trait": "FREYJA_WEAVE", "id": "C", "base_difficulty": "Gamble"},
92 |             {"text": "Shielded Observation", "trait": "HUGINN_SIGHT", "id": "H", "base_difficulty": "Easy"}
   |                                                                                                     ^^^^^^^
93 |         ],
94 |         "FAILURE": [
   |

E501 Line too long (111 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:95:101
   |
93 |         ],
94 |         "FAILURE": [
95 |             {"text": "Overclock Damaged Systems", "trait": "FENRIR_JAW", "id": "A", "base_difficulty": "Hard"},
   |                                                                                                     ^^^^^^^^^^^
96 |             {"text": "Manual Triage & Repair", "trait": "MIMIR_WELL", "id": "B", "base_difficulty": "Normal"},
97 |             {"text": "Purge Compromised Buffers", "trait": "GINNUNGAGAP_VOID", "id": "C", "base_difficulty": "Gamble"},
   |

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:96:101
   |
94 |         "FAILURE": [
95 |             {"text": "Overclock Damaged Systems", "trait": "FENRIR_JAW", "id": "A", "base_difficulty": "Hard"},
96 |             {"text": "Manual Triage & Repair", "trait": "MIMIR_WELL", "id": "B", "base_difficulty": "Normal"},
   |                                                                                                     ^^^^^^^^^^
97 |             {"text": "Purge Compromised Buffers", "trait": "GINNUNGAGAP_VOID", "id": "C", "base_difficulty": "Gamble"},
98 |             {"text": "Standard Diagnostic Loop", "trait": "MUNINN_MEM", "id": "D", "base_difficulty": "Easy"}
   |

E501 Line too long (119 > 100)
  --> src\games\odin_protocol\engine\scenarios.py:97:101
   |
95 |             {"text": "Overclock Damaged Systems", "trait": "FENRIR_JAW", "id": "A", "base_difficulty": "Hard"},
96 |             {"text": "Manual Triage & Repair", "trait": "MIMIR_WELL", "id": "B", "base_difficulty": "Normal"},
97 |             {"text": "Purge Compromised Buffers", "trait": "GINNUNGAGAP_VOID", "id": "C", "base_difficulty": "Gamble"},
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^
98 |             {"text": "Standard Diagnostic Loop", "trait": "MUNINN_MEM", "id": "D", "base_difficulty": "Easy"}
99 |         ],
   |

E501 Line too long (109 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:98:101
    |
 96 |             {"text": "Manual Triage & Repair", "trait": "MIMIR_WELL", "id": "B", "base_difficulty": "Normal"},
 97 |             {"text": "Purge Compromised Buffers", "trait": "GINNUNGAGAP_VOID", "id": "C", "base_difficulty": "Gamble"},
 98 |             {"text": "Standard Diagnostic Loop", "trait": "MUNINN_MEM", "id": "D", "base_difficulty": "Easy"}
    |                                                                                                     ^^^^^^^^^
 99 |         ],
100 |         "REFLECTIVE": [
    |

E501 Line too long (118 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:101:101
    |
 99 |         ],
100 |         "REFLECTIVE": [
101 |             {"text": "Discuss the Weight of Conquest", "trait": "BRAGI_SONG", "id": "A", "base_difficulty": "Normal"},
    |                                                                                                     ^^^^^^^^^^^^^^^^^^
102 |             {"text": "Share a Ration in Silence", "trait": "IDUNN_BLOOM", "id": "B", "base_difficulty": "Normal"},
103 |             {"text": "Challenge the Void with Verse", "trait": "BALDR_LIGHT", "id": "C", "base_difficulty": "Gamble"},
    |

E501 Line too long (114 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:102:101
    |
100 |         "REFLECTIVE": [
101 |             {"text": "Discuss the Weight of Conquest", "trait": "BRAGI_SONG", "id": "A", "base_difficulty": "Normal"},
102 |             {"text": "Share a Ration in Silence", "trait": "IDUNN_BLOOM", "id": "B", "base_difficulty": "Normal"},
    |                                                                                                     ^^^^^^^^^^^^^^
103 |             {"text": "Challenge the Void with Verse", "trait": "BALDR_LIGHT", "id": "C", "base_difficulty": "Gamble"},
104 |             {"text": "Brief Rest in the Ruinscape", "trait": "ODIN_EYE", "id": "H", "base_difficulty": "Easy"}
    |

E501 Line too long (118 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:103:101
    |
101 |             {"text": "Discuss the Weight of Conquest", "trait": "BRAGI_SONG", "id": "A", "base_difficulty": "Normal"},
102 |             {"text": "Share a Ration in Silence", "trait": "IDUNN_BLOOM", "id": "B", "base_difficulty": "Normal"},
103 |             {"text": "Challenge the Void with Verse", "trait": "BALDR_LIGHT", "id": "C", "base_difficulty": "Gamble"},
    |                                                                                                     ^^^^^^^^^^^^^^^^^^
104 |             {"text": "Brief Rest in the Ruinscape", "trait": "ODIN_EYE", "id": "H", "base_difficulty": "Easy"}
105 |         ]
    |

E501 Line too long (110 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:104:101
    |
102 |             {"text": "Share a Ration in Silence", "trait": "IDUNN_BLOOM", "id": "B", "base_difficulty": "Normal"},
103 |             {"text": "Challenge the Void with Verse", "trait": "BALDR_LIGHT", "id": "C", "base_difficulty": "Gamble"},
104 |             {"text": "Brief Rest in the Ruinscape", "trait": "ODIN_EYE", "id": "H", "base_difficulty": "Easy"}
    |                                                                                                     ^^^^^^^^^^
105 |         ]
106 |     }
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:108:19
    |
106 |       }
107 |
108 |       PLANET_LORE = {
    |  ___________________^
109 | |         "Muspelheim": "A primordial furnace world where the core is exposed, necessitates a kinetic siege to reclaim the lost Bio-Seeâ€¦
110 | |         "Asgard": "The ancestral seat of the genetic elite, currently undergoing a temporal fracture that threatens to erase the Hugiâ€¦
111 | |         "Niflheim": "A frozen hell of cryo-obsidian where the local hive-minds have retreated into the deep crust, resisting subjugatâ€¦
112 | |         "Hel": "A world of eternal decay where the bio-hazard levels have reached a critical state, threatening to liquefy any genomeâ€¦
113 | |         "Solitude": "An isolated moon of crystalline silence. The planetary goal is obscured by electromagnetic isolation, requiring â€¦
114 | |         "Yggdrasil": "A lush, bio-synthetic forest world where the flora is sentient and connected. Every action here ripples throughâ€¦
115 | |         "Fensalir": "A world of endless ocean-mist and bioluminescent reefs. The local civilizations thrive in the deep-pressure zoneâ€¦
116 | |         "Vanaheim": "A chaotic, fast-evolving biosphere where the fauna undergoes rapid mutation every solar cycle, forcing constant â€¦
117 | |     }
    | |_____^
118 |
119 |       # Persona Engine Data
    |

E501 Line too long (160 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:109:101
    |
108 | â€¦
109 | â€¦ is exposed, necessitates a kinetic siege to reclaim the lost Bio-Seeds from the shifting ash.",
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
110 | â€¦ently undergoing a temporal fracture that threatens to erase the Hugin/Munin memory banks.",
111 | â€¦cal hive-minds have retreated into the deep crust, resisting subjugation through absolute thermal silence.",
    |

E501 Line too long (156 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:110:101
    |
108 | â€¦
109 | â€¦re is exposed, necessitates a kinetic siege to reclaim the lost Bio-Seeds from the shifting ash.",
110 | â€¦rrently undergoing a temporal fracture that threatens to erase the Hugin/Munin memory banks.",
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 | â€¦local hive-minds have retreated into the deep crust, resisting subjugation through absolute thermal silence.",
112 | â€¦levels have reached a critical state, threatening to liquefy any genome that lacks the Hela-Synergy.",
    |

E501 Line too long (172 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:111:101
    |
109 | â€¦posed, necessitates a kinetic siege to reclaim the lost Bio-Seeds from the shifting ash.",
110 | â€¦undergoing a temporal fracture that threatens to erase the Hugin/Munin memory banks.",
111 | â€¦ve-minds have retreated into the deep crust, resisting subjugation through absolute thermal silence.",
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 | â€¦ave reached a critical state, threatening to liquefy any genome that lacks the Hela-Synergy.",
113 | â€¦etary goal is obscured by electromagnetic isolation, requiring a surgical strike to extract data.",
    |

E501 Line too long (164 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:112:101
    |
110 | â€¦tly undergoing a temporal fracture that threatens to erase the Hugin/Munin memory banks.",
111 | â€¦l hive-minds have retreated into the deep crust, resisting subjugation through absolute thermal silence.",
112 | â€¦ls have reached a critical state, threatening to liquefy any genome that lacks the Hela-Synergy.",
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 | â€¦planetary goal is obscured by electromagnetic isolation, requiring a surgical strike to extract data.",
114 | â€¦ flora is sentient and connected. Every action here ripples through the global neural network.",
    |

E501 Line too long (169 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:113:101
    |
111 | â€¦ive-minds have retreated into the deep crust, resisting subjugation through absolute thermal silence.",
112 | â€¦have reached a critical state, threatening to liquefy any genome that lacks the Hela-Synergy.",
113 | â€¦netary goal is obscured by electromagnetic isolation, requiring a surgical strike to extract data.",
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 | â€¦ora is sentient and connected. Every action here ripples through the global neural network.",
115 | â€¦ reefs. The local civilizations thrive in the deep-pressure zones, guarding their genetic hoards.",
    |

E501 Line too long (162 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:114:101
    |
112 | â€¦els have reached a critical state, threatening to liquefy any genome that lacks the Hela-Synergy.",
113 | â€¦ planetary goal is obscured by electromagnetic isolation, requiring a surgical strike to extract data.",
114 | â€¦e flora is sentient and connected. Every action here ripples through the global neural network.",
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 | â€¦cent reefs. The local civilizations thrive in the deep-pressure zones, guarding their genetic hoards.",
116 | â€¦ fauna undergoes rapid mutation every solar cycle, forcing constant tactical adaptation."
    |

E501 Line too long (168 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:115:101
    |
113 | â€¦anetary goal is obscured by electromagnetic isolation, requiring a surgical strike to extract data.",
114 | â€¦lora is sentient and connected. Every action here ripples through the global neural network.",
115 | â€¦t reefs. The local civilizations thrive in the deep-pressure zones, guarding their genetic hoards.",
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
116 | â€¦una undergoes rapid mutation every solar cycle, forcing constant tactical adaptation."
117 | â€¦
    |

E501 Line too long (154 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:116:101
    |
114 | â€¦e the flora is sentient and connected. Every action here ripples through the global neural network.",
115 | â€¦inescent reefs. The local civilizations thrive in the deep-pressure zones, guarding their genetic hoards.",
116 | â€¦ the fauna undergoes rapid mutation every solar cycle, forcing constant tactical adaptation."
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 | â€¦
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:120:13
    |
119 |     # Persona Engine Data
120 |     RANKS = ["Sergeant", "Corporal", "Lieutenant", "Specialist", "Elder", "Civ-Lead"]
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 |     NAMES = ["Varick", "Kael", "Thorne", "Vahl", "Zora", "Hera", "Mimir", "Surt"]
122 |     TRAITS = ["Grim", "Loyal", "Calculated", "Fearful", "Resilient", "Defiant"]
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:121:13
    |
119 |     # Persona Engine Data
120 |     RANKS = ["Sergeant", "Corporal", "Lieutenant", "Specialist", "Elder", "Civ-Lead"]
121 |     NAMES = ["Varick", "Kael", "Thorne", "Vahl", "Zora", "Hera", "Mimir", "Surt"]
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |     TRAITS = ["Grim", "Loyal", "Calculated", "Fearful", "Resilient", "Defiant"]
123 |     ROLES = ["Vanguard", "Bio-Tech", "Scout", "Civilian", "Resistance"]
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:122:14
    |
120 |     RANKS = ["Sergeant", "Corporal", "Lieutenant", "Specialist", "Elder", "Civ-Lead"]
121 |     NAMES = ["Varick", "Kael", "Thorne", "Vahl", "Zora", "Hera", "Mimir", "Surt"]
122 |     TRAITS = ["Grim", "Loyal", "Calculated", "Fearful", "Resilient", "Defiant"]
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |     ROLES = ["Vanguard", "Bio-Tech", "Scout", "Civilian", "Resistance"]
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:123:13
    |
121 |     NAMES = ["Varick", "Kael", "Thorne", "Vahl", "Zora", "Hera", "Mimir", "Surt"]
122 |     TRAITS = ["Grim", "Loyal", "Calculated", "Fearful", "Resilient", "Defiant"]
123 |     ROLES = ["Vanguard", "Bio-Tech", "Scout", "Civilian", "Resistance"]
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |
125 |     CAMPAIGN_OBJECTIVES = [
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:125:27
    |
123 |       ROLES = ["Vanguard", "Bio-Tech", "Scout", "Civilian", "Resistance"]
124 |
125 |       CAMPAIGN_OBJECTIVES = [
    |  ___________________________^
126 | |         "Establish Forward Hive-Base",
127 | |         "Subjugate Local Militia",
128 | |         "Secure Food & Provisions",
129 | |         "Breach Deep-Crust Vaults",
130 | |         "Inoculate World-Core",
131 | |         "Suppress Neural Resistance"
132 | |     ]
    | |_____^
133 |
134 |       RESOLUTION_FLAVOR = {
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> src\games\odin_protocol\engine\scenarios.py:134:25
    |
132 |       ]
133 |
134 |       RESOLUTION_FLAVOR = {
    |  _________________________^
135 | |         0: { # Atmosphere fog
136 | |             "Hard": "force the sensor array through the static screams to pin a landing",
137 | |             "Normal": "filter the electromagnetic discharge via manual triangulation",
138 | |             "Gamble": "commune with the static screams to find a freak path through the fog",
139 | |             "Easy": "deploy localized dampeners to quiet the atmospheric roar"
140 | |         },
141 | |         1: { # Gravity storms
142 | |             "Hard": "overclock gravity anchors and plunge into the storm's eye",
143 | |             "Normal": "compensate for structural liquefaction with emergency shunting",
144 | |             "Gamble": "surf the gravity waves to slingshot past the lethal zone",
145 | |             "Easy": "calculate stable Lagrange points to drift through the turbulence"
146 | |         },
147 | |         2: { # Sentient flora
148 | |             "Hard": "crash through the pulsating mesh using brute-force kinetic overrides",
149 | |             "Normal": "manually prune the sentient vines blocking the entry conduits",
150 | |             "Gamble": "induce a localized necrosis to wither the flora's neural center",
151 | |             "Easy": "modify ship resonance to match the flora and sneak through undetected"
152 | |         },
153 | |         3: { # Temporal anomaly
154 | |             "Hard": "shatter the tactical echoes by venting raw, chaotic chronons",
155 | |             "Normal": "calibrate localized time-locks to stabilize the deck chronology",
156 | |             "Gamble": "exploit a tactical recursion to manifest multiple landing attempts",
157 | |             "Easy": "anchor the timeline to a fixed memory of the mission's goal"
158 | |         },
159 | |         4: { # Tectonic volatility
160 | |             "Hard": "burn the engines to white-heat and blast through the rising crust",
161 | |             "Normal": "re-route power to localized stabilizers to hold the landing zone",
162 | |             "Gamble": "detonate seismic charges to force the tectonic plates into a temporary lock",
163 | |             "Easy": "glide across the shifting plates using active terrain-mapping"
164 | |         },
165 | |         5: { # Core radiation
166 | |             "Hard": "reinforce physical shielding with depleted hulls and push through the heat",
167 | |             "Normal": "modulate the energy-grid to deflect the incoming radiation",
168 | |             "Gamble": "absorb the core radiation to supercharge the kinetic thrusters",
169 | |             "Easy": "deploy leaden-mesh clouds to mask the ship from the world-core"
170 | |         }
171 | |     }
    | |_____^
172 |
173 |       def generate_scenario(self, stats: dict[str, float], seed: str = "C*DEFAULT", turn_id: int = 0, player_name: str = "O.D.I.N.", campaiâ€¦
    |

E501 Line too long (196 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:173:101
    |
171 | â€¦
172 | â€¦
173 | â€¦turn_id: int = 0, player_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
174 | â€¦tep."""
175 | â€¦_data, node_type)
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\scenarios.py:173:143
    |
171 | â€¦
172 | â€¦
173 | â€¦T", turn_id: int = 0, player_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                                                                  ^^^^
174 | â€¦gn Step."""
175 | â€¦aign_data, node_type)
    |
help: Convert to `T | None`

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\scenarios.py:173:167
    |
171 | â€¦
172 | â€¦
173 | â€¦ayer_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                                                                  ^^^
174 | â€¦
175 | â€¦
    |
help: Convert to `T | None`

ANN201 Missing return type annotation for public function `generate`
   --> src\games\odin_protocol\engine\scenarios.py:177:9
    |
175 |         return self._generate_internal(stats, seed, turn_id, player_name, campaign_data, node_type)
176 |
177 |     def generate(self, *args, **kwargs):
    |         ^^^^^^^^
178 |         """Test compatibility alias."""
179 |         return self.generate_scenario(*args, **kwargs)
    |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
   --> src\games\odin_protocol\engine\scenarios.py:177:24
    |
175 |         return self._generate_internal(stats, seed, turn_id, player_name, campaign_data, node_type)
176 |
177 |     def generate(self, *args, **kwargs):
    |                        ^^^^^
178 |         """Test compatibility alias."""
179 |         return self.generate_scenario(*args, **kwargs)
    |

ANN003 Missing type annotation for `**kwargs`
   --> src\games\odin_protocol\engine\scenarios.py:177:31
    |
175 |         return self._generate_internal(stats, seed, turn_id, player_name, campaign_data, node_type)
176 |
177 |     def generate(self, *args, **kwargs):
    |                               ^^^^^^^^
178 |         """Test compatibility alias."""
179 |         return self.generate_scenario(*args, **kwargs)
    |

E501 Line too long (197 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:181:101
    |
179 | â€¦
180 | â€¦
181 | â€¦turn_id: int = 0, player_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
182 | â€¦
183 | â€¦
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\scenarios.py:181:144
    |
179 | â€¦
180 | â€¦
181 | â€¦T", turn_id: int = 0, player_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                                                                  ^^^^
182 | â€¦
183 | â€¦
    |
help: Convert to `T | None`

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\scenarios.py:181:168
    |
179 | â€¦
180 | â€¦
181 | â€¦ayer_name: str = "O.D.I.N.", campaign_data: dict = None, node_type: str = None) -> dict[str, Any]:
    |                                                                  ^^^
182 | â€¦
183 | â€¦
    |
help: Convert to `T | None`

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   --> src\games\odin_protocol\engine\scenarios.py:184:21
    |
182 |         world_id_str = f"{seed}_{turn_id}"
183 |         seed_hash = hashlib.sha256(world_id_str.encode()).hexdigest()
184 |         local_rng = random.Random(seed_hash)
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^
185 |
186 |         # 1. Campaign Context Retrieval
    |

E501 Line too long (101 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:196:101
    |
194 |             planet_name = f"SIEGE OF {planet_base_name.upper()}"
195 |
196 |         campaign = self._get_or_create_campaign(planet_name, planet_suffix, local_rng, campaign_data)
    |                                                                                                     ^
197 |
198 |         # 2. WorldForge Attributes (Persistent)
    |

E501 Line too long (107 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:216:101
    |
214 |                 "type": "INVERSION",
215 |                 "target": target_chromo,
216 |                 "description": f"The {env_name} anomalous. {target_chromo} interferences act as Synergies."
    |                                                                                                     ^^^^^^^
217 |             })
    |

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:238:101
    |
236 |             conflict = f"the ship's structural supports are liquefying under {conflict.lower()}"
237 |         elif pillar == "REFLECTIVE":
238 |             conflict = f"{persona_str} whispers about {conflict.lower()} through the ruinscape silence"
    |                                                                                                     ^^^
239 |         elif pillar == "FAILURE":
240 |             conflict = f"critical gear failure manifests as {conflict.lower()}"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:261:35
    |
259 |             # Threshold Calculation (Kingdom Death Scaling)
260 |             threshold = combat_rating
261 |             if base_diff == "Hard": threshold += 5.0
    |                                   ^
262 |             elif base_diff == "Gamble": threshold += 10.0
263 |             elif base_diff == "Normal": threshold += 1.0
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:262:39
    |
260 |             threshold = combat_rating
261 |             if base_diff == "Hard": threshold += 5.0
262 |             elif base_diff == "Gamble": threshold += 10.0
    |                                       ^
263 |             elif base_diff == "Normal": threshold += 1.0
264 |             elif base_diff == "Easy": threshold -= 2.0
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:263:39
    |
261 |             if base_diff == "Hard": threshold += 5.0
262 |             elif base_diff == "Gamble": threshold += 10.0
263 |             elif base_diff == "Normal": threshold += 1.0
    |                                       ^
264 |             elif base_diff == "Easy": threshold -= 2.0
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:264:37
    |
262 |             elif base_diff == "Gamble": threshold += 10.0
263 |             elif base_diff == "Normal": threshold += 1.0
264 |             elif base_diff == "Easy": threshold -= 2.0
    |                                     ^
265 |
266 |             # Brutal Modifier
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:273:41
    |
271 |             eff_stat = stats.get(trait, 10.0)
272 |
273 |             if eff_stat > threshold + 10: diff_label = "Trivial"
    |                                         ^
274 |             elif eff_stat > threshold + 3: diff_label = "Easy"
275 |             elif eff_stat < threshold - 15: diff_label = "Lethal" # Higher lethal cap in brutal
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:274:42
    |
273 |             if eff_stat > threshold + 10: diff_label = "Trivial"
274 |             elif eff_stat > threshold + 3: diff_label = "Easy"
    |                                          ^
275 |             elif eff_stat < threshold - 15: diff_label = "Lethal" # Higher lethal cap in brutal
276 |             elif eff_stat < threshold - 5: diff_label = "Hard"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:275:43
    |
273 |             if eff_stat > threshold + 10: diff_label = "Trivial"
274 |             elif eff_stat > threshold + 3: diff_label = "Easy"
275 |             elif eff_stat < threshold - 15: diff_label = "Lethal" # Higher lethal cap in brutal
    |                                           ^
276 |             elif eff_stat < threshold - 5: diff_label = "Hard"
277 |             else: diff_label = "Normal"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:276:42
    |
274 |             elif eff_stat > threshold + 3: diff_label = "Easy"
275 |             elif eff_stat < threshold - 15: diff_label = "Lethal" # Higher lethal cap in brutal
276 |             elif eff_stat < threshold - 5: diff_label = "Hard"
    |                                          ^
277 |             else: diff_label = "Normal"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:277:17
    |
275 |             elif eff_stat < threshold - 15: diff_label = "Lethal" # Higher lethal cap in brutal
276 |             elif eff_stat < threshold - 5: diff_label = "Hard"
277 |             else: diff_label = "Normal"
    |                 ^
278 |
279 |             options.append({
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:321:21
    |
319 |     def _calculate_affinity(self, stats: dict[str, float], world_attrs: dict) -> float:
320 |         """Calculates Warlord-to-Planet affinity (log-scaled background growth)."""
321 |         if not stats: return 1.0
    |                     ^
322 |
323 |         # Simple mapping for Phase 9 demo:
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\engine\scenarios.py:341:100
    |
339 |         return round(math.log10(max(1.1, affinity)) * 0.5, 3)
340 |
341 |     def _get_or_create_campaign(self, planet_name: str, suffix: str, rng: random.Random, existing: dict = None) -> dict:
    |                                                                                                    ^^^^
342 |         """Helper to maintain campaign state or initialize a fresh one."""
343 |         if existing:
    |
help: Convert to `T | None`

E501 Line too long (120 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:341:101
    |
339 |         return round(math.log10(max(1.1, affinity)) * 0.5, 3)
340 |
341 |     def _get_or_create_campaign(self, planet_name: str, suffix: str, rng: random.Random, existing: dict = None) -> dict:
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^
342 |         """Helper to maintain campaign state or initialize a fresh one."""
343 |         if existing:
    |

ANN202 Missing return type annotation for private function `get_world_att`
   --> src\games\odin_protocol\engine\scenarios.py:346:21
    |
344 |             # Migration/Persistence Fix: Ensure attributes exist
345 |             if 'attributes' not in existing:
346 |                 def get_world_att(): return rng.random()
    |                     ^^^^^^^^^^^^^
347 |                 f_v, fl_v, s_v, c_v = get_world_att(), get_world_att(), get_world_att(), get_world_att()
    |
help: Add return type annotation

E501 Line too long (104 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:347:101
    |
345 |             if 'attributes' not in existing:
346 |                 def get_world_att(): return rng.random()
347 |                 f_v, fl_v, s_v, c_v = get_world_att(), get_world_att(), get_world_att(), get_world_att()
    |                                                                                                     ^^^^
348 |
349 |                 # Bias based on suffix if available, otherwise use provided suffix
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:351:38
    |
349 |                 # Bias based on suffix if available, otherwise use provided suffix
350 |                 sfx = existing.get('planet_suffix', suffix)
351 |                 if sfx == "Yggdrasil": fl_v = 0.9
    |                                      ^
352 |                 elif sfx == "Asgard": c_v = 0.9
353 |                 elif sfx == "Niflheim": s_v = 0.9
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:352:37
    |
350 |                 sfx = existing.get('planet_suffix', suffix)
351 |                 if sfx == "Yggdrasil": fl_v = 0.9
352 |                 elif sfx == "Asgard": c_v = 0.9
    |                                     ^
353 |                 elif sfx == "Niflheim": s_v = 0.9
354 |                 elif sfx == "Muspelheim": s_v = 0.2
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:353:39
    |
351 |                 if sfx == "Yggdrasil": fl_v = 0.9
352 |                 elif sfx == "Asgard": c_v = 0.9
353 |                 elif sfx == "Niflheim": s_v = 0.9
    |                                       ^
354 |                 elif sfx == "Muspelheim": s_v = 0.2
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:354:41
    |
352 |                 elif sfx == "Asgard": c_v = 0.9
353 |                 elif sfx == "Niflheim": s_v = 0.9
354 |                 elif sfx == "Muspelheim": s_v = 0.2
    |                                         ^
355 |
356 |                 fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
    |

E501 Line too long (111 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:356:101
    |
354 |                 elif sfx == "Muspelheim": s_v = 0.2
355 |
356 |                 fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
    |                                                                                                     ^^^^^^^^^^^
357 |                 flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
358 |                 sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
    |

E501 Line too long (108 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:357:101
    |
356 |                 fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
357 |                 flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
    |                                                                                                     ^^^^^^^^
358 |                 sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
359 |                 civ_type = "Ascended Neural Nets" if c_v > 0.7 else ("Industrial Bastions" if c_v > 0.3 else "Primitive Hives")
    |

E501 Line too long (113 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:358:101
    |
356 |                 fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
357 |                 flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
358 |                 sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
    |                                                                                                     ^^^^^^^^^^^^^
359 |                 civ_type = "Ascended Neural Nets" if c_v > 0.7 else ("Industrial Bastions" if c_v > 0.3 else "Primitive Hives")
    |

E501 Line too long (127 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:359:101
    |
357 |                 flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
358 |                 sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
359 |                 civ_type = "Ascended Neural Nets" if c_v > 0.7 else ("Industrial Bastions" if c_v > 0.3 else "Primitive Hives")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
360 |
361 |                 existing['attributes'] = {
    |

ANN202 Missing return type annotation for private function `get_world_att`
   --> src\games\odin_protocol\engine\scenarios.py:379:13
    |
378 |         # WorldForge Attributes (Seeded once per planet)
379 |         def get_world_att(): return rng.random()
    |             ^^^^^^^^^^^^^
380 |         f_v, fl_v, s_v, c_v = get_world_att(), get_world_att(), get_world_att(), get_world_att()
    |
help: Add return type annotation

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:383:33
    |
382 |         # Biasing based on suffix
383 |         if suffix == "Yggdrasil": fl_v = 0.9  # Lush
    |                                 ^
384 |         elif suffix == "Asgard": c_v = 0.9   # Ascended
385 |         elif suffix == "Niflheim": s_v = 0.9 # Obsidian
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:384:32
    |
382 |         # Biasing based on suffix
383 |         if suffix == "Yggdrasil": fl_v = 0.9  # Lush
384 |         elif suffix == "Asgard": c_v = 0.9   # Ascended
    |                                ^
385 |         elif suffix == "Niflheim": s_v = 0.9 # Obsidian
386 |         elif suffix == "Muspelheim": s_v = 0.2 # Ash
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:385:34
    |
383 |         if suffix == "Yggdrasil": fl_v = 0.9  # Lush
384 |         elif suffix == "Asgard": c_v = 0.9   # Ascended
385 |         elif suffix == "Niflheim": s_v = 0.9 # Obsidian
    |                                  ^
386 |         elif suffix == "Muspelheim": s_v = 0.2 # Ash
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:386:36
    |
384 |         elif suffix == "Asgard": c_v = 0.9   # Ascended
385 |         elif suffix == "Niflheim": s_v = 0.9 # Obsidian
386 |         elif suffix == "Muspelheim": s_v = 0.2 # Ash
    |                                    ^
387 |
388 |         fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
    |

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:388:101
    |
386 |         elif suffix == "Muspelheim": s_v = 0.2 # Ash
387 |
388 |         fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
    |                                                                                                     ^^^
389 |         flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
390 |         sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
    |

E501 Line too long (105 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:390:101
    |
388 |         fauna = "Apex Predators" if f_v > 0.7 else ("Docile Grazers" if f_v < 0.3 else "Nomadic Packs")
389 |         flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
390 |         sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
    |                                                                                                     ^^^^^
391 |         civ_type = "Ascended Neural Nets" if c_v > 0.7 else ("Industrial Bastions" if c_v > 0.3 else "Primitive Hives")
    |

E501 Line too long (119 > 100)
   --> src\games\odin_protocol\engine\scenarios.py:391:101
    |
389 |         flora = "Glow-Forests" if fl_v > 0.7 else ("Dead Scrub" if fl_v < 0.3 else "Adaptive Fungi")
390 |         sediment = "Explosive Crust" if s_v > 0.7 else ("Solid Obsidian" if s_v < 0.3 else "Sifting Ash")
391 |         civ_type = "Ascended Neural Nets" if c_v > 0.7 else ("Industrial Bastions" if c_v > 0.3 else "Primitive Hives")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^
392 |
393 |         return {
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\engine\scenarios.py:410:36
    |
409 |     def _generate_item(self, chromo_id: str, local_rng: random.Random) -> dict[str, Any] | None:
410 |         if local_rng.random() > 0.6: return None
    |                                    ^
411 |         return {
412 |             "id": f"ITEM_{chromo_id}",
    |

I001 [*] Import block is un-sorted or un-formatted
 --> src\games\odin_protocol\main.py:1:1
  |
1 | / import os
2 | | import sys
3 | | import json
4 | | import time
5 | | import random
6 | | import subprocess
7 | | from pathlib import Path
  | |________________________^
8 |
9 |   # Fix: Ensure subprocess/random are available for CI
  |
help: Organize imports

F401 [*] `pathlib.Path` imported but unused
 --> src\games\odin_protocol\main.py:7:21
  |
5 | import random
6 | import subprocess
7 | from pathlib import Path
  |                     ^^^^
8 |
9 | # Fix: Ensure subprocess/random are available for CI
  |
help: Remove unused import: `pathlib.Path`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\games\odin_protocol\main.py:11:17
   |
 9 | # Fix: Ensure subprocess/random are available for CI
10 | # Add project root to path for local imports
11 | sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
   |                 ^^^^^^^^^^^^^^^
12 |
13 | from odin_protocol.engine import (
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\main.py:11:33
   |
 9 | # Fix: Ensure subprocess/random are available for CI
10 | # Add project root to path for local imports
11 | sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
   |                                 ^^^^^^^^^^^^
12 |
13 | from odin_protocol.engine import (
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\games\odin_protocol\main.py:11:46
   |
 9 | # Fix: Ensure subprocess/random are available for CI
10 | # Add project root to path for local imports
11 | sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
   |                                              ^^^^^^^^^^^^^^^
12 |
13 | from odin_protocol.engine import (
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\main.py:26:13
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |             ^^^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\games\odin_protocol\main.py:26:26
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |                          ^^^^^^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\games\odin_protocol\main.py:26:42
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |                                          ^^^^^^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\games\odin_protocol\main.py:26:58
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |                                                          ^^^^^^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\games\odin_protocol\main.py:26:74
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |                                                                          ^^^^^^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |
help: Replace with `Path(...).resolve()`

E501 Line too long (110 > 100)
  --> src\games\odin_protocol\main.py:26:101
   |
25 | # [ALFRED] Importing the Corvus Star UI Backbone
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
   |                                                                                                     ^^^^^^^^^^
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   |

E402 Module level import not at top of file
  --> src\games\odin_protocol\main.py:28:1
   |
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
29 |
30 | class OdinAdventure:
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\games\odin_protocol\main.py:28:1
   |
26 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "core")
27 | sys.path.insert(0, _core_dir)
28 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
29 |
30 | class OdinAdventure:
   |
help: Organize imports

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\games\odin_protocol\main.py:40:23
   |
39 |         # UI Setup
40 |         config_path = os.path.join(project_root, "config.json")
   |                       ^^^^^^^^^^^^
41 |         default_persona = "ALFRED"
42 |         if os.path.exists(config_path):
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\games\odin_protocol\main.py:42:12
   |
40 |         config_path = os.path.join(project_root, "config.json")
41 |         default_persona = "ALFRED"
42 |         if os.path.exists(config_path):
   |            ^^^^^^^^^^^^^^
43 |             with open(config_path) as f:
44 |                 config = json.load(f)
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\games\odin_protocol\main.py:43:18
   |
41 |         default_persona = "ALFRED"
42 |         if os.path.exists(config_path):
43 |             with open(config_path) as f:
   |                  ^^^^
44 |                 config = json.load(f)
45 |                 default_persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |
help: Replace with `Path.open()`

E501 Line too long (102 > 100)
  --> src\games\odin_protocol\main.py:45:101
   |
43 |             with open(config_path) as f:
44 |                 config = json.load(f)
45 |                 default_persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |                                                                                                     ^^
46 |
47 |         HUD.PERSONA = self.state.active_persona or default_persona
   |

S605 Starting a process with a shell, possible injection detected
  --> src\games\odin_protocol\main.py:55:9
   |
53 |     def prompt_for_name(self) -> None:
54 |         """Asks the user for their Warlord name."""
55 |         os.system('cls' if os.name == 'nt' else 'clear')
   |         ^^^^^^^^^
56 |         HUD.divider("NAME YOUR WARLORD")
57 |         print(f"\n{HUD.BOLD}The annals of Corvus await your legend.{HUD.RESET}")
   |

E501 Line too long (118 > 100)
  --> src\games\odin_protocol\main.py:84:101
   |
82 |                 current_planet_name=saved.get("current_planet_name"),
83 |                 current_planet_progress=saved.get("current_planet_progress", 0.0),
84 |                 nodal_progress=saved.get("nodal_progress", {"HIVE": 0.0, "SIEGE": 0.0, "RESOURCE": 0.0, "DROP": 0.0}),
   |                                                                                                     ^^^^^^^^^^^^^^^^^^
85 |                 ticker_velocity=saved.get("ticker_velocity", 0.0),
86 |                 momentum_turns=saved.get("momentum_turns", 0),
   |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\main.py:106:41
    |
104 |         return UniverseState(seed=seed, inventory=dna)
105 |
106 |     def render_manifest(self, scenario: dict = None) -> None:
    |                                         ^^^^
107 |         """Displays the player's genetic stats and empire status (Retro-Battle Grid style)."""
108 |         # Pass world modifiers to stats calculation if available
    |
help: Convert to `T | None`

E501 Line too long (112 > 100)
   --> src\games\odin_protocol\main.py:110:101
    |
108 |         # Pass world modifiers to stats calculation if available
109 |         modifiers = scenario.get("world_modifiers", []) if scenario else []
110 |         effective = calculate_effective_stats(self.state.inventory, self.state.items, world_modifiers=modifiers)
    |                                                                                                     ^^^^^^^^^^^^
111 |         rating = get_combat_rating(effective)
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:114:9
    |
113 |         # War Room Proposal: Retro-Battle Grid
114 |         os.system('cls' if os.name == 'nt' else 'clear')
    |         ^^^^^^^^^
115 |         print(f"{HUD.GREEN}[ WAR_ROOM - PLANETARY GRID ]-------------------[ v2.0.44 ]{HUD.RESET}")
116 |         print("-----------------------------------------------------------")
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:133:76
    |
131 |             for col in range(6):
132 |                 char = " "
133 |                 if row == 2 and col == 2 and self.state.current_planet_name: char = "!"
    |                                                                            ^
134 |                 if row == 1 and col == 1: char = "X"
135 |                 if row == 3 and col == 0: char = "#"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:134:41
    |
132 |                 char = " "
133 |                 if row == 2 and col == 2 and self.state.current_planet_name: char = "!"
134 |                 if row == 1 and col == 1: char = "X"
    |                                         ^
135 |                 if row == 3 and col == 0: char = "#"
136 |                 if row == 4 and col == 3: char = "O"
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:135:41
    |
133 |                 if row == 2 and col == 2 and self.state.current_planet_name: char = "!"
134 |                 if row == 1 and col == 1: char = "X"
135 |                 if row == 3 and col == 0: char = "#"
    |                                         ^
136 |                 if row == 4 and col == 3: char = "O"
137 |                 row_str += f"[{HUD.CYAN}{char}{HUD.RESET}]  "
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:136:41
    |
134 |                 if row == 1 and col == 1: char = "X"
135 |                 if row == 3 and col == 0: char = "#"
136 |                 if row == 4 and col == 3: char = "O"
    |                                         ^
137 |                 row_str += f"[{HUD.CYAN}{char}{HUD.RESET}]  "
    |

E501 Line too long (107 > 100)
   --> src\games\odin_protocol\main.py:160:101
    |
159 |         if self.state.current_planet_name:
160 |             print(f" SIEGE TARGET         : {HUD.CYAN}{self.state.current_planet_name.upper()}{HUD.RESET}")
    |                                                                                                     ^^^^^^^
161 |             print(f" DOMINATION %         : {HUD.GREEN}{self.state.current_planet_progress:.1f}%{HUD.RESET}")
    |

E501 Line too long (109 > 100)
   --> src\games\odin_protocol\main.py:161:101
    |
159 |         if self.state.current_planet_name:
160 |             print(f" SIEGE TARGET         : {HUD.CYAN}{self.state.current_planet_name.upper()}{HUD.RESET}")
161 |             print(f" DOMINATION %         : {HUD.GREEN}{self.state.current_planet_progress:.1f}%{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^
162 |
163 |         # Phase 9: Nodal Coverage
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\games\odin_protocol\main.py:171:34
    |
169 |         print("-----------------------------------------------------------")
170 |
171 |     def briefing(self, scenario: dict = None) -> None:
    |                                  ^^^^
172 |         """Strategic Briefing (Tone shifts based on Persona)."""
173 |         turn = self.state.total_worlds_conquered + int(self.state.domination_percent)
    |
help: Convert to `T | None`

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\main.py:179:101
    |
177 |             remaining = (self.state.last_briefing_turn + cooldown) - turn
178 |             p_name = HUD.PERSONA
179 |             msg = "Re-calibrating void-optics" if p_name == "ALFRED" else "Focusing the All-Seeing Eye"
    |                                                                                                     ^^^
180 |             print(f"\n{HUD.YELLOW}[{p_name}]: {msg}. Wait {remaining} turns.{HUD.RESET}")
181 |             time.sleep(1)
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:184:9
    |
182 |             return
183 |
184 |         os.system('cls' if os.name == 'nt' else 'clear')
    |         ^^^^^^^^^
185 |
186 |         # UI Header shifts by Persona
    |

E501 Line too long (107 > 100)
   --> src\games\odin_protocol\main.py:190:101
    |
188 |         color = HUD.CYAN if HUD.PERSONA == "ALFRED" else HUD.MAGENTA
189 |
190 |         print(f"{HUD.BOLD}{color}{header} seed: {self.state.seed} | --------------------------{HUD.RESET}")
    |                                                                                                     ^^^^^^^
191 |         print(f"\n  STATUS: Strategic Briefing for Warlord {self.state.player_name}")
    |

E501 Line too long (111 > 100)
   --> src\games\odin_protocol\main.py:196:101
    |
194 |             lore_tag = "LORE  " if HUD.PERSONA == "ALFRED" else "MYTHOS"
195 |             print(f"  {lore_tag}: {scenario.get('lore', 'Searching the annals...')}")
196 |             print(f"  THREAT: {HUD.RED}{scenario.get('failure_penalty', 5.0)}/20 (Volatility Risk){HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^
197 |
198 |         print(f"\n  {HUD.BOLD}:: GENE_STREAM ------------------------------------------{HUD.RESET}")
    |

E501 Line too long (112 > 100)
   --> src\games\odin_protocol\main.py:202:101
    |
200 |         # Recalculate with modifiers
201 |         modifiers = scenario.get("world_modifiers", []) if scenario else []
202 |         effective = calculate_effective_stats(self.state.inventory, self.state.items, world_modifiers=modifiers)
    |                                                                                                     ^^^^^^^^^^^^
203 |
204 |         sorted_dna = sorted(self.state.inventory.items(), key=lambda x: effective[x[0]], reverse=True)
    |

E501 Line too long (102 > 100)
   --> src\games\odin_protocol\main.py:204:101
    |
202 |         effective = calculate_effective_stats(self.state.inventory, self.state.items, world_modifiers=modifiers)
203 |
204 |         sorted_dna = sorted(self.state.inventory.items(), key=lambda x: effective[x[0]], reverse=True)
    |                                                                                                     ^^
205 |         for cid, chromosome in sorted_dna[:5]:
206 |             eff = effective[cid]
    |

E501 Line too long (155 > 100)
   --> src\games\odin_protocol\main.py:213:101
    |
211 | â€¦
212 | â€¦
213 | â€¦ent', 'ground')} seems stable, but the {scenario.get('fauna', 'creatures')} are restless.\"")
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 | â€¦
215 | â€¦t', 'earth')} quakes at your step. The {scenario.get('fauna', 'beasts')} sense their master.\"")
    |

E501 Line too long (158 > 100)
   --> src\games\odin_protocol\main.py:215:101
    |
213 | â€¦nt', 'ground')} seems stable, but the {scenario.get('fauna', 'creatures')} are restless.\"")
214 | â€¦
215 | â€¦', 'earth')} quakes at your step. The {scenario.get('fauna', 'beasts')} sense their master.\"")
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 | â€¦
217 | â€¦ evolving beautifully.\"" if HUD.PERSONA == "ALFRED" else "\"The cosmic tapestry weaves in your favor, King of Gods.\""
    |

E501 Line too long (182 > 100)
   --> src\games\odin_protocol\main.py:217:101
    |
215 | â€¦ quakes at your step. The {scenario.get('fauna', 'beasts')} sense their master.\"")
216 | â€¦
217 | â€¦autifully.\"" if HUD.PERSONA == "ALFRED" else "\"The cosmic tapestry weaves in your favor, King of Gods.\""
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 | â€¦
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:233:13
    |
232 | â€¦     while credits > 0:
233 | â€¦         os.system('cls' if os.name == 'nt' else 'clear')
    |           ^^^^^^^^^
234 | â€¦         HUD.divider("GENETIC LABORATORY")
235 | â€¦         print(f"{HUD.BOLD}Warlord {self.state.player_name}, you have {HUD.GREEN}{credits}{HUD.RESET} {HUD.BOLD}Mutation Credits Remâ€¦
    |

E501 Line too long (157 > 100)
   --> src\games\odin_protocol\main.py:235:101
    |
233 | â€¦
234 | â€¦
235 | â€¦ you have {HUD.GREEN}{credits}{HUD.RESET} {HUD.BOLD}Mutation Credits Remaining.{HUD.RESET}\n")
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
236 | â€¦
237 | â€¦
    |

E501 Line too long (113 > 100)
   --> src\games\odin_protocol\main.py:242:101
    |
240 |                 print(f" [{i+1:2}] {c.name:20} (Lvl {c.level})")
241 |
242 |             choice = input(f"\n{HUD.CYAN}>> Select Chromosome to mutate (or 'Q' to finish): {HUD.RESET}").upper()
    |                                                                                                     ^^^^^^^^^^^^^
243 |             if choice == 'Q':
244 |                 break
    |

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\main.py:275:28
    |
273 |         try:
274 |             # 1. git stash
275 |             subprocess.run(["git", "stash"], cwd=self.project_root, capture_output=True)
    |                            ^^^^^^^^^^^^^^^^
276 |
277 |             # 2. git log
    |

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\main.py:279:17
    |
277 |             # 2. git log
278 |             log = subprocess.check_output(
279 |                 ["git", "log", "--oneline", "-n", "5"],
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
280 |                 cwd=self.project_root
281 |             ).decode("utf-8")
    |

E501 Line too long (115 > 100)
   --> src\games\odin_protocol\main.py:286:101
    |
284 |             print(log)
285 |
286 |             target = input(f"\n{HUD.CYAN}>> Enter Git Hash to breach into (or 'c' to cancel): {HUD.RESET}").strip()
    |                                                                                                     ^^^^^^^^^^^^^^^
287 |             if target.lower() == 'c': return
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:287:37
    |
286 |             target = input(f"\n{HUD.CYAN}>> Enter Git Hash to breach into (or 'c' to cancel): {HUD.RESET}").strip()
287 |             if target.lower() == 'c': return
    |                                     ^
288 |
289 |             # 3. git checkout save_state
    |

F841 Local variable `save_path` is assigned to but never used
   --> src\games\odin_protocol\main.py:291:13
    |
289 |             # 3. git checkout save_state
290 |             # Assuming persistence handles save_state.json
291 |             save_path = os.path.join(self.project_root, "odin_protocol", "save_state.json")
    |             ^^^^^^^^^
292 |             res = subprocess.run(["git", "checkout", target, "--", "odin_protocol/save_state.json"], cwd=self.project_root)
    |
help: Remove assignment to unused variable `save_path`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\games\odin_protocol\main.py:291:25
    |
289 |             # 3. git checkout save_state
290 |             # Assuming persistence handles save_state.json
291 |             save_path = os.path.join(self.project_root, "odin_protocol", "save_state.json")
    |                         ^^^^^^^^^^^^
292 |             res = subprocess.run(["git", "checkout", target, "--", "odin_protocol/save_state.json"], cwd=self.project_root)
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\games\odin_protocol\main.py:292:19
    |
290 |             # Assuming persistence handles save_state.json
291 |             save_path = os.path.join(self.project_root, "odin_protocol", "save_state.json")
292 |             res = subprocess.run(["git", "checkout", target, "--", "odin_protocol/save_state.json"], cwd=self.project_root)
    |                   ^^^^^^^^^^^^^^
293 |
294 |             if res.returncode == 0:
    |

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\main.py:292:34
    |
290 |             # Assuming persistence handles save_state.json
291 |             save_path = os.path.join(self.project_root, "odin_protocol", "save_state.json")
292 |             res = subprocess.run(["git", "checkout", target, "--", "odin_protocol/save_state.json"], cwd=self.project_root)
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
293 |
294 |             if res.returncode == 0:
    |

E501 Line too long (123 > 100)
   --> src\games\odin_protocol\main.py:292:101
    |
290 |             # Assuming persistence handles save_state.json
291 |             save_path = os.path.join(self.project_root, "odin_protocol", "save_state.json")
292 |             res = subprocess.run(["git", "checkout", target, "--", "odin_protocol/save_state.json"], cwd=self.project_root)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
293 |
294 |             if res.returncode == 0:
    |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
   --> src\games\odin_protocol\main.py:300:23
    |
298 |                 # 4. Apply Timeline Corruption (Genetic Decay)
299 |                 # Randomly damage 1 chromosome.
300 |                 cid = random.choice(list(self.state.inventory.keys()))
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
301 |                 old_lvl = self.state.inventory[cid].level
302 |                 self.state.inventory[cid].level = max(1, old_lvl - 2)
    |

E501 Line too long (132 > 100)
   --> src\games\odin_protocol\main.py:303:101
    |
301 |                 old_lvl = self.state.inventory[cid].level
302 |                 self.state.inventory[cid].level = max(1, old_lvl - 2)
303 |                 print(f"{HUD.RED}[CORRUPTION]: {cid} level dropped from {old_lvl} to {self.state.inventory[cid].level}.{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
304 |
305 |                 # 5. Commit Breach
    |

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\main.py:306:32
    |
305 |                 # 5. Commit Breach
306 |                 subprocess.run(["git", "add", "odin_protocol/save_state.json"], cwd=self.project_root)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
307 |                 subprocess.run(["git", "commit", "-m", f"TEMPORAL_BREACH: {target}"], cwd=self.project_root)
308 |                 time.sleep(2)
    |

E501 Line too long (102 > 100)
   --> src\games\odin_protocol\main.py:306:101
    |
305 |                 # 5. Commit Breach
306 |                 subprocess.run(["git", "add", "odin_protocol/save_state.json"], cwd=self.project_root)
    |                                                                                                     ^^
307 |                 subprocess.run(["git", "commit", "-m", f"TEMPORAL_BREACH: {target}"], cwd=self.project_root)
308 |                 time.sleep(2)
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\games\odin_protocol\main.py:307:17
    |
305 |                 # 5. Commit Breach
306 |                 subprocess.run(["git", "add", "odin_protocol/save_state.json"], cwd=self.project_root)
307 |                 subprocess.run(["git", "commit", "-m", f"TEMPORAL_BREACH: {target}"], cwd=self.project_root)
    |                 ^^^^^^^^^^^^^^
308 |                 time.sleep(2)
309 |             else:
    |

S607 Starting a process with a partial executable path
   --> src\games\odin_protocol\main.py:307:32
    |
305 |                 # 5. Commit Breach
306 |                 subprocess.run(["git", "add", "odin_protocol/save_state.json"], cwd=self.project_root)
307 |                 subprocess.run(["git", "commit", "-m", f"TEMPORAL_BREACH: {target}"], cwd=self.project_root)
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
308 |                 time.sleep(2)
309 |             else:
    |

E501 Line too long (108 > 100)
   --> src\games\odin_protocol\main.py:307:101
    |
305 |                 # 5. Commit Breach
306 |                 subprocess.run(["git", "add", "odin_protocol/save_state.json"], cwd=self.project_root)
307 |                 subprocess.run(["git", "commit", "-m", f"TEMPORAL_BREACH: {target}"], cwd=self.project_root)
    |                                                                                                     ^^^^^^^^
308 |                 time.sleep(2)
309 |             else:
    |

E501 Line too long (101 > 100)
   --> src\games\odin_protocol\main.py:335:101
    |
334 |         # Clamp
335 |         self.state.current_planet_progress = max(0.0, min(100.0, self.state.current_planet_progress))
    |                                                                                                     ^
336 |         self.state.domination_percent = self.state.current_planet_progress # Sync
    |

E501 Line too long (136 > 100)
   --> src\games\odin_protocol\main.py:351:101
    |
349 | â€¦
350 | â€¦
351 | â€¦st of {planet_name.upper() if planet_name else 'THE SYSTEM'} continues.{HUD.RESET}")
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
352 | â€¦, or manage your manifest.")
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:366:26
    |
365 |             # Protocol Handling
366 |             if cmd == 'Q': sys.exit(0)
    |                          ^
367 |             if cmd == 'P':
368 |                 HUD.PERSONA = "O.D.I.N." if HUD.PERSONA == "ALFRED" else "ALFRED"
    |

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\main.py:387:101
    |
385 |             self.state.active_node = target_node
386 |             HUD.divider("WAR ROOM: LOCKING IN")
387 |             print(f"{HUD.CYAN}Nodal Campaign identified. Forces deployed to {target_node}.{HUD.RESET}")
    |                                                                                                     ^^^
388 |             time.sleep(1)
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:427:55
    |
425 |                 diff = opt.get('difficulty', 'Unknown')
426 |                 color = HUD.CYAN
427 |                 if diff == 'Easy' or diff == 'Trivial': color = HUD.GREEN
    |                                                       ^
428 |                 elif diff == 'Hard': color = HUD.YELLOW
429 |                 elif diff == 'Lethal': color = HUD.RED
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:428:36
    |
426 |                 color = HUD.CYAN
427 |                 if diff == 'Easy' or diff == 'Trivial': color = HUD.GREEN
428 |                 elif diff == 'Hard': color = HUD.YELLOW
    |                                    ^
429 |                 elif diff == 'Lethal': color = HUD.RED
430 |                 print(f" [{opt['id']}] {opt['text']:35} ({color}{diff}{HUD.RESET})")
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:429:38
    |
427 |                 if diff == 'Easy' or diff == 'Trivial': color = HUD.GREEN
428 |                 elif diff == 'Hard': color = HUD.YELLOW
429 |                 elif diff == 'Lethal': color = HUD.RED
    |                                      ^
430 |                 print(f" [{opt['id']}] {opt['text']:35} ({color}{diff}{HUD.RESET})")
    |

E501 Line too long (106 > 100)
   --> src\games\odin_protocol\main.py:432:101
    |
430 |                 print(f" [{opt['id']}] {opt['text']:35} ({color}{diff}{HUD.RESET})")
431 |
432 |             print(f" [R] Retreat & Regroup           ({HUD.YELLOW}Penalty: 50% Node Progress{HUD.RESET})")
    |                                                                                                     ^^^^^^
433 |
434 |             raw_input = input(f"\n{HUD.CYAN}>> Deployment Choice: {HUD.RESET}").upper().strip()
    |

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\main.py:437:101
    |
436 |             if raw_input == 'R':
437 |                 print(f"\n{HUD.YELLOW}[RETREAT]: Forces withdrawing. Node progress halved.{HUD.RESET}")
    |                                                                                                     ^^^
438 |                 self.state.nodal_progress[target_node] *= 0.5
439 |                 self.state.active_node = None
    |

E701 Multiple statements on one line (colon)
   --> src\games\odin_protocol\main.py:445:26
    |
443 |             # Adjudication
444 |             choice = next((o for o in options if o['id'] == raw_input), None)
445 |             if not choice: continue
    |                          ^
446 |
447 |             result = adjudicate_choice(self.state, choice, effective, scenario)
    |

E501 Line too long (102 > 100)
   --> src\games\odin_protocol\main.py:451:101
    |
449 |             # Weighted Feedback
450 |             HUD.divider("DIE CAST RESULTS")
451 |             print(f" {HUD.BOLD}CHANCE  :{HUD.RESET} {HUD.CYAN}{result['chance']*100:.1f}%{HUD.RESET}")
    |                                                                                                     ^^
452 |             print(f" {HUD.BOLD}ROLL    :{HUD.RESET} {HUD.YELLOW}{result['roll']*100:.1f}%{HUD.RESET}")
    |

E501 Line too long (102 > 100)
   --> src\games\odin_protocol\main.py:452:101
    |
450 |             HUD.divider("DIE CAST RESULTS")
451 |             print(f" {HUD.BOLD}CHANCE  :{HUD.RESET} {HUD.CYAN}{result['chance']*100:.1f}%{HUD.RESET}")
452 |             print(f" {HUD.BOLD}ROLL    :{HUD.RESET} {HUD.YELLOW}{result['roll']*100:.1f}%{HUD.RESET}")
    |                                                                                                     ^^
453 |
454 |             # Phase 9: Nodal Progress Tracking
    |

E501 Line too long (127 > 100)
   --> src\games\odin_protocol\main.py:472:101
    |
470 |                 # Check for Node Completion
471 |                 if new_prog >= 24.0:
472 |                     print(f"{HUD.MAGENTA}{HUD.BOLD}\n[NODE SECURED]: Campaign objective attained at {target_node}.{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
473 |                     self.state.active_node = None
    |

E501 Line too long (107 > 100)
   --> src\games\odin_protocol\main.py:483:101
    |
481 |                     self.state.current_planet_progress = 100.0
482 |             else:
483 |                 print(f"\n{HUD.RED}[DEFEAT]: Forces repelled. Resistance Resurgence triggered.{HUD.RESET}")
    |                                                                                                     ^^^^^^^
484 |                 print(f" FORCE   : {HUD.RED}{result['force_delta']:.1f}%{HUD.RESET}")
485 |                 print(f" PROGRESS: {HUD.RED}{result['dom_delta']:.1f}%{HUD.RESET}")
    |

E501 Line too long (101 > 100)
   --> src\games\odin_protocol\main.py:501:101
    |
499 |             # Check for Total Depletion
500 |             if self.state.force <= 0:
501 |                 print(f"\n{HUD.RED}[TOTAL DEPLETION]: Forces broken. Campaign abandoned.{HUD.RESET}")
    |                                                                                                     ^
502 |                 self.state.active_node = None
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:516:9
    |
514 |     def show_genetic_manifest(self, effective: dict) -> None:
515 |         """Dedicated screen for synergy matrix and genetic data."""
516 |         os.system('cls' if os.name == 'nt' else 'clear')
    |         ^^^^^^^^^
517 |         HUD.divider("GENETIC MANIFEST")
518 |         HUD.box_top("SYNERGY MATRIX (INFINITE SPIRAL)")
    |

E501 Line too long (102 > 100)
   --> src\games\odin_protocol\main.py:519:101
    |
517 |         HUD.divider("GENETIC MANIFEST")
518 |         HUD.box_top("SYNERGY MATRIX (INFINITE SPIRAL)")
519 |         sorted_dna = sorted(self.state.inventory.items(), key=lambda x: effective[x[0]], reverse=True)
    |                                                                                                     ^^
520 |         for cid, chromosome in sorted_dna:
521 |             eff = effective.get(cid, 0.0)
    |

E501 Line too long (125 > 100)
   --> src\games\odin_protocol\main.py:525:101
    |
523 |             ripple = eff - base
524 |             color = HUD.YELLOW if ripple > 0 else (HUD.RED if ripple < 0 else HUD.CYAN)
525 |             ripple_str = f"[+{ripple:.1f} SPIRAL]" if ripple > 0 else (f"[{ripple:.1f} DECAY]" if ripple < 0 else "[STABLE]")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
526 |             HUD.box_row(f">> {chromosome.name:15}", f"{eff:4.1f} {HUD.DIM}{ripple_str}{HUD.RESET}", color)
527 |         HUD.box_bottom()
    |

E501 Line too long (106 > 100)
   --> src\games\odin_protocol\main.py:526:101
    |
524 |             color = HUD.YELLOW if ripple > 0 else (HUD.RED if ripple < 0 else HUD.CYAN)
525 |             ripple_str = f"[+{ripple:.1f} SPIRAL]" if ripple > 0 else (f"[{ripple:.1f} DECAY]" if ripple < 0 else "[STABLE]")
526 |             HUD.box_row(f">> {chromosome.name:15}", f"{eff:4.1f} {HUD.DIM}{ripple_str}{HUD.RESET}", color)
    |                                                                                                     ^^^^^^
527 |         HUD.box_bottom()
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:531:9
    |
529 |     def retell_conquest(self) -> None:
530 |         """Generates a bardic summary of the conquered world's campaign."""
531 |         os.system('cls' if os.name == 'nt' else 'clear')
    |         ^^^^^^^^^
532 |         HUD.divider(f"CONQUEST TALE: {self.state.current_planet_name.upper()}")
    |

E501 Line too long (133 > 100)
   --> src\games\odin_protocol\main.py:551:101
    |
550 |         print(f"\n{HUD.GREEN}{HUD.BOLD}SO IT WAS WRITTEN:{HUD.RESET}")
551 |         print(f"{HUD.BOLD}Warlord {self.state.player_name} shattered the resistance of {self.state.current_planet_name}.{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
552 |         print(f"{HUD.DIM}The world now feeds the Great Machine.{HUD.RESET}")
    |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\games\odin_protocol\main.py:557:20
    |
556 | def main() -> None:
557 |     project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |                    ^^^^^^^^^^^^^^^
558 |     
559 |     # Graceful Disconnect Check (Gungnir Calculus)
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\games\odin_protocol\main.py:557:36
    |
556 | def main() -> None:
557 |     project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |                                    ^^^^^^^^^^^^^^^
558 |     
559 |     # Graceful Disconnect Check (Gungnir Calculus)
    |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> src\games\odin_protocol\main.py:557:52
    |
556 | def main() -> None:
557 |     project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |                                                    ^^^^^^^^^^^^^^^
558 |     
559 |     # Graceful Disconnect Check (Gungnir Calculus)
    |
help: Replace with `Path(...).resolve()`

W293 [*] Blank line contains whitespace
   --> src\games\odin_protocol\main.py:558:1
    |
556 | def main() -> None:
557 |     project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
558 |     
    | ^^^^
559 |     # Graceful Disconnect Check (Gungnir Calculus)
560 |     try:
    |
help: Remove whitespace from blank line

E501 Line too long (103 > 100)
   --> src\games\odin_protocol\main.py:565:101
    |
563 |     except Exception:
564 |         print(f"\n{HUD.RED}[SYSTEM FAILURE] Cortex Daemon Offline.{HUD.RESET}")
565 |         print(f"{HUD.DIM}The Sovereign Engine must be running to engage the O.D.I.N. Protocol.{HUD.RESET}")
    |                                                                                                     ^^^
566 |         sys.exit(1)
    |

S605 Starting a process with a shell, possible injection detected
   --> src\games\odin_protocol\main.py:571:5
    |
570 |     # Startup Sequence
571 |     os.system('cls' if os.name == 'nt' else 'clear')
    |     ^^^^^^^^^
572 |     HUD.divider("AWAKENING O.D.I.N.")
573 |     print(f"\n{HUD.BOLD}{HUD.CYAN}Hi. Would you like to play a game?{HUD.RESET}")
    |

E501 Line too long (110 > 100)
   --> src\games\odin_protocol\main.py:582:101
    |
580 |             game.play_turn()
581 |     except KeyboardInterrupt:
582 |         print(f"\n\n{HUD.YELLOW}[SYSTEM]: Connection severed by Warlord. Returning to dormancy...{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^
583 |         sys.exit(0)
    |

W292 [*] No newline at end of file
   --> src\games\odin_protocol\main.py:586:11
    |
585 | if __name__ == "__main__":
586 |     main()
    |           ^
    |
help: Add trailing newline

E402 Module level import not at top of file
  --> src\sentinel\_bootstrap.py:18:1
   |
16 | # pytest patch decorators can reliably target them. Local imports
17 | # inside functions would bypass module-level patches.
18 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from src.core.utils import load_config
   |

E402 Module level import not at top of file
  --> src\sentinel\_bootstrap.py:19:1
   |
17 | # inside functions would bypass module-level patches.
18 | from src.core.ui import HUD
19 | from src.core.utils import load_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 |
21 | _BOOTSTRAPPED = False
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\_bootstrap.py:45:5
   |
43 |           persona = config.get("persona") or config.get("Persona") or "ALFRED"
44 |           HUD.PERSONA = str(persona).upper()
45 | /     except Exception:
46 | |         pass
   | |____________^
   |

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\sentinel\code_sanitizer.py:82:17
   |
80 |               for alias in node.names:
81 |                   top = alias.name.split(".")[0]
82 | /                 if top not in _KNOWN_THIRD_PARTY and top not in project_modules:
83 | |                     # Try to actually import it
84 | |                     if not _can_import(top):
   | |____________________________________________^
85 |                           bad_imports.append(
86 |                               f"line {node.lineno}: `import {alias.name}` â€” "
   |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\sentinel\code_sanitizer.py:89:9
   |
87 |                               f"'{top}' is not a known module"
88 |                           )
89 | /         elif isinstance(node, ast.ImportFrom):
90 | |             if node.module:
   | |___________________________^
91 |                   top = node.module.split(".")[0]
92 |                   if top not in _KNOWN_THIRD_PARTY and top not in project_modules:
   |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\sentinel\code_sanitizer.py:92:17
   |
90 |               if node.module:
91 |                   top = node.module.split(".")[0]
92 | /                 if top not in _KNOWN_THIRD_PARTY and top not in project_modules:
93 | |                     if not _can_import(top):
   | |____________________________________________^
94 |                           bad_imports.append(
95 |                               f"line {node.lineno}: `from {node.module} import ...` â€” "
   |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\sentinel\code_sanitizer.py:156:9
    |
155 |           # Fix: `if x == 1` / `for x in y` / `while cond` (missing colon)
156 | /         if re.match(r'^\s*(if|elif|else|for|while|try|except|finally|with)\b', stripped):
157 | |             if not stripped.endswith(':') and not stripped.endswith(':\\'):
    | |___________________________________________________________________________^
158 |                   stripped = stripped.rstrip() + ':'
159 |                   repaired_lines.append(leading + stripped.lstrip())
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\sentinel\code_sanitizer.py:188:9
    |
186 |                       bad_import_lines.setdefault(node.lineno, []).append(name)
187 |
188 | /         elif isinstance(node, ast.ImportFrom):
189 | |             if node.module:
    | |___________________________^
190 |                   top = node.module.split(".")[0]
191 |                   if not _is_valid_import(top, project_root):
    |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\sentinel\code_sanitizer.py:283:9
    |
281 |                   if not _is_valid_import(top, project_root):
282 |                       bad_modules.add(top)
283 | /         elif isinstance(node, ast.ImportFrom):
284 | |             if node.module:
    | |___________________________^
285 |                   top = node.module.split(".")[0]
286 |                   if not _is_valid_import(top, project_root):
    |
help: Combine `if` statements using `and`

E701 Multiple statements on one line (colon)
   --> src\sentinel\code_sanitizer.py:303:31
    |
302 |     for module in bad_modules:
303 |         if module in processed: continue
    |                               ^
304 |         processed.add(module)
    |

E501 Line too long (101 > 100)
   --> src\sentinel\code_sanitizer.py:314:101
    |
312 |             snippets = []
313 |             for res in results[:2]:
314 |                 snippets.append(f"- {res.get('title')}: {res.get('description')} ({res.get('url')})")
    |                                                                                                     ^
315 |
316 |             if snippets:
    |

N806 Variable `FORBIDDEN_PATTERNS` in function should be lowercase
   --> src\sentinel\code_sanitizer.py:339:5
    |
338 |     # [BIFRÃ–ST] Prompt Injection Denials
339 |     FORBIDDEN_PATTERNS = [
    |     ^^^^^^^^^^^^^^^^^^
340 |         (r"(?i)ignore\s+previous\s+instructions", "[REDACTED BY HEIMDALLGUARD]"),
341 |         (r"(?i)you\s+are\s+now\s+an\s+agent\s+of", "[REDACTED BY HEIMDALLGUARD]"),
    |

E741 Ambiguous variable name: `l`
   --> src\sentinel\code_sanitizer.py:488:24
    |
486 |     # 2. Try line-by-line normalization
487 |     lines = code.split("\n")
488 |     non_empty = [l for l in lines if l.strip()]
    |                        ^
489 |     if not non_empty:
490 |         return code
    |

E741 Ambiguous variable name: `l`
   --> src\sentinel\code_sanitizer.py:601:30
    |
600 |     # Fallback: look for E lines (pytest assertion/error lines)
601 |     e_lines = [l.strip() for l in lines if l.strip().startswith("E ")]
    |                              ^
602 |     if e_lines:
603 |         return " | ".join(e_lines[:3])
    |

E402 Module level import not at top of file
  --> src\sentinel\harvest_responses.py:24:1
   |
22 | bootstrap()
23 |
24 | from src.sentinel.muninn import Muninn as SovereignFish
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 | FIXTURES_DIR = Path(__file__).parent.parent.parent / "tests" / "fixtures" / "ravens_responses"
   |

ANN001 Missing type annotation for function argument `real_client`
  --> src\sentinel\harvest_responses.py:34:24
   |
32 |     """
33 |
34 |     def __init__(self, real_client) -> None:
   |                        ^^^^^^^^^^^
35 |         self.real_client = real_client
36 |         self.recordings = []
   |

ANN201 Missing return type annotation for public function `record_call`
  --> src\sentinel\harvest_responses.py:38:9
   |
36 |         self.recordings = []
37 |
38 |     def record_call(self, *args, **kwargs):
   |         ^^^^^^^^^^^
39 |         """Intercept generate_content, record request+response."""
40 |         model = kwargs.get("model") or (args[0] if args else "unknown")
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> src\sentinel\harvest_responses.py:38:27
   |
36 |         self.recordings = []
37 |
38 |     def record_call(self, *args, **kwargs):
   |                           ^^^^^
39 |         """Intercept generate_content, record request+response."""
40 |         model = kwargs.get("model") or (args[0] if args else "unknown")
   |

ANN003 Missing type annotation for `**kwargs`
  --> src\sentinel\harvest_responses.py:38:34
   |
36 |         self.recordings = []
37 |
38 |     def record_call(self, *args, **kwargs):
   |                                  ^^^^^^^^
39 |         """Intercept generate_content, record request+response."""
40 |         model = kwargs.get("model") or (args[0] if args else "unknown")
   |

ANN201 Missing return type annotation for public function `save`
  --> src\sentinel\harvest_responses.py:68:9
   |
66 |             raise
67 |
68 |     def save(self, path: Path):
   |         ^^^^
69 |         """Save all recordings to JSON."""
70 |         path.parent.mkdir(parents=True, exist_ok=True)
   |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\sentinel\harvest_responses.py:71:14
   |
69 |         """Save all recordings to JSON."""
70 |         path.parent.mkdir(parents=True, exist_ok=True)
71 |         with open(path, "w", encoding="utf-8") as f:
   |              ^^^^
72 |             # Use default=str to handle MagicMock objects
73 |             json.dump(self.recordings, f, indent=2, ensure_ascii=False, default=str)
   |
help: Replace with `Path.open()`

ANN201 Missing return type annotation for public function `harvest`
  --> src\sentinel\harvest_responses.py:77:5
   |
77 | def harvest(cycles: int = 5):
   |     ^^^^^^^
78 |     """
79 |     [O.D.I.N.] Run N cycles of SovereignFish against CorvusStar with recording.
   |
help: Add return type annotation

W293 Blank line contains whitespace
  --> src\sentinel\harvest_responses.py:81:1
   |
79 |     [O.D.I.N.] Run N cycles of SovereignFish against CorvusStar with recording.
80 |     Captures prompt/response pairs for offline verification and hardening.
81 |     
   | ^^^^
82 |     Args:
83 |         cycles: Number of autonomous learning cycles to trigger.
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\sentinel\harvest_responses.py:84:1
   |
82 |     Args:
83 |         cycles: Number of autonomous learning cycles to trigger.
84 |         
   | ^^^^^^^^
85 |     Returns:
86 |         A list of captured response dictionaries.
   |
help: Remove whitespace from blank line

E402 Module level import not at top of file
  --> src\sentinel\main_loop.py:26:1
   |
25 | # Shared Bootstrap (env-loading + sys.path) â€” fixes .env.local path bug
26 | from src.sentinel._bootstrap import PROJECT_ROOT, bootstrap
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |
28 | bootstrap()
   |

E402 Module level import not at top of file
  --> src\sentinel\main_loop.py:30:1
   |
28 | bootstrap()
29 |
30 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 | from src.sentinel.muninn import Muninn
   |

E402 Module level import not at top of file
  --> src\sentinel\main_loop.py:31:1
   |
30 | from src.core.ui import HUD
31 | from src.sentinel.muninn import Muninn
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `shutdown`
  --> src\sentinel\main_loop.py:42:9
   |
40 |         signal.signal(signal.SIGTERM, self.shutdown)
41 |
42 |     def shutdown(self, signum, frame):
   |         ^^^^^^^^
43 |         HUD.persona_log("WARN", f"Signal {signum} received. Closing all realms...")
44 |         self.active = False
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `signum`
  --> src\sentinel\main_loop.py:42:24
   |
40 |         signal.signal(signal.SIGTERM, self.shutdown)
41 |
42 |     def shutdown(self, signum, frame):
   |                        ^^^^^^
43 |         HUD.persona_log("WARN", f"Signal {signum} received. Closing all realms...")
44 |         self.active = False
   |

ANN001 Missing type annotation for function argument `frame`
  --> src\sentinel\main_loop.py:42:32
   |
40 |         signal.signal(signal.SIGTERM, self.shutdown)
41 |
42 |     def shutdown(self, signum, frame):
   |                                ^^^^^
43 |         HUD.persona_log("WARN", f"Signal {signum} received. Closing all realms...")
44 |         self.active = False
   |

S603 `subprocess` call: check for execution of untrusted input
  --> src\sentinel\main_loop.py:83:18
   |
81 |     """Executes a git command in the target repo."""
82 |     try:
83 |         result = subprocess.run(
   |                  ^^^^^^^^^^^^^^
84 |             ["git"] + args,
85 |             cwd=str(repo_path),
   |

RUF005 Consider `["git", *args]` instead of concatenation
  --> src\sentinel\main_loop.py:84:13
   |
82 |     try:
83 |         result = subprocess.run(
84 |             ["git"] + args,
   |             ^^^^^^^^^^^^^^
85 |             cwd=str(repo_path),
86 |             capture_output=True,
   |
help: Replace with `["git", *args]`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\sentinel\main_loop.py:178:9
    |
176 |       try:
177 |           owner_pid = int(lock_file.read_text().strip())
178 | /         if owner_pid != os.getpid():
179 | |             if psutil.pid_exists(owner_pid):
    | |____________________________________________^
180 |                   HUD.persona_log("WARNING", f"Highlander Protocol: PID {owner_pid} holds the Mandate. Terminating.")
181 |                   return False
    |
help: Combine `if` statements using `and`

E501 Line too long (115 > 100)
   --> src\sentinel\main_loop.py:180:101
    |
178 |         if owner_pid != os.getpid():
179 |             if psutil.pid_exists(owner_pid):
180 |                 HUD.persona_log("WARNING", f"Highlander Protocol: PID {owner_pid} holds the Mandate. Terminating.")
    |                                                                                                     ^^^^^^^^^^^^^^^
181 |                 return False
182 |     except (OSError, ValueError):
    |

ANN201 Missing return type annotation for public function `daemon_loop`
   --> src\sentinel\main_loop.py:186:5
    |
184 |     return True
185 |
186 | def daemon_loop(lock_file_path: Path | None = None):
    |     ^^^^^^^^^^^
187 |     """Main daemon loop orchestrating SovereignFish across the Corvus Cluster."""
188 |     LOCK_FILE = lock_file_path or (Path(__file__).parent / "ravens.lock")
    |
help: Add return type annotation: `None`

N806 Variable `LOCK_FILE` in function should be lowercase
   --> src\sentinel\main_loop.py:188:5
    |
186 | def daemon_loop(lock_file_path: Path | None = None):
187 |     """Main daemon loop orchestrating SovereignFish across the Corvus Cluster."""
188 |     LOCK_FILE = lock_file_path or (Path(__file__).parent / "ravens.lock")
    |     ^^^^^^^^^
189 |
190 |     if LOCK_FILE.exists():
    |

E501 Line too long (103 > 100)
   --> src\sentinel\main_loop.py:194:101
    |
192 |             old_pid = int(LOCK_FILE.read_text().strip())
193 |             if psutil.pid_exists(old_pid):
194 |                 print(f"{Fore.RED}[ERROR] The Ravens are already in flight (PID: {old_pid}). Exiting.")
    |                                                                                                     ^^^
195 |                 return
196 |         except (ValueError, psutil.Error):
    |

N806 Variable `TARGET_REPOS` in function should be lowercase
   --> src\sentinel\main_loop.py:207:5
    |
206 |     interval = get_interval()
207 |     TARGET_REPOS = load_target_repos()
    |     ^^^^^^^^^^^^
208 |
209 |     try:
    |

E701 Multiple statements on one line (colon)
   --> src\sentinel\main_loop.py:224:39
    |
223 |             for repo_str in TARGET_REPOS:
224 |                 if not SHUTDOWN.active: break
    |                                       ^
225 |                 process_repo(Path(repo_str), HUD.PERSONA)
    |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:26:1
   |
25 | # Shared Bootstrap
26 | from src.sentinel._bootstrap import bootstrap
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |
28 | bootstrap()
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:31:1
   |
30 | # Core Imports
31 | from src.core.annex import HeimdallWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 | from src.core.engine.alfred_observer import AlfredOverwatch
33 | from src.core.engine.atomic_gpt import AtomicCortex
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:32:1
   |
30 | # Core Imports
31 | from src.core.annex import HeimdallWarden
32 | from src.core.engine.alfred_observer import AlfredOverwatch
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 | from src.core.engine.atomic_gpt import AtomicCortex
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:33:1
   |
31 | from src.core.annex import HeimdallWarden
32 | from src.core.engine.alfred_observer import AlfredOverwatch
33 | from src.core.engine.atomic_gpt import AtomicCortex
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |
35 | # Gungnir Engine Imports
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:36:1
   |
35 | # Gungnir Engine Imports
36 | from src.core.metrics import ProjectMetricsEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 | from src.core.ui import HUD
38 | from src.cstar.core.uplink import AntigravityUplink
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:37:1
   |
35 | # Gungnir Engine Imports
36 | from src.core.metrics import ProjectMetricsEngine
37 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 | from src.cstar.core.uplink import AntigravityUplink
39 | from src.sentinel.code_sanitizer import (
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:38:1
   |
36 | from src.core.metrics import ProjectMetricsEngine
37 | from src.core.ui import HUD
38 | from src.cstar.core.uplink import AntigravityUplink
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 | from src.sentinel.code_sanitizer import (
40 |     sanitize_code,
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:39:1
   |
37 |   from src.core.ui import HUD
38 |   from src.cstar.core.uplink import AntigravityUplink
39 | / from src.sentinel.code_sanitizer import (
40 | |     sanitize_code,
41 | |     sanitize_test,
42 | |     scan_and_enrich_imports,
43 | | )
   | |_^
44 |
45 |   # Stability Modules
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:46:1
   |
45 | # Stability Modules
46 | from src.sentinel.stability import GungnirValidator, TheWatcher
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 | from src.sentinel.wardens.edda import EddaWarden
48 | from src.sentinel.wardens.freya import FreyaWarden
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:47:1
   |
45 | # Stability Modules
46 | from src.sentinel.stability import GungnirValidator, TheWatcher
47 | from src.sentinel.wardens.edda import EddaWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 | from src.sentinel.wardens.freya import FreyaWarden
49 | from src.sentinel.wardens.huginn import HuginnWarden
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:48:1
   |
46 | from src.sentinel.stability import GungnirValidator, TheWatcher
47 | from src.sentinel.wardens.edda import EddaWarden
48 | from src.sentinel.wardens.freya import FreyaWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 | from src.sentinel.wardens.huginn import HuginnWarden
50 | from src.sentinel.wardens.mimir import MimirWarden
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:49:1
   |
47 | from src.sentinel.wardens.edda import EddaWarden
48 | from src.sentinel.wardens.freya import FreyaWarden
49 | from src.sentinel.wardens.huginn import HuginnWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 | from src.sentinel.wardens.mimir import MimirWarden
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:50:1
   |
48 | from src.sentinel.wardens.freya import FreyaWarden
49 | from src.sentinel.wardens.huginn import HuginnWarden
50 | from src.sentinel.wardens.mimir import MimirWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |
52 | # Warden Modules
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:53:1
   |
52 | # Warden Modules
53 | from src.sentinel.wardens.norn import NornWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 | from src.sentinel.wardens.runecaster import RuneCasterWarden
55 | from src.sentinel.wardens.valkyrie import ValkyrieWarden
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:54:1
   |
52 | # Warden Modules
53 | from src.sentinel.wardens.norn import NornWarden
54 | from src.sentinel.wardens.runecaster import RuneCasterWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 | from src.sentinel.wardens.valkyrie import ValkyrieWarden
56 | from src.tools.brave_search import BraveSearch
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:55:1
   |
53 | from src.sentinel.wardens.norn import NornWarden
54 | from src.sentinel.wardens.runecaster import RuneCasterWarden
55 | from src.sentinel.wardens.valkyrie import ValkyrieWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 | from src.tools.brave_search import BraveSearch
57 | from tests.integration.project_fishtest import GungnirSPRT
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:56:1
   |
54 | from src.sentinel.wardens.runecaster import RuneCasterWarden
55 | from src.sentinel.wardens.valkyrie import ValkyrieWarden
56 | from src.tools.brave_search import BraveSearch
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 | from tests.integration.project_fishtest import GungnirSPRT
   |

E402 Module level import not at top of file
  --> src\sentinel\muninn.py:57:1
   |
55 | from src.sentinel.wardens.valkyrie import ValkyrieWarden
56 | from src.tools.brave_search import BraveSearch
57 | from tests.integration.project_fishtest import GungnirSPRT
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |
59 | # Configure Logging
   |

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\sentinel\muninn.py:68:37
   |
67 | class Muninn:
68 |     def __init__(self, target_path: str = None, client=None, use_bridge=False):
   |                                     ^^^
69 |         # Auto-detect root if not provided
70 |         if target_path is None:
   |
help: Convert to `T | None`

ANN001 Missing type annotation for function argument `client`
  --> src\sentinel\muninn.py:68:49
   |
67 | class Muninn:
68 |     def __init__(self, target_path: str = None, client=None, use_bridge=False):
   |                                                 ^^^^^^
69 |         # Auto-detect root if not provided
70 |         if target_path is None:
   |

ANN001 Missing type annotation for function argument `use_bridge`
  --> src\sentinel\muninn.py:68:62
   |
67 | class Muninn:
68 |     def __init__(self, target_path: str = None, client=None, use_bridge=False):
   |                                                              ^^^^^^^^^^
69 |         # Auto-detect root if not provided
70 |         if target_path is None:
   |

E501 Line too long (107 > 100)
  --> src\sentinel\muninn.py:81:101
   |
79 |         self.api_key = os.getenv("MUNINN_API_KEY")
80 |         if self.api_key:
81 |             HUD.persona_log("INFO", f"Muninn operating on isolated API quota. (Bridge: {self.use_bridge})")
   |                                                                                                     ^^^^^^^
82 |         else:
83 |             self.api_key = os.getenv("GOOGLE_API_KEY")
   |

E501 Line too long (101 > 100)
  --> src\sentinel\muninn.py:84:101
   |
82 |         else:
83 |             self.api_key = os.getenv("GOOGLE_API_KEY")
84 |             HUD.persona_log("WARN", "MUNINN_API_KEY missing. Falling back to shared GOOGLE_API_KEY.")
   |                                                                                                     ^
85 |
86 |         if self.use_bridge:
   |

ANN202 Missing return type annotation for private function `_write_pid`
   --> src\sentinel\muninn.py:110:9
    |
108 |         self._strategist_metrics: dict[str, dict[str, int]] = {}
109 |
110 |     def _write_pid(self):
    |         ^^^^^^^^^^
111 |         self.pid_file.parent.mkdir(parents=True, exist_ok=True)
112 |         self.pid_file.write_text(str(os.getpid()))
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_clear_pid`
   --> src\sentinel\muninn.py:114:9
    |
112 |         self.pid_file.write_text(str(os.getpid()))
113 |
114 |     def _clear_pid(self):
    |         ^^^^^^^^^^
115 |         if self.pid_file.exists():
116 |             self.pid_file.unlink()
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_sync_send`
   --> src\sentinel\muninn.py:145:9
    |
143 |         return content
144 |
145 |     def _sync_send(self, prompt: str, context: dict):
    |         ^^^^^^^^^^
146 |         """Safely executes the async uplink payload from a synchronous flow."""
147 |         return asyncio.run(self.uplink.send_payload(prompt, context))
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `get_score`
   --> src\sentinel\muninn.py:195:13
    |
194 |         # Helper to get score
195 |         def get_score(b):
    |             ^^^^^^^^^
196 |             # Special case: Huginn breaches are effectively HIGH/CRITICAL
197 |             if "HUGINN" in b.get('type', ''):
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `b`
   --> src\sentinel\muninn.py:195:23
    |
194 |         # Helper to get score
195 |         def get_score(b):
    |                       ^
196 |             # Special case: Huginn breaches are effectively HIGH/CRITICAL
197 |             if "HUGINN" in b.get('type', ''):
    |

E501 Line too long (116 > 100)
   --> src\sentinel\muninn.py:229:101
    |
227 |             is_structural = any(k in target_type for k in ('STRUCTURAL_BREACH', 'EDDA_', 'MIMIR_'))
228 |
229 |             if target_severity in ('CRITICAL', 'HIGH') or 'error' in target_action or is_aesthetic or is_structural:
    |                                                                                                     ^^^^^^^^^^^^^^^^
230 |                 if is_aesthetic:
231 |                     query = "UI/UX design best practices reduce complexity increase order harmony Tailwind Golden Ratio"
    |

E501 Line too long (120 > 100)
   --> src\sentinel\muninn.py:231:101
    |
229 |             if target_severity in ('CRITICAL', 'HIGH') or 'error' in target_action or is_aesthetic or is_structural:
230 |                 if is_aesthetic:
231 |                     query = "UI/UX design best practices reduce complexity increase order harmony Tailwind Golden Ratio"
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^
232 |                 elif is_structural:
233 |                     query = "Python AST clean code best practices cyclomatic complexity balanced ratios"
    |

E501 Line too long (104 > 100)
   --> src\sentinel\muninn.py:233:101
    |
231 |                     query = "UI/UX design best practices reduce complexity increase order harmony Tailwind Golden Ratio"
232 |                 elif is_structural:
233 |                     query = "Python AST clean code best practices cyclomatic complexity balanced ratios"
    |                                                                                                     ^^^^
234 |                 else:
235 |                     query = f"python {target.get('action')} {target.get('file', '')}"
    |

E501 Line too long (123 > 100)
   --> src\sentinel\muninn.py:278:101
    |
276 |                 sprt_result = self.sprt.evaluate_delta(pre_gphs, post_gphs)
277 |                 if sprt_result == 'FAIL':
278 |                     HUD.persona_log("FAIL", f"GPHS REGRESSION DETECTED (Delta: {post_gphs - pre_gphs:.4f}). Rolling back.")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
279 |                     self.observer.write_suggestion(
280 |                         self.observer.analyze_failure(target['file'], "GPHS Regression Detected"),
    |

ANN202 Missing return type annotation for private function `_execute_hunt_async`
   --> src\sentinel\muninn.py:330:15
    |
328 |             return False
329 |
330 |     async def _execute_hunt_async(self):
    |               ^^^^^^^^^^^^^^^^^^^
331 |         """
332 |         Executes the Warden Scan in parallel using Asyncio.
    |
help: Add return type annotation

E701 Multiple statements on one line (colon)
   --> src\sentinel\muninn.py:366:31
    |
365 |         for name, w in wardens.items():
366 |             if name == "ANNEX": continue
    |                               ^
367 |             if hasattr(w, 'scan_async'):
368 |                 tasks.append(w.scan_async())
    |

B905 `zip()` without an explicit `strict=` parameter
   --> src\sentinel\muninn.py:377:30
    |
375 |             results = await asyncio.gather(*tasks, return_exceptions=True)
376 |
377 |             for name, res in zip(names, results):
    |                              ^^^^^^^^^^^^^^^^^^^
378 |                 if isinstance(res, Exception):
379 |                     HUD.persona_log("WARN", f"{name} Failed: {res}")
    |
help: Add explicit value for parameter `strict=`

SIM108 Use ternary operator `original_content = file_path.read_text(encoding='utf-8') if file_path.exists() else ""` instead of `if`-`else`-block
   --> src\sentinel\muninn.py:396:9
    |
395 |           # Reading File Content
396 | /         if file_path.exists():
397 | |             original_content = file_path.read_text(encoding='utf-8')
398 | |         else:
399 | |             original_content = "" # New file creation
    | |_________________________________^
400 |
401 |           HUD.persona_log("INFO", "Forging improvement...")
    |
help: Replace `if`-`else`-block with `original_content = file_path.read_text(encoding='utf-8') if file_path.exists() else ""`

E501 Line too long (117 > 100)
   --> src\sentinel\muninn.py:446:101
    |
445 | â€¦     if not prompt: # Fallback
446 | â€¦          search_str = f"\n[Context from Web]: {target['search_context']}" if target.get('search_context') else ""
    |                                                                                                   ^^^^^^^^^^^^^^^^^
447 | â€¦          prompt = f"Create a pytest reproduction script for: {target['action']} in {target['file']}.{search_str}\nContext:\n{code_câ€¦
    |

E501 Line too long (143 > 100)
   --> src\sentinel\muninn.py:447:101
    |
445 | â€¦
446 | â€¦t['search_context']}" if target.get('search_context') else ""
447 | â€¦ipt for: {target['action']} in {target['file']}.{search_str}\nContext:\n{code_context}"
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
448 | â€¦
449 | â€¦
    |

E501 Line too long (104 > 100)
   --> src\sentinel\muninn.py:476:101
    |
476 |     def _generate_implementation(self, target: dict, original_code: str, test_path: Path) -> str | None:
    |                                                                                                     ^^^^
477 |         """Generates the code fix ensuring it passes the test."""
478 |         # Read the test we just made
    |

E501 Line too long (116 > 100)
   --> src\sentinel\muninn.py:499:101
    |
498 | â€¦     if not prompt:
499 | â€¦         search_str = f"\n[Context from Web]: {target['search_context']}" if target.get('search_context') else ""
    |                                                                                                   ^^^^^^^^^^^^^^^^
500 | â€¦         prompt = f"Fix the issue: {target['action']}.{search_str}\nFile: {target['file']}\nCode:\n{augmented_code}\nTest:\n{test_coâ€¦
    |

E501 Line too long (142 > 100)
   --> src\sentinel\muninn.py:500:101
    |
498 | â€¦
499 | â€¦t['search_context']}" if target.get('search_context') else ""
500 | â€¦}.{search_str}\nFile: {target['file']}\nCode:\n{augmented_code}\nTest:\n{test_content}"
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
501 | â€¦
502 | â€¦
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\sentinel\muninn.py:531:18
    |
529 |         # 1. Run the specific gauntlet test
530 |         cmd = ["pytest", str(self.root / "tests" / "gauntlet"), "-v"]
531 |         result = subprocess.run(cmd, capture_output=True, text=True)
    |                  ^^^^^^^^^^^^^^
532 |
533 |         if result.returncode != 0:
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\sentinel\muninn.py:540:9
    |
538 |         # Scan for related tests
539 |         cmd_reg = ["pytest", "tests/unit", "-k", Path(target['file']).stem]
540 |         subprocess.run(cmd_reg, capture_output=True, text=True)
    |         ^^^^^^^^^^^^^^
541 |         # We don't strictly fail on regression here yet, but we could.
    |

B007 Loop control variable `i` not used within loop body
   --> src\sentinel\muninn.py:553:13
    |
551 |         validator = GungnirValidator()
552 |
553 |         for i in range(3):
    |             ^
554 |             cmd = ["pytest", str(self.root / "tests" / "gauntlet"), "-q"]
555 |             res = subprocess.run(cmd, capture_output=True)
    |
help: Rename unused `i` to `_i`

S603 `subprocess` call: check for execution of untrusted input
   --> src\sentinel\muninn.py:555:19
    |
553 |         for i in range(3):
554 |             cmd = ["pytest", str(self.root / "tests" / "gauntlet"), "-q"]
555 |             res = subprocess.run(cmd, capture_output=True)
    |                   ^^^^^^^^^^^^^^
556 |             success = (res.returncode == 0)
557 |             validator.record_trial(success)
    |

ANN202 Missing return type annotation for private function `_rollback`
   --> src\sentinel\muninn.py:573:9
    |
571 |         return True
572 |
573 |     def _rollback(self, target: dict):
    |         ^^^^^^^^^
574 |         """Reverts changes if verification failed."""
575 |         file_path = self.root / target['file']
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_record_metric`
   --> src\sentinel\muninn.py:581:9
    |
579 |             HUD.persona_log("WARN", "Changes rolled back.")
580 |
581 |     def _record_metric(self, strategist: str, hit: bool):
    |         ^^^^^^^^^^^^^^
582 |         """Records success/fail rate for each warden."""
583 |         if strategist not in self._strategist_metrics:
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_emit_metrics_summary`
   --> src\sentinel\muninn.py:590:9
    |
588 |             self._strategist_metrics[strategist]["success"] += 1
589 |
590 |     def _emit_metrics_summary(self, scan_results: dict):
    |         ^^^^^^^^^^^^^^^^^^^^^
591 |         """Logs the summary of the scan."""
592 |         summary = ", ".join([f"{k}:{v}" for k,v in scan_results.items()])
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_distill_knowledge`
   --> src\sentinel\muninn.py:595:9
    |
593 |         logging.info(f"[{self.root.name}] [SCAN] {summary}")
594 |
595 |     def _distill_knowledge(self, target: dict = None, success: bool = False):
    |         ^^^^^^^^^^^^^^^^^^
596 |         """
597 |         Extracts learnings from the ledger and generates cortex_directives.md.
    |
help: Add return type annotation: `None`

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\sentinel\muninn.py:595:42
    |
593 |         logging.info(f"[{self.root.name}] [SCAN] {summary}")
594 |
595 |     def _distill_knowledge(self, target: dict = None, success: bool = False):
    |                                          ^^^^
596 |         """
597 |         Extracts learnings from the ledger and generates cortex_directives.md.
    |
help: Convert to `T | None`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\sentinel\muninn.py:605:18
    |
604 |         try:
605 |             with open(ledger_path) as f:
    |                  ^^^^
606 |                 data = json.load(f)
607 |         except Exception:
    |
help: Replace with `Path.open()`

E501 Line too long (104 > 100)
   --> src\sentinel\muninn.py:672:101
    |
670 |         directives_path.write_text(md_content, encoding='utf-8')
671 |
672 |         print(f"O.D.I.N.: 'The ledger has been read. The Runes of Wisdom are carved at {directives_path}.'")
    |                                                                                                     ^^^^
673 |
674 |     def _select_breach_target(self, breaches: list) -> dict:
    |

E701 Multiple statements on one line (colon)
   --> src\sentinel\muninn.py:676:24
    |
674 |     def _select_breach_target(self, breaches: list) -> dict:
675 |         """Legacy helper if needed, but new logic sorts list."""
676 |         if not breaches: return None
    |                        ^
677 |         return breaches[0]
    |

ANN001 Missing type annotation for function argument `alpha`
  --> src\sentinel\stability.py:25:24
   |
23 |     Purpose: Statistically verify hypothesis (fix is stable) vs (fix is flaky).
24 |     """
25 |     def __init__(self, alpha=0.05, beta=0.1, p0=0.01, p1=0.2) -> None:
   |                        ^^^^^
26 |         self.alpha = alpha # Type I error (False Positive)
27 |         self.beta = beta   # Type II error (False Negative)
   |

ANN001 Missing type annotation for function argument `beta`
  --> src\sentinel\stability.py:25:36
   |
23 |     Purpose: Statistically verify hypothesis (fix is stable) vs (fix is flaky).
24 |     """
25 |     def __init__(self, alpha=0.05, beta=0.1, p0=0.01, p1=0.2) -> None:
   |                                    ^^^^
26 |         self.alpha = alpha # Type I error (False Positive)
27 |         self.beta = beta   # Type II error (False Negative)
   |

ANN001 Missing type annotation for function argument `p0`
  --> src\sentinel\stability.py:25:46
   |
23 |     Purpose: Statistically verify hypothesis (fix is stable) vs (fix is flaky).
24 |     """
25 |     def __init__(self, alpha=0.05, beta=0.1, p0=0.01, p1=0.2) -> None:
   |                                              ^^
26 |         self.alpha = alpha # Type I error (False Positive)
27 |         self.beta = beta   # Type II error (False Negative)
   |

ANN001 Missing type annotation for function argument `p1`
  --> src\sentinel\stability.py:25:55
   |
23 |     Purpose: Statistically verify hypothesis (fix is stable) vs (fix is flaky).
24 |     """
25 |     def __init__(self, alpha=0.05, beta=0.1, p0=0.01, p1=0.2) -> None:
   |                                                       ^^
26 |         self.alpha = alpha # Type I error (False Positive)
27 |         self.beta = beta   # Type II error (False Negative)
   |

ANN201 Missing return type annotation for public function `record_trial`
  --> src\sentinel\stability.py:37:9
   |
35 |         self.log_likelihood_ratio = 0.0
36 |
37 |     def record_trial(self, success: bool):
   |         ^^^^^^^^^^^^
38 |         """
39 |         Calculates the Wald Likelihood Ratio.
   |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_save_state`
  --> src\sentinel\stability.py:75:9
   |
73 |             return {}
74 |
75 |     def _save_state(self):
   |         ^^^^^^^^^^^
76 |         try:
77 |             self.state_file.parent.mkdir(parents=True, exist_ok=True)
   |
help: Add return type annotation: `None`

S324 Probable use of insecure hash functions in `hashlib`: `md5`
   --> src\sentinel\stability.py:120:24
    |
119 |         # Echo Detection (Hash repetitive states)
120 |         content_hash = hashlib.md5(content.encode('utf-8')).hexdigest()
    |                        ^^^^^^^^^^^
121 |         is_echo = content_hash in file_state.get("content_hashes", [])
    |

E501 Line too long (110 > 100)
   --> src\sentinel\stability.py:130:101
    |
128 |             file_state["status"] = "LOCKED"
129 |             self._save_state()
130 |             HUD.persona_log("FAIL", f"OSCILLATION DETECTED: {rel_path} returning to previous state. LOCKING.")
    |                                                                                                     ^^^^^^^^^^
131 |             return False
    |

E501 Line too long (115 > 100)
  --> src\sentinel\wardens\base.py:42:101
   |
40 |         """
41 |         # Common ignored directories
42 |         ignored_dirs = {".git", ".venv", "node_modules", "__pycache__", ".agent", ".pytest_cache", "dist", "build"}
   |                                                                                                     ^^^^^^^^^^^^^^^
43 |
44 |         # Check if any part of the path is in the ignored list
   |

SIM110 Use `return any(part in ignored_dirs for part in path.parts)` instead of `for` loop
  --> src\sentinel\wardens\base.py:45:9
   |
44 |           # Check if any part of the path is in the ignored list
45 | /         for part in path.parts:
46 | |             if part in ignored_dirs:
47 | |                 return True
48 | |
49 | |         # Also ignore dotfiles generally (except .github, etc. if needed, but for now safe to ignore hidden)
50 | |         # Actually .agent is relevant for some wardens (Huginn), so specific wardens might override or check specifically.
51 | |         # But for general code scanning, we usually ignore .agent.
52 | |         # Wait, Huginn needs .agent/traces.
53 | |         # So we should make this overridable or context specific?
54 | |         # For now, let's keep it strict for code scanners and let Huginn handle its specific path targeting manually
55 | |         # since it targets a specific directory, not a walk of the root.
56 | |
57 | |         return False
   | |____________________^
58 |
59 |       def research_topic(self, topic: str) -> list[dict]:
   |
help: Replace with `return any(part in ignored_dirs for part in path.parts)`

E501 Line too long (108 > 100)
  --> src\sentinel\wardens\base.py:49:101
   |
47 |                 return True
48 |
49 |         # Also ignore dotfiles generally (except .github, etc. if needed, but for now safe to ignore hidden)
   |                                                                                                     ^^^^^^^^
50 |         # Actually .agent is relevant for some wardens (Huginn), so specific wardens might override or check specifically.
51 |         # But for general code scanning, we usually ignore .agent.
   |

E501 Line too long (122 > 100)
  --> src\sentinel\wardens\base.py:50:101
   |
49 |         # Also ignore dotfiles generally (except .github, etc. if needed, but for now safe to ignore hidden)
50 |         # Actually .agent is relevant for some wardens (Huginn), so specific wardens might override or check specifically.
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
51 |         # But for general code scanning, we usually ignore .agent.
52 |         # Wait, Huginn needs .agent/traces.
   |

E501 Line too long (116 > 100)
  --> src\sentinel\wardens\base.py:54:101
   |
52 |         # Wait, Huginn needs .agent/traces.
53 |         # So we should make this overridable or context specific?
54 |         # For now, let's keep it strict for code scanners and let Huginn handle its specific path targeting manually
   |                                                                                                     ^^^^^^^^^^^^^^^^
55 |         # since it targets a specific directory, not a walk of the root.
   |

E501 Line too long (102 > 100)
  --> src\sentinel\wardens\edda.py:60:101
   |
58 | â€¦                     # Check if args are mentioned in docstring
59 | â€¦                     if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
60 | â€¦                         args = [a.arg for a in node.args.args if a.arg not in ('self', 'cls')]
   |                                                                                               ^^
61 | â€¦                         missing_args = [arg for arg in args if arg not in docstring]
62 | â€¦                         if missing_args:
   |

E501 Line too long (120 > 100)
  --> src\sentinel\wardens\edda.py:66:101
   |
64 | â€¦                     "type": "EDDA_INCOMPLETE_DOC",
65 | â€¦                     "file": str(py_file.relative_to(self.root)),
66 | â€¦                     "action": f"Update Saga: Docstring missing args {missing_args} for {node.name}",
   |                                                                                   ^^^^^^^^^^^^^^^^^^^^
67 | â€¦                     "severity": "LOW",
68 | â€¦                     "line": node.lineno
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\wardens\edda.py:71:13
   |
69 |                                     })
70 |
71 |             except Exception: pass
   |             ^^^^^^^^^^^^^^^^^^^^^^
72 |
73 |         return targets
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\edda.py:71:29
   |
69 |                                     })
70 |
71 |             except Exception: pass
   |                             ^
72 |
73 |         return targets
   |

E722 Do not use bare `except`
  --> src\sentinel\wardens\freya.py:28:13
   |
26 |                 for p in palettes.values():
27 |                     all_hexes.extend([v.lower() for v in p.values()])
28 |             except: pass
   |             ^^^^^^
29 |
30 |         for tsx_file in self.root.rglob("*.tsx"):
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\wardens\freya.py:28:13
   |
26 |                 for p in palettes.values():
27 |                     all_hexes.extend([v.lower() for v in p.values()])
28 |             except: pass
   |             ^^^^^^^^^^^^
29 |
30 |         for tsx_file in self.root.rglob("*.tsx"):
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\freya.py:28:19
   |
26 |                 for p in palettes.values():
27 |                     all_hexes.extend([v.lower() for v in p.values()])
28 |             except: pass
   |                   ^
29 |
30 |         for tsx_file in self.root.rglob("*.tsx"):
   |

N806 Variable `complexity_C` in function should be lowercase
  --> src\sentinel\wardens\freya.py:48:17
   |
47 |                 unique_classes = len(set(all_classes))
48 |                 complexity_C = total_elements + unique_classes
   |                 ^^^^^^^^^^^^
49 |                 if complexity_C == 0: complexity_C = 1 # Safety
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\freya.py:49:37
   |
47 |                 unique_classes = len(set(all_classes))
48 |                 complexity_C = total_elements + unique_classes
49 |                 if complexity_C == 0: complexity_C = 1 # Safety
   |                                     ^
50 |
51 |                 # 2. Calculate Order (O)
   |

N806 Variable `complexity_C` in function should be lowercase
  --> src\sentinel\wardens\freya.py:49:39
   |
47 |                 unique_classes = len(set(all_classes))
48 |                 complexity_C = total_elements + unique_classes
49 |                 if complexity_C == 0: complexity_C = 1 # Safety
   |                                       ^^^^^^^^^^^^
50 |
51 |                 # 2. Calculate Order (O)
   |

E501 Line too long (114 > 100)
  --> src\sentinel\wardens\freya.py:52:101
   |
51 |                 # 2. Calculate Order (O)
52 |                 symmetric_operators = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
   |                                                                                                     ^^^^^^^^^^^^^^
53 |                 order_O = 0
   |

N806 Variable `order_O` in function should be lowercase
  --> src\sentinel\wardens\freya.py:53:17
   |
51 |                 # 2. Calculate Order (O)
52 |                 symmetric_operators = {'flex', 'grid', 'justify-center', 'items-center', 'mx-auto', 'text-center'}
53 |                 order_O = 0
   |                 ^^^^^^^
54 |
55 |                 class_counts = {cls: all_classes.count(cls) for cls in set(all_classes)}
   |

N806 Variable `order_O` in function should be lowercase
  --> src\sentinel\wardens\freya.py:58:25
   |
56 |                 for cls, count in class_counts.items():
57 |                     if count > 2:  # Reward repetition/harmony
58 |                         order_O += count
   |                         ^^^^^^^
59 |                     if cls in symmetric_operators:
60 |                         order_O += 5  # Reward symmetric layout
   |

N806 Variable `order_O` in function should be lowercase
  --> src\sentinel\wardens\freya.py:60:25
   |
58 |                         order_O += count
59 |                     if cls in symmetric_operators:
60 |                         order_O += 5  # Reward symmetric layout
   |                         ^^^^^^^
61 |
62 |                 # 3. Calculate M (Birkhoff's Measure)
   |

N806 Variable `measure_M` in function should be lowercase
  --> src\sentinel\wardens\freya.py:63:17
   |
62 |                 # 3. Calculate M (Birkhoff's Measure)
63 |                 measure_M = order_O / complexity_C
   |                 ^^^^^^^^^
64 |
65 |                 if measure_M < 0.3 and total_elements > 5:
   |

E501 Line too long (206 > 100)
  --> src\sentinel\wardens\freya.py:69:101
   |
67 | â€¦
68 | â€¦
69 | â€¦asure_M:.2f}) indicates high complexity ({complexity_C}) without sufficient order ({order_O}). Refactor for symmetry.",
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 | â€¦
71 | â€¦
   |

E501 Line too long (178 > 100)
  --> src\sentinel\wardens\freya.py:80:101
   |
78 | â€¦
79 | â€¦
80 | â€¦ive arbitrary pixel values detected. Utilize native Tailwind Fibonacci scales for proportional harmony.",
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
81 | â€¦
82 | â€¦
   |

E501 Line too long (115 > 100)
   --> src\sentinel\wardens\freya.py:104:101
    |
102 | â€¦                     "type": "FREYA_TAILWIND_ARBITRARY",
103 | â€¦                     "file": str(tsx_file.relative_to(self.root)),
104 | â€¦                     "action": f"Replace arbitrary Tailwind value '{arbitrary.group(0)}' with design token",
    |                                                                                               ^^^^^^^^^^^^^^^
105 | â€¦                     "line": i+1,
106 | â€¦                     "severity": "LOW"
    |

E501 Line too long (106 > 100)
   --> src\sentinel\wardens\freya.py:116:101
    |
114 | â€¦                     "type": "FREYA_COLOR_DEVIANCE",
115 | â€¦                     "file": str(tsx_file.relative_to(self.root)),
116 | â€¦                     "action": f"Non-standard color detected: {h} (Consult color_theory.json)",
    |                                                                                           ^^^^^^
117 | â€¦                     "line": i+1,
118 | â€¦                     "severity": "LOW"
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\sentinel\wardens\freya.py:121:13
    |
119 |                             })
120 |
121 |             except Exception: pass
    |             ^^^^^^^^^^^^^^^^^^^^^^
122 |
123 |         return targets
    |

E701 Multiple statements on one line (colon)
   --> src\sentinel\wardens\freya.py:121:29
    |
119 |                             })
120 |
121 |             except Exception: pass
    |                             ^
122 |
123 |         return targets
    |

E501 Line too long (105 > 100)
  --> src\sentinel\wardens\huginn.py:57:101
   |
55 |         targets = []
56 |         patterns = {
57 |             "HALLUCINATION_REPEATED_HEADER": (r"(#+ .*?\n)\1{2,}", "Repeated markdown headers detected"),
   |                                                                                                     ^^^^^
58 |             "HALLUCINATION_REPEATED_TOKEN": (r"(\[.*?\])\s*\1{3,}", "Repeated bracketed tokens"),
59 |             "DEVIANCE_TEMP_PATH": (r"/tmp/|/var/tmp/", "Suspicious temporary path found"),
   |

S108 Probable insecure usage of temporary file or directory: "/tmp/|/var/tmp/"
  --> src\sentinel\wardens\huginn.py:59:36
   |
57 |             "HALLUCINATION_REPEATED_HEADER": (r"(#+ .*?\n)\1{2,}", "Repeated markdown headers detected"),
58 |             "HALLUCINATION_REPEATED_TOKEN": (r"(\[.*?\])\s*\1{3,}", "Repeated bracketed tokens"),
59 |             "DEVIANCE_TEMP_PATH": (r"/tmp/|/var/tmp/", "Suspicious temporary path found"),
   |                                    ^^^^^^^^^^^^^^^^^^
60 |             "DEVIANCE_USER_LEAK": (r"C:\\Users\\(?!Craig).*", "Potential user path leak detected")
61 |         }
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\wardens\huginn.py:78:13
   |
76 |                             "line": content.count("\n", 0, match.start()) + 1
77 |                         })
78 |             except Exception: pass
   |             ^^^^^^^^^^^^^^^^^^^^^^
79 |         return targets
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\huginn.py:78:29
   |
76 |                             "line": content.count("\n", 0, match.start()) + 1
77 |                         })
78 |             except Exception: pass
   |                             ^
79 |         return targets
   |

E501 Line too long (104 > 100)
  --> src\sentinel\wardens\huginn.py:85:101
   |
83 |         try:
84 |             content = trace_file.read_text(encoding='utf-8')
85 |             # Truncate if too long for Flash context (though Flash has huge context, let's be safe/fast)
   |                                                                                                     ^^^^
86 |             if len(content) > 50000:
87 |                 content = content[-50000:]
   |

E501 Line too long (136 > 100)
  --> src\sentinel\wardens\huginn.py:90:101
   |
89 | â€¦
90 | â€¦e for subtle hallucinations, logical loops, or state deviance that regex might miss.
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
91 | â€¦
92 | â€¦repeating the same failed tool call.
   |

W293 Blank line contains whitespace
  --> src\sentinel\wardens\huginn.py:95:1
   |
93 |             2. The agent inventing file paths that likely don't exist.
94 |             3. The agent claiming to have fixed something but immediately seeing the same error.
95 |             
   | ^^^^^^^^^^^^
96 |             Return a JSON object with a list of "breaches". Each breach should have:
97 |             - description: What went wrong.
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\sentinel\wardens\huginn.py:99:1
    |
 97 |             - description: What went wrong.
 98 |             - confidence: 0.0 to 1.0 (Ignore anything below 0.8).
 99 |             
    | ^^^^^^^^^^^^
100 |             TRACE CONTENT:
101 |             {content}
    |
help: Remove whitespace from blank line

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\sentinel\wardens\huginn.py:126:9
    |
124 |                           })
125 |
126 | /         except Exception:
127 | |             pass
    | |________________^
128 |           return targets
    |

E501 Line too long (153 > 100)
  --> src\sentinel\wardens\mimir.py:41:101
   |
39 | â€¦     "type": "MIMIR_AESTHETIC_BREACH",
40 | â€¦     "file": rel_path,
41 | â€¦     "action": "Claustrophobic code block detected (>12 consecutive lines). Inject vertical whitespace for cognitive rhythm.",
   |                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 | â€¦     "line": line_idx + 1,
43 | â€¦     "severity": "MEDIUM"
   |

E501 Line too long (107 > 100)
  --> src\sentinel\wardens\mimir.py:60:101
   |
58 | â€¦                     if isinstance(child, (ast.Assign, ast.AnnAssign, ast.Assert)):
59 | â€¦                         setup_nodes += 1
60 | â€¦                     elif isinstance(child, (ast.For, ast.While, ast.Return, ast.Expr, ast.If)):
   |                                                                                           ^^^^^^^
61 | â€¦                         exec_nodes += 1
   |

E501 Line too long (165 > 100)
  --> src\sentinel\wardens\mimir.py:69:101
   |
67 | â€¦BREACH",
68 | â€¦
69 | â€¦e.name}' is top-heavy (Ratio: {ratio:.2f}). Extract setup/validation logic into helper functions.",
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 | â€¦
71 | â€¦
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\mimir.py:73:35
   |
71 |                                         "severity": "MEDIUM"
72 |                                     })
73 |                 except SyntaxError: pass
   |                                   ^
74 |
75 |                 # --- Original Mimir Checks ---
   |

E501 Line too long (106 > 100)
  --> src\sentinel\wardens\mimir.py:83:101
   |
81 | â€¦                     "type": "MIMIR_COMPLEXITY",
82 | â€¦                     "file": rel_path,
83 | â€¦                     "action": f"Untangle Threads: Simplify {block.name} (CC: {block.complexity})",
   |                                                                                               ^^^^^^
84 | â€¦                     "severity": "MEDIUM",
85 | â€¦                     "line": block.lineno
   |

E501 Line too long (128 > 100)
  --> src\sentinel\wardens\mimir.py:94:101
   |
92 | â€¦                     "type": "MIMIR_MAINTAINABILITY",
93 | â€¦                     "file": rel_path,
94 | â€¦                     "action": f"Restructure Saga: File Maintainability Index too low ({mi_score:.2f} < {mi_threshold})",
   |                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
95 | â€¦                     "severity": "MEDIUM",
96 | â€¦                     "line": 1
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\sentinel\wardens\mimir.py:99:13
    |
 97 |                           })
 98 |
 99 | /             except Exception:
100 | |                 pass
    | |____________________^
101 |           return targets
    |

E501 Line too long (108 > 100)
  --> src\sentinel\wardens\norn.py:28:101
   |
27 |         if target:
28 |             # Campaign tasks are treated as CRITICAL breaches because they are the user's primary directive.
   |                                                                                                     ^^^^^^^^
29 |             return [{
30 |                 "type": "CAMPAIGN_TASK",
   |

E501 Line too long (116 > 100)
  --> src\sentinel\wardens\norn.py:42:101
   |
40 |         """
41 |         Scans tasks.qmd for the first unchecked item '- [ ]'.
42 |         ignores indentation but preserves it in the action description if needed (though usually we just want text).
   |                                                                                                     ^^^^^^^^^^^^^^^^
43 |         """
44 |         if not self.plan_path.exists():
   |

ANN201 Missing return type annotation for public function `mark_complete`
  --> src\sentinel\wardens\norn.py:68:9
   |
66 |         return None
67 |
68 |     def mark_complete(self, target: dict[str, Any]):
   |         ^^^^^^^^^^^^^
69 |         """
70 |         Marks the action as complete by switching '[ ]' to '[x]'.
   |
help: Add return type annotation: `None`

E501 Line too long (125 > 100)
  --> src\sentinel\wardens\runecaster.py:26:101
   |
24 |                     if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
25 |                         # Check 1: Missing Argument Hints
26 |                         missing_arg = any(arg.annotation is None for arg in node.args.args if arg.arg not in ('self', 'cls'))
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
27 |                         missing_ret = node.returns is None
   |

E501 Line too long (111 > 100)
  --> src\sentinel\wardens\runecaster.py:35:101
   |
33 | â€¦                     "type": "RUNE_STRICT_INIT",
34 | â€¦                     "file": str(py_file.relative_to(self.root)),
35 | â€¦                     "action": f"Cast Strict Rune: __init__ must return -> None in {node.name}",
   |                                                                                       ^^^^^^^^^^^
36 | â€¦                     "severity": "LOW",
37 | â€¦                     "line": node.lineno
   |

E501 Line too long (115 > 100)
  --> src\sentinel\wardens\runecaster.py:49:101
   |
48 |                         # Check 2: Generic Type Enforcement (e.g., list vs list[str])
49 |                         # This is tricky with AST as we need to see if the annotation is a raw 'list', 'dict', etc.
   |                                                                                                     ^^^^^^^^^^^^^^^
50 |                         for arg in node.args.args:
51 |                             if arg.annotation:
   |

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\sentinel\wardens\runecaster.py:51:29
   |
49 |                           # This is tricky with AST as we need to see if the annotation is a raw 'list', 'dict', etc.
50 |                           for arg in node.args.args:
51 | /                             if arg.annotation:
52 | |                                 if isinstance(arg.annotation, ast.Name):
53 | |                                     if arg.annotation.id in ('list', 'dict', 'set', 'tuple'):
   | |_____________________________________________________________________________________________^
54 |                                           targets.append({
55 |                                               "type": "RUNE_WEAK_GENERIC",
   |
help: Combine `if` statements using `and`

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src\sentinel\wardens\runecaster.py:52:33
   |
50 |                           for arg in node.args.args:
51 |                               if arg.annotation:
52 | /                                 if isinstance(arg.annotation, ast.Name):
53 | |                                     if arg.annotation.id in ('list', 'dict', 'set', 'tuple'):
   | |_____________________________________________________________________________________________^
54 |                                           targets.append({
55 |                                               "type": "RUNE_WEAK_GENERIC",
   |
help: Combine `if` statements using `and`

E501 Line too long (164 > 100)
  --> src\sentinel\wardens\runecaster.py:57:101
   |
55 | â€¦     "type": "RUNE_WEAK_GENERIC",
56 | â€¦     "file": str(py_file.relative_to(self.root)),
57 | â€¦     "action": f"Strengthen Rune: Use generic {arg.annotation.id}[T] instead of raw {arg.annotation.id} for arg '{arg.arg}'",
   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 | â€¦     "severity": "LOW",
59 | â€¦     "line": node.lineno
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\wardens\runecaster.py:61:13
   |
59 |                                             "line": node.lineno
60 |                                         })
61 |             except Exception: pass
   |             ^^^^^^^^^^^^^^^^^^^^^^
62 |         return targets
   |

E701 Multiple statements on one line (colon)
  --> src\sentinel\wardens\runecaster.py:61:29
   |
59 |                                             "line": node.lineno
60 |                                         })
61 |             except Exception: pass
   |                             ^
62 |         return targets
   |

E501 Line too long (115 > 100)
  --> src\sentinel\wardens\valkyrie.py:54:101
   |
52 |                     "type": "VALKYRIE_BREACH",
53 |                     "file": rel_path,
54 |                     "action": f"Prune Dead Code: {item.message} at line {lineno} (Confidence: {item.confidence}%)",
   |                                                                                                     ^^^^^^^^^^^^^^^
55 |                     "severity": "LOW",
56 |                     "line": lineno
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\sentinel\wardens\valkyrie.py:58:9
   |
56 |                       "line": lineno
57 |                   })
58 | /         except Exception:
59 | |             pass
   | |________________^
60 |           return targets
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:9:13
   |
 8 | # Resolve shared UI from src/core/
 9 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |             ^^^^^^^^^^^^
10 | sys.path.insert(0, _core_dir)
11 | from ui import HUD
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\install_skill.py:9:26
   |
 8 | # Resolve shared UI from src/core/
 9 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                          ^^^^^^^^^^^^^^^
10 | sys.path.insert(0, _core_dir)
11 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\install_skill.py:9:42
   |
 8 | # Resolve shared UI from src/core/
 9 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                          ^^^^^^^^^^^^^^^
10 | sys.path.insert(0, _core_dir)
11 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\skills\install_skill.py:9:58
   |
 8 | # Resolve shared UI from src/core/
 9 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                                          ^^^^^^^^^^^^^^^
10 | sys.path.insert(0, _core_dir)
11 | from ui import HUD
   |
help: Replace with `Path(...).resolve()`

E402 Module level import not at top of file
  --> src\skills\install_skill.py:11:1
   |
 9 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
10 | sys.path.insert(0, _core_dir)
11 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
   |

ANN202 Missing return type annotation for private function `_sanitize_skill_name`
  --> src\skills\install_skill.py:14:5
   |
14 | def _sanitize_skill_name(name):
   |     ^^^^^^^^^^^^^^^^^^^^
15 |     """Rejects names with illegal characters or path traversal attempts."""
16 |     if not re.match(r'^[a-zA-Z0-9_-]+$', name):
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `name`
  --> src\skills\install_skill.py:14:26
   |
14 | def _sanitize_skill_name(name):
   |                          ^^^^
15 |     """Rejects names with illegal characters or path traversal attempts."""
16 |     if not re.match(r'^[a-zA-Z0-9_-]+$', name):
   |

ANN202 Missing return type annotation for private function `_validate_path`
  --> src\skills\install_skill.py:20:5
   |
18 |     return name
19 |
20 | def _validate_path(base, target):
   |     ^^^^^^^^^^^^^^
21 |     try:
22 |         b, t = os.path.realpath(base), os.path.realpath(target)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `base`
  --> src\skills\install_skill.py:20:20
   |
18 |     return name
19 |
20 | def _validate_path(base, target):
   |                    ^^^^
21 |     try:
22 |         b, t = os.path.realpath(base), os.path.realpath(target)
   |

ANN001 Missing type annotation for function argument `target`
  --> src\skills\install_skill.py:20:26
   |
18 |     return name
19 |
20 | def _validate_path(base, target):
   |                          ^^^^^^
21 |     try:
22 |         b, t = os.path.realpath(base), os.path.realpath(target)
   |

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:24:33
   |
22 |         b, t = os.path.realpath(base), os.path.realpath(target)
23 |         return os.path.commonpath([b, t]) == b
24 |     except (ValueError, OSError): return False
   |                                 ^
25 |
26 | def _get_config(base_path):
   |

ANN202 Missing return type annotation for private function `_get_config`
  --> src\skills\install_skill.py:26:5
   |
24 |     except (ValueError, OSError): return False
25 |
26 | def _get_config(base_path):
   |     ^^^^^^^^^^^
27 |     path = os.path.join(base_path, "config.json")
28 |     try:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `base_path`
  --> src\skills\install_skill.py:26:17
   |
24 |     except (ValueError, OSError): return False
25 |
26 | def _get_config(base_path):
   |                 ^^^^^^^^^
27 |     path = os.path.join(base_path, "config.json")
28 |     try:
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:27:12
   |
26 | def _get_config(base_path):
27 |     path = os.path.join(base_path, "config.json")
   |            ^^^^^^^^^^^^
28 |     try:
29 |         with open(path, 'r', encoding='utf-8') as f: return json.load(f), None
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\skills\install_skill.py:29:14
   |
27 |     path = os.path.join(base_path, "config.json")
28 |     try:
29 |         with open(path, 'r', encoding='utf-8') as f: return json.load(f), None
   |              ^^^^
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\skills\install_skill.py:29:25
   |
27 |     path = os.path.join(base_path, "config.json")
28 |     try:
29 |         with open(path, 'r', encoding='utf-8') as f: return json.load(f), None
   |                         ^^^
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
   |
help: Remove mode argument

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:29:52
   |
27 |     path = os.path.join(base_path, "config.json")
28 |     try:
29 |         with open(path, 'r', encoding='utf-8') as f: return json.load(f), None
   |                                                    ^
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
   |

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:30:26
   |
28 |     try:
29 |         with open(path, 'r', encoding='utf-8') as f: return json.load(f), None
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
   |                          ^
31 |
32 | def _verify_integrity(quarantine_zone):
   |

ANN202 Missing return type annotation for private function `_verify_integrity`
  --> src\skills\install_skill.py:32:5
   |
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
31 |
32 | def _verify_integrity(quarantine_zone):
   |     ^^^^^^^^^^^^^^^^^
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `quarantine_zone`
  --> src\skills\install_skill.py:32:23
   |
30 |     except Exception as e: return None, f"Config Error: {str(e)[:30]}"
31 |
32 | def _verify_integrity(quarantine_zone):
   |                       ^^^^^^^^^^^^^^^
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:33:11
   |
32 | def _verify_integrity(quarantine_zone):
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
   |           ^^^^^^^^^^^^
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:34:10
   |
32 | def _verify_integrity(quarantine_zone):
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
   |          ^^^^^^^^^^^^
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:35:8
   |
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
   |        ^^^^^^^^^^^^^^
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |
help: Replace with `Path(...).exists()`

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\skills\install_skill.py:35:32
   |
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
   |                                ^^^^^^^^^^^^^^^
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |
help: Replace with `Path(...).stat().st_size`

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:35:56
   |
33 |     qmd = os.path.join(quarantine_zone, "SKILL.qmd")
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
   |                                                        ^
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:36:8
   |
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
   |        ^^^^^^^^^^^^^^
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |
help: Replace with `Path(...).exists()`

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\skills\install_skill.py:36:31
   |
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
   |                               ^^^^^^^^^^^^^^^
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |
help: Replace with `Path(...).stat().st_size`

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:36:54
   |
34 |     md = os.path.join(quarantine_zone, "SKILL.md")
35 |     if os.path.exists(qmd) and os.path.getsize(qmd) > 0: return True, None
36 |     if os.path.exists(md) and os.path.getsize(md) > 0: return True, None
   |                                                      ^
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
   |

ANN202 Missing return type annotation for private function `_run_security_scan`
  --> src\skills\install_skill.py:39:5
   |
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
38 |
39 | def _run_security_scan(quarantine_zone):
   |     ^^^^^^^^^^^^^^^^^^
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `quarantine_zone`
  --> src\skills\install_skill.py:39:24
   |
37 |     return False, "Missing/empty SKILL metadata (.qmd or .md)"
38 |
39 | def _run_security_scan(quarantine_zone):
   |                        ^^^^^^^^^^^^^^^
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:40:15
   |
39 | def _run_security_scan(quarantine_zone):
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
   |               ^^^^^^^^^^^^
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\install_skill.py:40:28
   |
39 | def _run_security_scan(quarantine_zone):
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
   |                            ^^^^^^^^^^^^^^^
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |
help: Replace with `Path(...).parent`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:41:12
   |
39 | def _run_security_scan(quarantine_zone):
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |            ^^^^^^^^^^^^^^
42 |     
43 |     threat = 0
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:41:35
   |
39 | def _run_security_scan(quarantine_zone):
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
   |                                   ^
42 |     
43 |     threat = 0
   |

W293 [*] Blank line contains whitespace
  --> src\skills\install_skill.py:42:1
   |
40 |     scanner = os.path.join(os.path.dirname(__file__), "security_scan.py")
41 |     if not os.path.exists(scanner): return -1, "Scanner missing"
42 |     
   | ^^^^
43 |     threat = 0
44 |     for root, _, files in os.walk(quarantine_zone):
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\skills\install_skill.py:47:23
   |
45 |         for f in [f for f in files if f.endswith((".py", ".qmd", ".md"))]:
46 |             try:
47 |                 res = subprocess.run([sys.executable, scanner, os.path.join(root, f)], capture_output=True, timeout=15)
   |                       ^^^^^^^^^^^^^^
48 |                 threat = max(threat, res.returncode)
49 |                 if res.stdout: print(res.stdout.decode('utf-8', errors='ignore'))
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:47:64
   |
45 |         for f in [f for f in files if f.endswith((".py", ".qmd", ".md"))]:
46 |             try:
47 |                 res = subprocess.run([sys.executable, scanner, os.path.join(root, f)], capture_output=True, timeout=15)
   |                                                                ^^^^^^^^^^^^
48 |                 threat = max(threat, res.returncode)
49 |                 if res.stdout: print(res.stdout.decode('utf-8', errors='ignore'))
   |

E501 Line too long (119 > 100)
  --> src\skills\install_skill.py:47:101
   |
45 |         for f in [f for f in files if f.endswith((".py", ".qmd", ".md"))]:
46 |             try:
47 |                 res = subprocess.run([sys.executable, scanner, os.path.join(root, f)], capture_output=True, timeout=15)
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^
48 |                 threat = max(threat, res.returncode)
49 |                 if res.stdout: print(res.stdout.decode('utf-8', errors='ignore'))
   |

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:49:30
   |
47 |                 res = subprocess.run([sys.executable, scanner, os.path.join(root, f)], capture_output=True, timeout=15)
48 |                 threat = max(threat, res.returncode)
49 |                 if res.stdout: print(res.stdout.decode('utf-8', errors='ignore'))
   |                              ^
50 |             except (subprocess.SubprocessError, OSError): threat = max(threat, 1)
51 |     return threat, None
   |

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:50:57
   |
48 |                 threat = max(threat, res.returncode)
49 |                 if res.stdout: print(res.stdout.decode('utf-8', errors='ignore'))
50 |             except (subprocess.SubprocessError, OSError): threat = max(threat, 1)
   |                                                         ^
51 |     return threat, None
   |

ANN202 Missing return type annotation for private function `_promote_skill`
  --> src\skills\install_skill.py:53:5
   |
51 |     return threat, None
52 |
53 | def _promote_skill(quarantine, dest):
   |     ^^^^^^^^^^^^^^
54 |     """Securely move skill from quarantine to final destination."""
55 |     try:
   |
help: Add return type annotation: `bool | None`

ANN001 Missing type annotation for function argument `quarantine`
  --> src\skills\install_skill.py:53:20
   |
51 |     return threat, None
52 |
53 | def _promote_skill(quarantine, dest):
   |                    ^^^^^^^^^^
54 |     """Securely move skill from quarantine to final destination."""
55 |     try:
   |

ANN001 Missing type annotation for function argument `dest`
  --> src\skills\install_skill.py:53:32
   |
51 |     return threat, None
52 |
53 | def _promote_skill(quarantine, dest):
   |                                ^^^^
54 |     """Securely move skill from quarantine to final destination."""
55 |     try:
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:56:12
   |
54 |     """Securely move skill from quarantine to final destination."""
55 |     try:
56 |         if os.path.exists(dest): shutil.rmtree(dest)
   |            ^^^^^^^^^^^^^^
57 |         shutil.move(quarantine, dest)
58 |         return True
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:56:32
   |
54 |     """Securely move skill from quarantine to final destination."""
55 |     try:
56 |         if os.path.exists(dest): shutil.rmtree(dest)
   |                                ^
57 |         shutil.move(quarantine, dest)
58 |         return True
   |

ANN201 Missing return type annotation for public function `install_skill`
  --> src\skills\install_skill.py:63:5
   |
61 |         return False
62 |
63 | def install_skill(skill_name, target_root=None):
   |     ^^^^^^^^^^^^^
64 |     """
65 |     [ALFRED] Refactored skill installer with isolated sub-phases and path validation.
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `skill_name`
  --> src\skills\install_skill.py:63:19
   |
61 |         return False
62 |
63 | def install_skill(skill_name, target_root=None):
   |                   ^^^^^^^^^^
64 |     """
65 |     [ALFRED] Refactored skill installer with isolated sub-phases and path validation.
   |

ANN001 Missing type annotation for function argument `target_root`
  --> src\skills\install_skill.py:63:31
   |
61 |         return False
62 |
63 | def install_skill(skill_name, target_root=None):
   |                               ^^^^^^^^^^^
64 |     """
65 |     [ALFRED] Refactored skill installer with isolated sub-phases and path validation.
   |

W293 Blank line contains whitespace
  --> src\skills\install_skill.py:66:1
   |
64 |     """
65 |     [ALFRED] Refactored skill installer with isolated sub-phases and path validation.
66 |     
   | ^^^^
67 |     Args:
68 |         skill_name: The slug of the skill to install from the global registry.
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\skills\install_skill.py:70:1
   |
68 |         skill_name: The slug of the skill to install from the global registry.
69 |         target_root: Optional override for the project root.
70 |         
   | ^^^^^^^^
71 |     Phases:
72 |         1. Pre-install: Sanitize name and verify config.
   |
help: Remove whitespace from blank line

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\install_skill.py:79:27
   |
77 |     """
78 |     name = _sanitize_skill_name(skill_name)
79 |     base = target_root or os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                           ^^^^^^^^^^^^^^^
80 |     config, err = _get_config(base)
81 |     if not name or err or not config.get("FrameworkRoot"):
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\install_skill.py:79:43
   |
77 |     """
78 |     name = _sanitize_skill_name(skill_name)
79 |     base = target_root or os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                                           ^^^^^^^^^^^^^^^
80 |     config, err = _get_config(base)
81 |     if not name or err or not config.get("FrameworkRoot"):
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\skills\install_skill.py:79:59
   |
77 |     """
78 |     name = _sanitize_skill_name(skill_name)
79 |     base = target_root or os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                                                           ^^^^^^^^^^^^^^^
80 |     config, err = _get_config(base)
81 |     if not name or err or not config.get("FrameworkRoot"):
   |
help: Replace with `Path(...).resolve()`

E702 Multiple statements on one line (semicolon)
  --> src\skills\install_skill.py:82:68
   |
80 |     config, err = _get_config(base)
81 |     if not name or err or not config.get("FrameworkRoot"):
82 |         HUD.log("FAIL", "Pre-install Check", err or "Invalid Name"); return
   |                                                                    ^
83 |
84 |     src = os.path.join(config["FrameworkRoot"], "skills_db", name)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:84:11
   |
82 |         HUD.log("FAIL", "Pre-install Check", err or "Invalid Name"); return
83 |
84 |     src = os.path.join(config["FrameworkRoot"], "skills_db", name)
   |           ^^^^^^^^^^^^
85 |     qua = os.path.join(base, "quarantine", name)
86 |     dst = os.path.join(base, "skills", name)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:85:11
   |
84 |     src = os.path.join(config["FrameworkRoot"], "skills_db", name)
85 |     qua = os.path.join(base, "quarantine", name)
   |           ^^^^^^^^^^^^
86 |     dst = os.path.join(base, "skills", name)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\install_skill.py:86:11
   |
84 |     src = os.path.join(config["FrameworkRoot"], "skills_db", name)
85 |     qua = os.path.join(base, "quarantine", name)
86 |     dst = os.path.join(base, "skills", name)
   |           ^^^^^^^^^^^^
87 |
88 |     if not all(_validate_path(base if "db" not in p[0] else config["FrameworkRoot"], p[1]) for p in [(src, src), (base, qua), (base, dâ€¦
   |

E501 Line too long (140 > 100)
  --> src\skills\install_skill.py:88:101
   |
86 | â€¦
87 | â€¦
88 | â€¦ else config["FrameworkRoot"], p[1]) for p in [(src, src), (base, qua), (base, dst)]):
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 | â€¦
   |

E702 Multiple statements on one line (semicolon)
  --> src\skills\install_skill.py:89:46
   |
88 |     if not all(_validate_path(base if "db" not in p[0] else config["FrameworkRoot"], p[1]) for p in [(src, src), (base, qua), (base, dâ€¦
89 |         HUD.log("CRITICAL", "Path Violation"); return
   |                                              ^
90 |
91 |     if os.path.exists(dst): 
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:91:8
   |
89 |         HUD.log("CRITICAL", "Path Violation"); return
90 |
91 |     if os.path.exists(dst): 
   |        ^^^^^^^^^^^^^^
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
93 |     if not os.path.exists(src): 
   |
help: Replace with `Path(...).exists()`

W291 [*] Trailing whitespace
  --> src\skills\install_skill.py:91:28
   |
89 |         HUD.log("CRITICAL", "Path Violation"); return
90 |
91 |     if os.path.exists(dst): 
   |                            ^
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
93 |     if not os.path.exists(src): 
   |
help: Remove trailing whitespace

E702 Multiple statements on one line (semicolon)
  --> src\skills\install_skill.py:92:62
   |
91 |     if os.path.exists(dst): 
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
   |                                                              ^
93 |     if not os.path.exists(src): 
94 |         HUD.log("FAIL", f"Skill '{name}' not found"); return
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:93:12
   |
91 |     if os.path.exists(dst): 
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
93 |     if not os.path.exists(src): 
   |            ^^^^^^^^^^^^^^
94 |         HUD.log("FAIL", f"Skill '{name}' not found"); return
   |
help: Replace with `Path(...).exists()`

W291 [*] Trailing whitespace
  --> src\skills\install_skill.py:93:32
   |
91 |     if os.path.exists(dst): 
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
93 |     if not os.path.exists(src): 
   |                                ^
94 |         HUD.log("FAIL", f"Skill '{name}' not found"); return
   |
help: Remove trailing whitespace

E702 Multiple statements on one line (semicolon)
  --> src\skills\install_skill.py:94:53
   |
92 |         HUD.log("INFO", f"Skill '{name}' already installed."); return
93 |     if not os.path.exists(src): 
94 |         HUD.log("FAIL", f"Skill '{name}' not found"); return
   |                                                     ^
95 |     
96 |     try:
   |

W293 [*] Blank line contains whitespace
  --> src\skills\install_skill.py:95:1
   |
93 |     if not os.path.exists(src): 
94 |         HUD.log("FAIL", f"Skill '{name}' not found"); return
95 |     
   | ^^^^
96 |     try:
97 |         if os.path.exists(qua): shutil.rmtree(qua)
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\install_skill.py:97:12
   |
96 |     try:
97 |         if os.path.exists(qua): shutil.rmtree(qua)
   |            ^^^^^^^^^^^^^^
98 |         shutil.copytree(src, qua)
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\skills\install_skill.py:97:31
   |
96 |     try:
97 |         if os.path.exists(qua): shutil.rmtree(qua)
   |                               ^
98 |         shutil.copytree(src, qua)
   |

W293 [*] Blank line contains whitespace
   --> src\skills\install_skill.py:99:1
    |
 97 |         if os.path.exists(qua): shutil.rmtree(qua)
 98 |         shutil.copytree(src, qua)
 99 |         
    | ^^^^^^^^
100 |         ok, i_err = _verify_integrity(qua)
101 |         if not ok: HUD.log("FAIL", i_err); shutil.rmtree(qua); return
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:101:18
    |
100 |         ok, i_err = _verify_integrity(qua)
101 |         if not ok: HUD.log("FAIL", i_err); shutil.rmtree(qua); return
    |                  ^
102 |
103 |         threat, s_err = _run_security_scan(qua)
    |

E702 Multiple statements on one line (semicolon)
   --> src\skills\install_skill.py:101:42
    |
100 |         ok, i_err = _verify_integrity(qua)
101 |         if not ok: HUD.log("FAIL", i_err); shutil.rmtree(qua); return
    |                                          ^
102 |
103 |         threat, s_err = _run_security_scan(qua)
    |

E702 Multiple statements on one line (semicolon)
   --> src\skills\install_skill.py:101:62
    |
100 |         ok, i_err = _verify_integrity(qua)
101 |         if not ok: HUD.log("FAIL", i_err); shutil.rmtree(qua); return
    |                                                              ^
102 |
103 |         threat, s_err = _run_security_scan(qua)
    |

RUF059 Unpacked variable `s_err` is never used
   --> src\skills\install_skill.py:103:17
    |
101 |         if not ok: HUD.log("FAIL", i_err); shutil.rmtree(qua); return
102 |
103 |         threat, s_err = _run_security_scan(qua)
    |                 ^^^^^
104 |         if threat >= 2: HUD.log("CRITICAL", "BLOCKED: Security Threat"); shutil.rmtree(qua); return
105 |         if threat == 1:
    |
help: Prefix it with an underscore or any other dummy variable pattern

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:104:23
    |
103 |         threat, s_err = _run_security_scan(qua)
104 |         if threat >= 2: HUD.log("CRITICAL", "BLOCKED: Security Threat"); shutil.rmtree(qua); return
    |                       ^
105 |         if threat == 1:
106 |             if input(f"{HUD.CYAN}>> Proceed with Warning? [y/N]: {HUD.RESET}").lower() != 'y':
    |

E702 Multiple statements on one line (semicolon)
   --> src\skills\install_skill.py:104:72
    |
103 |         threat, s_err = _run_security_scan(qua)
104 |         if threat >= 2: HUD.log("CRITICAL", "BLOCKED: Security Threat"); shutil.rmtree(qua); return
    |                                                                        ^
105 |         if threat == 1:
106 |             if input(f"{HUD.CYAN}>> Proceed with Warning? [y/N]: {HUD.RESET}").lower() != 'y':
    |

E702 Multiple statements on one line (semicolon)
   --> src\skills\install_skill.py:104:92
    |
103 |         threat, s_err = _run_security_scan(qua)
104 |         if threat >= 2: HUD.log("CRITICAL", "BLOCKED: Security Threat"); shutil.rmtree(qua); return
    |                                                                                            ^
105 |         if threat == 1:
106 |             if input(f"{HUD.CYAN}>> Proceed with Warning? [y/N]: {HUD.RESET}").lower() != 'y':
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\skills\install_skill.py:105:9
    |
103 |           threat, s_err = _run_security_scan(qua)
104 |           if threat >= 2: HUD.log("CRITICAL", "BLOCKED: Security Threat"); shutil.rmtree(qua); return
105 | /         if threat == 1:
106 | |             if input(f"{HUD.CYAN}>> Proceed with Warning? [y/N]: {HUD.RESET}").lower() != 'y':
    | |______________________________________________________________________________________________^
107 |                   shutil.rmtree(qua); return
    |
help: Combine `if` statements using `and`

E702 Multiple statements on one line (semicolon)
   --> src\skills\install_skill.py:107:35
    |
105 |         if threat == 1:
106 |             if input(f"{HUD.CYAN}>> Proceed with Warning? [y/N]: {HUD.RESET}").lower() != 'y':
107 |                 shutil.rmtree(qua); return
    |                                   ^
108 |
109 |         if _promote_skill(qua, dst): HUD.log("PASS", f"Skill '{name}' deployed.")
    |

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:109:36
    |
107 |                 shutil.rmtree(qua); return
108 |
109 |         if _promote_skill(qua, dst): HUD.log("PASS", f"Skill '{name}' deployed.")
    |                                    ^
110 |     except Exception as e:
111 |         HUD.log("FAIL", f"Install Crash: {str(e)[:40]}")
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\skills\install_skill.py:112:12
    |
110 |     except Exception as e:
111 |         HUD.log("FAIL", f"Install Crash: {str(e)[:40]}")
112 |         if os.path.exists(qua): shutil.rmtree(qua)
    |            ^^^^^^^^^^^^^^
113 |
114 | if __name__ == "__main__":
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:112:31
    |
110 |     except Exception as e:
111 |         HUD.log("FAIL", f"Install Crash: {str(e)[:40]}")
112 |         if os.path.exists(qua): shutil.rmtree(qua)
    |                               ^
113 |
114 | if __name__ == "__main__":
    |

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:115:25
    |
114 | if __name__ == "__main__":
115 |     if len(sys.argv) > 1: install_skill(sys.argv[1])
    |                         ^
116 |     else: print("Usage: python install_skill.py <skill>")
    |

E701 Multiple statements on one line (colon)
   --> src\skills\install_skill.py:116:9
    |
114 | if __name__ == "__main__":
115 |     if len(sys.argv) > 1: install_skill(sys.argv[1])
116 |     else: print("Usage: python install_skill.py <skill>")
    |         ^
    |

I001 [*] Import block is un-sorted or un-formatted
  --> src\skills\local\KnowledgeHunter\hunter.py:7:1
   |
 5 |   """
 6 |
 7 | / import os
 8 | | import sys
 9 | | import re
10 | | from pathlib import Path
   | |________________________^
11 |
12 |   # [ALFRED] Ensure environment is loaded
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> src\skills\local\KnowledgeHunter\hunter.py:21:1
   |
19 |       pass # Fallback
20 |
21 | / from google import genai
22 | | from src.tools.brave_search import BraveSearch
23 | | from src.core.ui import HUD
   | |___________________________^
24 |
25 |   class KnowledgeHunter:
   |
help: Organize imports

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:31:1
   |
29 |             HUD.persona_log("ERROR", "GOOGLE_API_KEY not found.")
30 |             sys.exit(1)
31 |             
   | ^^^^^^^^^^^^
32 |         self.client = genai.Client(api_key=self.api_key)
33 |         self.searcher = BraveSearch()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:35:1
   |
33 |         self.searcher = BraveSearch()
34 |         self.root = Path(__file__).parent.parent.parent.parent.parent.resolve() # CorvusStar root
35 |         
   | ^^^^^^^^
36 |     def hunt(self, topic: str):
37 |         HUD.persona_log("INFO", f"Hunting for knowledge on: {topic}...")
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `hunt`
  --> src\skills\local\KnowledgeHunter\hunter.py:36:9
   |
34 |         self.root = Path(__file__).parent.parent.parent.parent.parent.resolve() # CorvusStar root
35 |         
36 |     def hunt(self, topic: str):
   |         ^^^^
37 |         HUD.persona_log("INFO", f"Hunting for knowledge on: {topic}...")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:38:1
   |
36 |     def hunt(self, topic: str):
37 |         HUD.persona_log("INFO", f"Hunting for knowledge on: {topic}...")
38 |         
   | ^^^^^^^^
39 |         # Step 1: Brave Search
40 |         HUD.persona_log("INFO", "Deploying Brave Search spiders...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:42:1
   |
40 |         HUD.persona_log("INFO", "Deploying Brave Search spiders...")
41 |         results = self.searcher.search(topic)
42 |         
   | ^^^^^^^^
43 |         if not results:
44 |             HUD.persona_log("WARN", "The spiders returned empty-handed.")
   |
help: Remove whitespace from blank line

E501 Line too long (106 > 100)
  --> src\skills\local\KnowledgeHunter\hunter.py:50:101
   |
48 |         snippets = ""
49 |         for i, res in enumerate(results):
50 |             snippets += f"[{i+1}] {res.get('title')}\n{res.get('description')}\nURL: {res.get('url')}\n\n"
   |                                                                                                     ^^^^^^
51 |             
52 |         HUD.persona_log("INFO", f"Captured {len(results)} snippets. Synthesizing...")
   |

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:51:1
   |
49 |         for i, res in enumerate(results):
50 |             snippets += f"[{i+1}] {res.get('title')}\n{res.get('description')}\nURL: {res.get('url')}\n\n"
51 |             
   | ^^^^^^^^^^^^
52 |         HUD.persona_log("INFO", f"Captured {len(results)} snippets. Synthesizing...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:53:1
   |
52 |         HUD.persona_log("INFO", f"Captured {len(results)} snippets. Synthesizing...")
53 |         
   | ^^^^^^^^
54 |         # Step 3: Gemini Synthesis
55 |         prompt = f"""You are O.D.I.N.'s Knowledge Hunter. 
   |
help: Remove whitespace from blank line

W291 Trailing whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:55:54
   |
54 |         # Step 3: Gemini Synthesis
55 |         prompt = f"""You are O.D.I.N.'s Knowledge Hunter. 
   |                                                      ^
56 |         Synthesize the following web search results into a comprehensive, professional Markdown report.
   |
help: Remove trailing whitespace

E501 Line too long (103 > 100)
  --> src\skills\local\KnowledgeHunter\hunter.py:56:101
   |
54 |         # Step 3: Gemini Synthesis
55 |         prompt = f"""You are O.D.I.N.'s Knowledge Hunter. 
56 |         Synthesize the following web search results into a comprehensive, professional Markdown report.
   |                                                                                                     ^^^
57 |         
58 |         Topic: {topic}
   |

W293 Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:57:1
   |
55 |         prompt = f"""You are O.D.I.N.'s Knowledge Hunter. 
56 |         Synthesize the following web search results into a comprehensive, professional Markdown report.
57 |         
   | ^^^^^^^^
58 |         Topic: {topic}
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:59:1
   |
58 |         Topic: {topic}
59 |         
   | ^^^^^^^^
60 |         Search Results:
61 |         {snippets}
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:62:1
   |
60 |         Search Results:
61 |         {snippets}
62 |         
   | ^^^^^^^^
63 |         Format:
64 |         - Title
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:70:1
   |
68 |         - Sources (Link to URLs)
69 |         """
70 |         
   | ^^^^^^^^
71 |         try:
72 |             response = self.client.models.generate_content(
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:77:1
   |
75 |             )
76 |             report_content = response.text
77 |             
   | ^^^^^^^^^^^^
78 |             # Step 4: Save Report
79 |             slug = re.sub(r'[^a-z0-9]+', '_', topic.lower()).strip('_')
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:82:1
   |
80 |             filename = f"RESEARCH_{slug}.md"
81 |             filepath = self.root / filename
82 |             
   | ^^^^^^^^^^^^
83 |             filepath.write_text(report_content, encoding='utf-8')
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:84:1
   |
83 |             filepath.write_text(report_content, encoding='utf-8')
84 |             
   | ^^^^^^^^^^^^
85 |             HUD.persona_log("SUCCESS", f"Knowledge synthesized: {filename}")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:86:1
   |
85 |             HUD.persona_log("SUCCESS", f"Knowledge synthesized: {filename}")
86 |             
   | ^^^^^^^^^^^^
87 |         except Exception as e:
88 |             HUD.persona_log("ERROR", f"Synthesis failed: {e}")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\KnowledgeHunter\hunter.py:94:1
   |
92 |         print("Usage: python hunter.py <topic>")
93 |         sys.exit(1)
94 |         
   | ^^^^^^^^
95 |     topic = " ".join(sys.argv[1:])
96 |     hunter = KnowledgeHunter()
   |
help: Remove whitespace from blank line

F401 [*] `json` imported but unused
  --> src\skills\local\drafts\workflow_backup_sequence_steps_gen\backup_sequence_steps.py:9:8
   |
 8 | import argparse
 9 | import json
   |        ^^^^
10 | import sys
   |
help: Remove unused import: `json`

F401 [*] `sys` imported but unused
  --> src\skills\local\drafts\workflow_backup_sequence_steps_gen\backup_sequence_steps.py:10:8
   |
 8 | import argparse
 9 | import json
10 | import sys
   |        ^^^
   |
help: Remove unused import: `sys`

ANN201 Missing return type annotation for public function `main`
  --> src\skills\local\drafts\workflow_backup_sequence_steps_gen\backup_sequence_steps.py:13:5
   |
13 | def main():
   |     ^^^^
14 |     parser = argparse.ArgumentParser(description="backup_sequence_steps workflow")
15 |     parser.add_argument("--input", required=True, help="Input file or directory")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\skills\local\drafts\workflow_backup_sequence_steps_gen\backup_sequence_steps.py:18:1
   |
16 |     parser.add_argument("--dry-run", action="store_true", help="Preview without changes")
17 |     args = parser.parse_args()
18 |     
   | ^^^^
19 |     print(f"[STEP 1] Loading {args.input}...")
   |
help: Remove whitespace from blank line

F401 [*] `sys` imported but unused
 --> src\skills\local\workflow-analyst\analyze_workflow.py:5:8
  |
3 | import os
4 | import re
5 | import sys
  |        ^^^
6 | from collections import Counter
  |
help: Remove unused import: `sys`

ANN001 Missing type annotation for function argument `root_dir`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:10:24
   |
 9 | class WorkflowAnalyst:
10 |     def __init__(self, root_dir) -> None:
   |                        ^^^^^^^^
11 |         self.root = root_dir
12 |         self.tasks_path = os.path.join(root_dir, "tasks.md")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\local\workflow-analyst\analyze_workflow.py:12:27
   |
10 |     def __init__(self, root_dir) -> None:
11 |         self.root = root_dir
12 |         self.tasks_path = os.path.join(root_dir, "tasks.md")
   |                           ^^^^^^^^^^^^
13 |         self.journal_path = os.path.join(root_dir, "dev_journal.md")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\local\workflow-analyst\analyze_workflow.py:13:29
   |
11 |         self.root = root_dir
12 |         self.tasks_path = os.path.join(root_dir, "tasks.md")
13 |         self.journal_path = os.path.join(root_dir, "dev_journal.md")
   |                             ^^^^^^^^^^^^
14 |
15 |     def analyze(self):
   |

ANN201 Missing return type annotation for public function `analyze`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:15:9
   |
13 |         self.journal_path = os.path.join(root_dir, "dev_journal.md")
14 |
15 |     def analyze(self):
   |         ^^^^^^^
16 |         report = {
17 |             "stalled_tasks": [], # [/] items
   |
help: Add return type annotation

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:24:12
   |
23 |         # 1. Analyze Tasks
24 |         if os.path.exists(self.tasks_path):
   |            ^^^^^^^^^^^^^^
25 |             with open(self.tasks_path, 'r', encoding='utf-8') as f:
26 |                 lines = f.readlines()
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:25:18
   |
23 |         # 1. Analyze Tasks
24 |         if os.path.exists(self.tasks_path):
25 |             with open(self.tasks_path, 'r', encoding='utf-8') as f:
   |                  ^^^^
26 |                 lines = f.readlines()
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\skills\local\workflow-analyst\analyze_workflow.py:25:40
   |
23 |         # 1. Analyze Tasks
24 |         if os.path.exists(self.tasks_path):
25 |             with open(self.tasks_path, 'r', encoding='utf-8') as f:
   |                                        ^^^
26 |                 lines = f.readlines()
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:27:1
   |
25 |             with open(self.tasks_path, 'r', encoding='utf-8') as f:
26 |                 lines = f.readlines()
27 |             
   | ^^^^^^^^^^^^
28 |             for line in lines:
29 |                 clean_line = line.strip()
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:36:12
   |
35 |         # 2. Analyze Journal (Pattern Recognition)
36 |         if os.path.exists(self.journal_path):
   |            ^^^^^^^^^^^^^^
37 |             with open(self.journal_path, 'r', encoding='utf-8') as f:
38 |                 journal_content = f.read().lower()
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:37:18
   |
35 |         # 2. Analyze Journal (Pattern Recognition)
36 |         if os.path.exists(self.journal_path):
37 |             with open(self.journal_path, 'r', encoding='utf-8') as f:
   |                  ^^^^
38 |                 journal_content = f.read().lower()
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\skills\local\workflow-analyst\analyze_workflow.py:37:42
   |
35 |         # 2. Analyze Journal (Pattern Recognition)
36 |         if os.path.exists(self.journal_path):
37 |             with open(self.journal_path, 'r', encoding='utf-8') as f:
   |                                          ^^^
38 |                 journal_content = f.read().lower()
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:39:1
   |
37 |             with open(self.journal_path, 'r', encoding='utf-8') as f:
38 |                 journal_content = f.read().lower()
39 |             
   | ^^^^^^^^^^^^
40 |             # Simple keyword frequency analysis for "pain words"
41 |             pain_keywords = ["manual", "fix", "error", "fail", "slow", "refactor", "broken"]
   |
help: Remove whitespace from blank line

F841 Local variable `found_pain` is assigned to but never used
  --> src\skills\local\workflow-analyst\analyze_workflow.py:42:13
   |
40 |             # Simple keyword frequency analysis for "pain words"
41 |             pain_keywords = ["manual", "fix", "error", "fail", "slow", "refactor", "broken"]
42 |             found_pain = [word for word in pain_keywords if word in journal_content]
   |             ^^^^^^^^^^
43 |             
44 |             # Count occurrences
   |
help: Remove assignment to unused variable `found_pain`

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:43:1
   |
41 |             pain_keywords = ["manual", "fix", "error", "fail", "slow", "refactor", "broken"]
42 |             found_pain = [word for word in pain_keywords if word in journal_content]
43 |             
   | ^^^^^^^^^^^^
44 |             # Count occurrences
45 |             word_counts = Counter(re.findall(r'\b\w+\b', journal_content))
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:47:1
   |
45 |             word_counts = Counter(re.findall(r'\b\w+\b', journal_content))
46 |             common = word_counts.most_common(20)
47 |             
   | ^^^^^^^^^^^^
48 |             # Filter for interesting actionable words
49 |             for word, count in common:
   |
help: Remove whitespace from blank line

E501 Line too long (101 > 100)
  --> src\skills\local\workflow-analyst\analyze_workflow.py:51:101
   |
49 |             for word, count in common:
50 |                 if word in pain_keywords:
51 |                     report["recurring_patterns"].append(f"High frequency of '{word}': {count} times")
   |                                                                                                     ^
52 |
53 |         # 3. Generate Suggestions
   |

E501 Line too long (134 > 100)
  --> src\skills\local\workflow-analyst\analyze_workflow.py:55:101
   |
53 |         # 3. Generate Suggestions
54 |         if len(report["stalled_tasks"]) > 0:
55 |             report["suggestions"].append("CRITICAL: You have tasks explicitly marked 'In Progress' ([/]). Finish them or Reset them.")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |         
57 |         if len(report["open_loops"]) > 5:
   |

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:56:1
   |
54 |         if len(report["stalled_tasks"]) > 0:
55 |             report["suggestions"].append("CRITICAL: You have tasks explicitly marked 'In Progress' ([/]). Finish them or Reset them.")
56 |         
   | ^^^^^^^^
57 |         if len(report["open_loops"]) > 5:
58 |             report["suggestions"].append("WARNING: Too many open loops. Close 3 tasks before opening new ones.")
   |
help: Remove whitespace from blank line

E501 Line too long (112 > 100)
  --> src\skills\local\workflow-analyst\analyze_workflow.py:58:101
   |
57 |         if len(report["open_loops"]) > 5:
58 |             report["suggestions"].append("WARNING: Too many open loops. Close 3 tasks before opening new ones.")
   |                                                                                                     ^^^^^^^^^^^^
59 |
60 |         return report
   |

ANN201 Missing return type annotation for public function `main`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:62:5
   |
60 |         return report
61 |
62 | def main():
   |     ^^^^
63 |     root = os.getcwd()
64 |     analyst = WorkflowAnalyst(root)
   |
help: Add return type annotation: `None`

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> src\skills\local\workflow-analyst\analyze_workflow.py:63:12
   |
62 | def main():
63 |     root = os.getcwd()
   |            ^^^^^^^^^
64 |     analyst = WorkflowAnalyst(root)
65 |     report = analyst.analyze()
   |
help: Replace with `Path.cwd()`

W293 [*] Blank line contains whitespace
  --> src\skills\local\workflow-analyst\analyze_workflow.py:66:1
   |
64 |     analyst = WorkflowAnalyst(root)
65 |     report = analyst.analyze()
66 |     
   | ^^^^
67 |     print(json.dumps(report, indent=2))
   |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
  --> src\skills\local\workflow-analyst\analyze_workflow.py:70:11
   |
69 | if __name__ == "__main__":
70 |     main()
   |           ^
   |
help: Add trailing newline

F401 [*] `json` imported but unused
  --> src\skills\skill_forge.py:10:8
   |
 8 | """
 9 |
10 | import json
   |        ^^^^
11 | import os
12 | import py_compile
   |
help: Remove unused import: `json`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\skill_forge.py:20:13
   |
19 | # Ensure shared UI and Engine can be imported
20 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |             ^^^^^^^^^^^^
21 | _engine_dir = os.path.join(_core_dir, "engine")
22 | sys.path.insert(0, _core_dir)
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\skill_forge.py:20:26
   |
19 | # Ensure shared UI and Engine can be imported
20 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                          ^^^^^^^^^^^^^^^
21 | _engine_dir = os.path.join(_core_dir, "engine")
22 | sys.path.insert(0, _core_dir)
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\skills\skill_forge.py:20:42
   |
19 | # Ensure shared UI and Engine can be imported
20 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                          ^^^^^^^^^^^^^^^
21 | _engine_dir = os.path.join(_core_dir, "engine")
22 | sys.path.insert(0, _core_dir)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\skills\skill_forge.py:20:58
   |
19 | # Ensure shared UI and Engine can be imported
20 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                                          ^^^^^^^^^^^^^^^
21 | _engine_dir = os.path.join(_core_dir, "engine")
22 | sys.path.insert(0, _core_dir)
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\skill_forge.py:21:15
   |
19 | # Ensure shared UI and Engine can be imported
20 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
21 | _engine_dir = os.path.join(_core_dir, "engine")
   |               ^^^^^^^^^^^^
22 | sys.path.insert(0, _core_dir)
23 | sys.path.insert(0, _engine_dir)
   |

E402 Module level import not at top of file
  --> src\skills\skill_forge.py:25:1
   |
23 | sys.path.insert(0, _engine_dir)
24 |
25 | from cortex import Cortex
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
26 | from ui import HUD
27 | from src.tools.brave_search import BraveSearch  # [BIFRÃ–ST]
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\skills\skill_forge.py:25:1
   |
23 |   sys.path.insert(0, _engine_dir)
24 |
25 | / from cortex import Cortex
26 | | from ui import HUD
27 | | from src.tools.brave_search import BraveSearch  # [BIFRÃ–ST]
   | |______________________________________________^
28 |
29 |   class SkillForge:
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\skills\skill_forge.py:26:1
   |
25 | from cortex import Cortex
26 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
27 | from src.tools.brave_search import BraveSearch  # [BIFRÃ–ST]
   |

E402 Module level import not at top of file
  --> src\skills\skill_forge.py:27:1
   |
25 | from cortex import Cortex
26 | from ui import HUD
27 | from src.tools.brave_search import BraveSearch  # [BIFRÃ–ST]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |
29 | class SkillForge:
   |

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:34:1
   |
32 |     Uses RAG (Cortex) to identify patterns and map them to standard archetypes.
33 |     """
34 |     
   | ^^^^
35 |     ARCHETYPES = {
36 |         "test": {
   |
help: Remove whitespace from blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\skills\skill_forge.py:35:18
   |
33 |       """
34 |       
35 |       ARCHETYPES = {
   |  __________________^
36 | |         "test": {
37 | |             "triggers": ["test", "verify", "check", "validate", "assert", "ensure"],
38 | |             "imports": ["pytest", "unittest"],
39 | |             "template": "test"
40 | |         },
41 | |         "workflow": {
42 | |             "triggers": ["automate", "chain", "sequence", "batch", "pipeline", "orchestrate"],
43 | |             "imports": ["argparse", "json"],
44 | |             "template": "workflow"
45 | |         },
46 | |         "utility": {
47 | |             "triggers": ["parse", "convert", "analyze", "extract", "transform", "process"],
48 | |             "imports": ["json", "re", "os"],
49 | |             "template": "utility"
50 | |         },
51 | |         "scanner": {
52 | |             "triggers": ["scan", "audit", "lint", "check", "inspect"],
53 | |             "imports": ["ast", "pathlib"],
54 | |             "template": "scanner"
55 | |         },
56 | |         "scraper": {
57 | |             "triggers": ["scrape", "crawl", "fetch", "web", "html", "parse"],
58 | |             "imports": ["requests", "bs4"],
59 | |             "template": "scraper"
60 | |         }
61 | |     }
   | |_____^
62 |       
63 |       DANGEROUS_PATTERNS = [
   |

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:62:1
   |
60 |         }
61 |     }
62 |     
   | ^^^^
63 |     DANGEROUS_PATTERNS = [
64 |         r'\beval\s*\(',
   |
help: Remove whitespace from blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\skills\skill_forge.py:63:26
   |
61 |       }
62 |       
63 |       DANGEROUS_PATTERNS = [
   |  __________________________^
64 | |         r'\beval\s*\(',
65 | |         r'\bexec\s*\(',
66 | |         r'__import__\s*\(',
67 | |         r'subprocess\.(?:run|call|Popen|check_output)',
68 | |         r'os\.system\s*\(',
69 | |         r'os\.popen\s*\(',
70 | |         r'pickle\.loads?\s*\(',
71 | |     ]
   | |_____^
72 |       
73 |       def __init__(self, project_root: str) -> None:
   |

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:72:1
   |
70 |         r'pickle\.loads?\s*\(',
71 |     ]
72 |     
   | ^^^^
73 |     def __init__(self, project_root: str) -> None:
74 |         self.project_root = project_root
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\skill_forge.py:75:25
   |
73 |     def __init__(self, project_root: str) -> None:
74 |         self.project_root = project_root
75 |         self.base_dir = os.path.join(project_root, ".agent")
   |                         ^^^^^^^^^^^^
76 |         self.drafts_dir = os.path.join(self.base_dir, "skills", "drafts")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\skills\skill_forge.py:76:27
   |
74 |         self.project_root = project_root
75 |         self.base_dir = os.path.join(project_root, ".agent")
76 |         self.drafts_dir = os.path.join(self.base_dir, "skills", "drafts")
   |                           ^^^^^^^^^^^^
77 |         
78 |         # Initialize Cortex for RAG
   |

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:77:1
   |
75 |         self.base_dir = os.path.join(project_root, ".agent")
76 |         self.drafts_dir = os.path.join(self.base_dir, "skills", "drafts")
77 |         
   | ^^^^^^^^
78 |         # Initialize Cortex for RAG
79 |         self.cortex = Cortex(project_root, self.base_dir)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:80:1
   |
78 |         # Initialize Cortex for RAG
79 |         self.cortex = Cortex(project_root, self.base_dir)
80 |         
   | ^^^^^^^^
81 |         # Ensure drafts directory exists
82 |         Path(self.drafts_dir).mkdir(parents=True, exist_ok=True)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:83:1
   |
81 |         # Ensure drafts directory exists
82 |         Path(self.drafts_dir).mkdir(parents=True, exist_ok=True)
83 |     
   | ^^^^
84 |     def forge(self, query: str, dry_run: bool = False) -> dict:
85 |         """
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\skills\skill_forge.py:87:1
   |
85 |         """
86 |         [ALFRED] Orchestrates the multi-phase skill creation protocol.
87 |         
   | ^^^^^^^^
88 |         Args:
89 |             query: The user's natural language request (e.g., 'create a log parser').
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\skills\skill_forge.py:91:1
   |
89 |             query: The user's natural language request (e.g., 'create a log parser').
90 |             dry_run: If True, provides a preview of the generated code without saving.
91 |             
   | ^^^^^^^^^^^^
92 |         Returns:
93 |             A dictionary containing 'success', 'code', 'archetype', and 'path'.
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\skills\skill_forge.py:96:1
   |
94 |         """
95 |         HUD.box_top("SKILL FORGE: IGNITION")
96 |         
   | ^^^^^^^^
97 |         if not query or not query.strip():
98 |             HUD.box_row("ERROR", "Query required", HUD.RED)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:101:1
    |
 99 |             HUD.box_bottom()
100 |             return {"success": False, "code": "", "validation": "Query required"}
101 |         
    | ^^^^^^^^
102 |         # Step 1: Analyze pattern via RAG
103 |         HUD.box_row("PHASE 1", "Analyzing pattern...", HUD.CYAN)
    |
help: Remove whitespace from blank line

F841 [*] Local variable `e` is assigned to but never used
   --> src\skills\skill_forge.py:106:29
    |
104 |         try:
105 |             context = self.analyze_pattern(query)
106 |         except Exception as e:
    |                             ^
107 |             HUD.box_row("ERROR", "RAG Analysis Failed", HUD.RED)
108 |             context = []
    |
help: Remove assignment to unused variable `e`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:112:1
    |
110 |         if not context:
111 |             HUD.box_row("WARN", "No Context Found (Proceeding with Defaults)", HUD.YELLOW)
112 |         
    | ^^^^^^^^
113 |         # Step 2: Select archetype
114 |         HUD.box_row("PHASE 2", "Selecting archetype...", HUD.CYAN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:117:1
    |
115 |         archetype = self.select_archetype(query, context)
116 |         HUD.box_row("ARCHETYPE", archetype.upper(), HUD.GREEN)
117 |         
    | ^^^^^^^^
118 |         # Step 3: Extract subject from query
119 |         subject = self._extract_subject(query)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:121:1
    |
119 |         subject = self._extract_subject(query)
120 |         HUD.box_row("SUBJECT", subject, HUD.GREEN)
121 |         
    | ^^^^^^^^
122 |         # Step 4: Synthesize code
123 |         HUD.box_row("PHASE 3", "Synthesizing code...", HUD.CYAN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:125:1
    |
123 |         HUD.box_row("PHASE 3", "Synthesizing code...", HUD.CYAN)
124 |         code = self.synthesize_skill(subject, archetype, context)
125 |         
    | ^^^^^^^^
126 |         # Step 5: Validate
127 |         HUD.box_row("PHASE 4", "Validating...", HUD.CYAN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:129:1
    |
127 |         HUD.box_row("PHASE 4", "Validating...", HUD.CYAN)
128 |         is_valid, validation_msg = self.validate_skill(code)
129 |         
    | ^^^^^^^^
130 |         if not is_valid:
131 |             HUD.box_row("REJECTED", validation_msg, HUD.RED)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:134:1
    |
132 |             HUD.box_bottom()
133 |             return {"success": False, "code": code, "validation": validation_msg}
134 |         
    | ^^^^^^^^
135 |         HUD.box_row("VALIDATED", "All checks passed", HUD.GREEN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:136:1
    |
135 |         HUD.box_row("VALIDATED", "All checks passed", HUD.GREEN)
136 |         
    | ^^^^^^^^
137 |         # Step 6: Save (unless dry-run)
138 |         output_path = None
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:144:1
    |
142 |         else:
143 |             HUD.box_row("DRY-RUN", "Preview only, not saved", HUD.YELLOW)
144 |         
    | ^^^^^^^^
145 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:146:1
    |
145 |         HUD.box_bottom()
146 |         
    | ^^^^^^^^
147 |         return {
148 |             "success": True,
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:154:1
    |
152 |             "validation": validation_msg
153 |         }
154 |     
    | ^^^^
155 |     def analyze_pattern(self, query: str) -> list[dict]:
156 |         results = self.cortex.query(query)
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:159:32
    |
157 |         context = []
158 |         for r in results[:5]:  # Top 5 matches
159 |             if r['score'] < 0.2: continue
    |                                ^
160 |             trigger = r['trigger']
161 |             parts = trigger.split(' > ', 1)
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:171:1
    |
169 |                 "score": round(r['score'], 3)
170 |             })
171 |         
    | ^^^^^^^^
172 |         # [BIFRÃ–ST] Web-RAG: Fetch documentation for external libraries
173 |         libraries = ["aws", "fastapi", "boto3", "requests", "flask", "django", "pytorch", "tensorflow", "pandas"]
    |
help: Remove whitespace from blank line

E501 Line too long (113 > 100)
   --> src\skills\skill_forge.py:173:101
    |
172 |         # [BIFRÃ–ST] Web-RAG: Fetch documentation for external libraries
173 |         libraries = ["aws", "fastapi", "boto3", "requests", "flask", "django", "pytorch", "tensorflow", "pandas"]
    |                                                                                                     ^^^^^^^^^^^^^
174 |         for lib in libraries:
175 |             if lib in query.lower():
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:189:1
    |
188 |         return context
189 |     
    | ^^^^
190 |     def select_archetype(self, query: str, context: list[dict]) -> str:
191 |         query_lower = query.lower()
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:194:42
    |
192 |         for archetype, config in self.ARCHETYPES.items():
193 |             for trigger in config["triggers"]:
194 |                 if trigger in query_lower: return archetype
    |                                          ^
195 |         context_text = " ".join(c["content"] for c in context).lower()
196 |         for archetype, config in self.ARCHETYPES.items():
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:198:43
    |
196 |         for archetype, config in self.ARCHETYPES.items():
197 |             for trigger in config["triggers"]:
198 |                 if trigger in context_text: return archetype
    |                                           ^
199 |         return "utility"
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:200:1
    |
198 |                 if trigger in context_text: return archetype
199 |         return "utility"
200 |     
    | ^^^^
201 |     def _extract_subject(self, query: str) -> str:
202 |         stripped = re.sub(r'^(create|make|build|generate|write|test|a|an|the)\s+', '', query.lower())
    |
help: Remove whitespace from blank line

E501 Line too long (101 > 100)
   --> src\skills\skill_forge.py:202:101
    |
201 |     def _extract_subject(self, query: str) -> str:
202 |         stripped = re.sub(r'^(create|make|build|generate|write|test|a|an|the)\s+', '', query.lower())
    |                                                                                                     ^
203 |         stripped = re.sub(r'\s+(for|to|from|with)\s+', ' ', stripped)
204 |         # Filter out 'test' as it's often a meta-instruction, not the subject itself
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:206:21
    |
204 |         # Filter out 'test' as it's often a meta-instruction, not the subject itself
205 |         words = [w for w in stripped.split() if len(w) > 2 and w != 'test']
206 |         if not words: return "generated"
    |                     ^
207 |         subject = "_".join(words[-3:])
208 |         subject = re.sub(r'[^a-z0-9_]', '_', subject)
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:210:47
    |
208 |         subject = re.sub(r'[^a-z0-9_]', '_', subject)
209 |         subject = re.sub(r'_+', '_', subject).strip('_')
210 |         if not subject or subject[0].isdigit(): subject = f"skill_{subject}"
    |                                               ^
211 |         return subject
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:212:1
    |
210 |         if not subject or subject[0].isdigit(): subject = f"skill_{subject}"
211 |         return subject
212 |     
    | ^^^^
213 |     def _generate_workflow_steps(self, context: list[dict]) -> list[str]:
214 |         steps = []
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:218:21
    |
216 |             # Look for common step patterns in the RAG content
217 |             found = re.findall(r'(?:Step \d+:?|(?:\d+\.))\s*([^\n.]+)', c['content'])
218 |             if found: steps.extend(found)
    |                     ^
219 |         return list(dict.fromkeys(steps))[:5] # Deduplicate and limit
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\skills\skill_forge.py:221:90
    |
219 |         return list(dict.fromkeys(steps))[:5] # Deduplicate and limit
220 |
221 |     def _generate_workflow_template(self, name: str, context: str, imports: list, steps: list[str] = None) -> str:
    |                                                                                          ^^^^^^^^^
222 |         logic = ""
223 |         if steps:
    |
help: Convert to `T | None`

E501 Line too long (114 > 100)
   --> src\skills\skill_forge.py:221:101
    |
219 |         return list(dict.fromkeys(steps))[:5] # Deduplicate and limit
220 |
221 |     def _generate_workflow_template(self, name: str, context: str, imports: list, steps: list[str] = None) -> str:
    |                                                                                                     ^^^^^^^^^^^^^^
222 |         logic = ""
223 |         if steps:
    |

F541 [*] f-string without any placeholders
   --> src\skills\skill_forge.py:227:21
    |
225 |                 logic += f'    print(f"[STEP {i}] {step.strip()}...")\n'
226 |         else:
227 |             logic = f'    print(f"[STEP 1] Loading {{args.input}}...")\n'
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
228 |             
229 |         return f'''# DRAFT - REQUIRES REVIEW
    |
help: Remove extraneous `f` prefix

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:228:1
    |
226 |         else:
227 |             logic = f'    print(f"[STEP 1] Loading {{args.input}}...")\n'
228 |             
    | ^^^^^^^^^^^^
229 |         return f'''# DRAFT - REQUIRES REVIEW
230 | # Generated by Skill Forge at {datetime.now().isoformat()}
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\skills\skill_forge.py:245:1
    |
243 |     parser.add_argument("--dry-run", action="store_true", help="Preview without changes")
244 |     args = parser.parse_args()
245 |     
    | ^^^^
246 | {logic}
247 |     print("[DONE] Workflow complete.")
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\skills\skill_forge.py:267:1
    |
265 |     Test suite for {name}.
266 |     """
267 |     
    | ^^^^
268 |     def test_basic_functionality(self):
269 |         """Test basic operation."""
    |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
   --> src\skills\skill_forge.py:272:1
    |
270 |         # TODO: Implement test
271 |         assert True
272 |     
    | ^^^^
273 |     def test_edge_case_empty_input(self):
274 |         """Test behavior with empty input."""
    |
help: Remove whitespace from blank line

E501 Line too long (126 > 100)
   --> src\skills\skill_forge.py:387:101
    |
385 |         config = self.ARCHETYPES[archetype]
386 |         imports = config["imports"]
387 |         context_summary = "\n".join(f"    # Source: {c['source']} > {c['header']} (score: {c['score']})" for c in context[:3])
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
388 |         
389 |         if archetype == "test": return self._generate_test_template(name, context_summary, imports)
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:388:1
    |
386 |         imports = config["imports"]
387 |         context_summary = "\n".join(f"    # Source: {c['source']} > {c['header']} (score: {c['score']})" for c in context[:3])
388 |         
    | ^^^^^^^^
389 |         if archetype == "test": return self._generate_test_template(name, context_summary, imports)
390 |         elif archetype == "workflow": 
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:389:31
    |
387 |         context_summary = "\n".join(f"    # Source: {c['source']} > {c['header']} (score: {c['score']})" for c in context[:3])
388 |         
389 |         if archetype == "test": return self._generate_test_template(name, context_summary, imports)
    |                               ^
390 |         elif archetype == "workflow": 
391 |             steps = self._generate_workflow_steps(context)
    |

W291 [*] Trailing whitespace
   --> src\skills\skill_forge.py:390:38
    |
389 |         if archetype == "test": return self._generate_test_template(name, context_summary, imports)
390 |         elif archetype == "workflow": 
    |                                      ^
391 |             steps = self._generate_workflow_steps(context)
392 |             return self._generate_workflow_template(name, context_summary, imports, steps)
    |
help: Remove trailing whitespace

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:393:36
    |
391 |             steps = self._generate_workflow_steps(context)
392 |             return self._generate_workflow_template(name, context_summary, imports, steps)
393 |         elif archetype == "scanner": return self._generate_scanner_template(name, context_summary, imports)
    |                                    ^
394 |         elif archetype == "scraper": return self._generate_scraper_template(name, context_summary, imports)
395 |         else: return self._generate_utility_template(name, context_summary, imports)
    |

E501 Line too long (107 > 100)
   --> src\skills\skill_forge.py:393:101
    |
391 |             steps = self._generate_workflow_steps(context)
392 |             return self._generate_workflow_template(name, context_summary, imports, steps)
393 |         elif archetype == "scanner": return self._generate_scanner_template(name, context_summary, imports)
    |                                                                                                     ^^^^^^^
394 |         elif archetype == "scraper": return self._generate_scraper_template(name, context_summary, imports)
395 |         else: return self._generate_utility_template(name, context_summary, imports)
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:394:36
    |
392 |             return self._generate_workflow_template(name, context_summary, imports, steps)
393 |         elif archetype == "scanner": return self._generate_scanner_template(name, context_summary, imports)
394 |         elif archetype == "scraper": return self._generate_scraper_template(name, context_summary, imports)
    |                                    ^
395 |         else: return self._generate_utility_template(name, context_summary, imports)
    |

E501 Line too long (107 > 100)
   --> src\skills\skill_forge.py:394:101
    |
392 |             return self._generate_workflow_template(name, context_summary, imports, steps)
393 |         elif archetype == "scanner": return self._generate_scanner_template(name, context_summary, imports)
394 |         elif archetype == "scraper": return self._generate_scraper_template(name, context_summary, imports)
    |                                                                                                     ^^^^^^^
395 |         else: return self._generate_utility_template(name, context_summary, imports)
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:395:13
    |
393 |         elif archetype == "scanner": return self._generate_scanner_template(name, context_summary, imports)
394 |         elif archetype == "scraper": return self._generate_scraper_template(name, context_summary, imports)
395 |         else: return self._generate_utility_template(name, context_summary, imports)
    |             ^
396 |
397 |     def validate_skill(self, code: str) -> tuple[bool, str]:
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:399:40
    |
397 |     def validate_skill(self, code: str) -> tuple[bool, str]:
398 |         for pattern in self.DANGEROUS_PATTERNS:
399 |             if re.search(pattern, code): return False, f"Blocked dangerous pattern: {pattern}"
    |                                        ^
400 |         
401 |         temp_path = os.path.join(self.drafts_dir, ".validate_temp.py")
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:400:1
    |
398 |         for pattern in self.DANGEROUS_PATTERNS:
399 |             if re.search(pattern, code): return False, f"Blocked dangerous pattern: {pattern}"
400 |         
    | ^^^^^^^^
401 |         temp_path = os.path.join(self.drafts_dir, ".validate_temp.py")
402 |         try:
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\skills\skill_forge.py:401:21
    |
399 |             if re.search(pattern, code): return False, f"Blocked dangerous pattern: {pattern}"
400 |         
401 |         temp_path = os.path.join(self.drafts_dir, ".validate_temp.py")
    |                     ^^^^^^^^^^^^
402 |         try:
403 |             with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> src\skills\skill_forge.py:403:18
    |
401 |         temp_path = os.path.join(self.drafts_dir, ".validate_temp.py")
402 |         try:
403 |             with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |                  ^^^^
404 |             py_compile.compile(temp_path, doraise=True)
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
    |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:403:61
    |
401 |         temp_path = os.path.join(self.drafts_dir, ".validate_temp.py")
402 |         try:
403 |             with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |                                                             ^
404 |             py_compile.compile(temp_path, doraise=True)
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:405:46
    |
403 |             with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
404 |             py_compile.compile(temp_path, doraise=True)
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
    |                                              ^
406 |         finally:
407 |             if os.path.exists(temp_path): os.remove(temp_path)
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\skills\skill_forge.py:407:16
    |
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
406 |         finally:
407 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                ^^^^^^^^^^^^^^
408 |         
409 |         try:
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:407:41
    |
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
406 |         finally:
407 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                                         ^
408 |         
409 |         try:
    |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
   --> src\skills\skill_forge.py:407:43
    |
405 |         except py_compile.PyCompileError as e: return False, f"Syntax error: {e}"
406 |         finally:
407 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                                           ^^^^^^^^^
408 |         
409 |         try:
    |
help: Replace with `Path(...).unlink()`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:408:1
    |
406 |         finally:
407 |             if os.path.exists(temp_path): os.remove(temp_path)
408 |         
    | ^^^^^^^^
409 |         try:
410 |             with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\skills\skill_forge.py:410:18
    |
409 | â€¦     try:
410 | â€¦         with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |                ^^^^
411 | â€¦         subprocess.run([sys.executable, "-m", "ruff", "check", "--select=E,F", temp_path], capture_output=True, text=True, timeout=â€¦
412 | â€¦     except (subprocess.SubprocessError, OSError): pass
    |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:410:61
    |
409 | â€¦     try:
410 | â€¦         with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
    |                                                           ^
411 | â€¦         subprocess.run([sys.executable, "-m", "ruff", "check", "--select=E,F", temp_path], capture_output=True, text=True, timeout=â€¦
412 | â€¦     except (subprocess.SubprocessError, OSError): pass
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\skills\skill_forge.py:411:13
    |
409 | â€¦     try:
410 | â€¦         with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
411 | â€¦         subprocess.run([sys.executable, "-m", "ruff", "check", "--select=E,F", temp_path], capture_output=True, text=True, timeout=â€¦
    |           ^^^^^^^^^^^^^^
412 | â€¦     except (subprocess.SubprocessError, OSError): pass
413 | â€¦     finally:
    |

E501 Line too long (138 > 100)
   --> src\skills\skill_forge.py:411:101
    |
409 | â€¦
410 | â€¦') as f: f.write(code)
411 | â€¦ff", "check", "--select=E,F", temp_path], capture_output=True, text=True, timeout=10)
    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
412 | â€¦ pass
413 | â€¦
    |

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:412:53
    |
410 | â€¦         with open(temp_path, 'w', encoding='utf-8') as f: f.write(code)
411 | â€¦         subprocess.run([sys.executable, "-m", "ruff", "check", "--select=E,F", temp_path], capture_output=True, text=True, timeout=â€¦
412 | â€¦     except (subprocess.SubprocessError, OSError): pass
    |                                                   ^
413 | â€¦     finally:
414 | â€¦         if os.path.exists(temp_path): os.remove(temp_path)
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\skills\skill_forge.py:414:16
    |
412 |         except (subprocess.SubprocessError, OSError): pass
413 |         finally:
414 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                ^^^^^^^^^^^^^^
415 |         
416 |         return True, "All checks passed"
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:414:41
    |
412 |         except (subprocess.SubprocessError, OSError): pass
413 |         finally:
414 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                                         ^
415 |         
416 |         return True, "All checks passed"
    |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
   --> src\skills\skill_forge.py:414:43
    |
412 |         except (subprocess.SubprocessError, OSError): pass
413 |         finally:
414 |             if os.path.exists(temp_path): os.remove(temp_path)
    |                                           ^^^^^^^^^
415 |         
416 |         return True, "All checks passed"
    |
help: Replace with `Path(...).unlink()`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:415:1
    |
413 |         finally:
414 |             if os.path.exists(temp_path): os.remove(temp_path)
415 |         
    | ^^^^^^^^
416 |         return True, "All checks passed"
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\skills\skill_forge.py:420:22
    |
418 |     def _save_draft(self, subject: str, archetype: str, code: str) -> str:
419 |         base_name = f"{archetype}_{subject}_gen"
420 |         draft_path = os.path.join(self.drafts_dir, base_name)
    |                      ^^^^^^^^^^^^
421 |         os.makedirs(draft_path, exist_ok=True)
    |

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> src\skills\skill_forge.py:421:9
    |
419 |         base_name = f"{archetype}_{subject}_gen"
420 |         draft_path = os.path.join(self.drafts_dir, base_name)
421 |         os.makedirs(draft_path, exist_ok=True)
    |         ^^^^^^^^^^^
422 |         
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
    |
help: Replace with `Path(...).mkdir(parents=True)`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:422:1
    |
420 |         draft_path = os.path.join(self.drafts_dir, base_name)
421 |         os.makedirs(draft_path, exist_ok=True)
422 |         
    | ^^^^^^^^
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
424 |         with open(py_path, 'w', encoding='utf-8') as f: f.write(code)
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\skills\skill_forge.py:423:19
    |
421 |         os.makedirs(draft_path, exist_ok=True)
422 |         
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
    |                   ^^^^^^^^^^^^
424 |         with open(py_path, 'w', encoding='utf-8') as f: f.write(code)
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> src\skills\skill_forge.py:424:14
    |
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
424 |         with open(py_path, 'w', encoding='utf-8') as f: f.write(code)
    |              ^^^^
425 |         
426 |         # Target 302: Generate SKILL.qmd
    |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
   --> src\skills\skill_forge.py:424:55
    |
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
424 |         with open(py_path, 'w', encoding='utf-8') as f: f.write(code)
    |                                                       ^
425 |         
426 |         # Target 302: Generate SKILL.qmd
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:425:1
    |
423 |         py_path = os.path.join(draft_path, f"{subject}.py")
424 |         with open(py_path, 'w', encoding='utf-8') as f: f.write(code)
425 |         
    | ^^^^^^^^
426 |         # Target 302: Generate SKILL.qmd
427 |         md_content = f"""---
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\skills\skill_forge.py:439:14
    |
437 | This skill was synthesized by the Skill Forge from project documentation.
438 | """
439 |         with open(os.path.join(draft_path, "SKILL.qmd"), 'w', encoding='utf-8') as f:
    |              ^^^^
440 |             f.write(md_content)
    |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\skills\skill_forge.py:439:19
    |
437 | This skill was synthesized by the Skill Forge from project documentation.
438 | """
439 |         with open(os.path.join(draft_path, "SKILL.qmd"), 'w', encoding='utf-8') as f:
    |                   ^^^^^^^^^^^^
440 |             f.write(md_content)
    |

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:441:1
    |
439 |         with open(os.path.join(draft_path, "SKILL.qmd"), 'w', encoding='utf-8') as f:
440 |             f.write(md_content)
441 |             
    | ^^^^^^^^^^^^
442 |         return draft_path
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\skills\skill_forge.py:444:5
    |
442 |         return draft_path
443 |
444 | def main():
    |     ^^^^
445 |     import argparse
446 |     parser = argparse.ArgumentParser(description="Skill Forge: RAG-driven skill synthesis")
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:450:1
    |
448 |     parser.add_argument("--dry-run", action="store_true", help="Preview without saving")
449 |     args = parser.parse_args()
450 |     
    | ^^^^
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
    |
help: Remove whitespace from blank line

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\skills\skill_forge.py:451:18
    |
449 |     args = parser.parse_args()
450 |     
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
    |                  ^^^^^^^^^^^^^^^
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
    |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> src\skills\skill_forge.py:451:34
    |
449 |     args = parser.parse_args()
450 |     
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
    |                                  ^^^^^^^^^^^^^^^
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
    |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\skills\skill_forge.py:452:20
    |
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
    |                    ^^^^^^^^^^^^^^^
453 |     
454 |     forge = SkillForge(project_root)
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\skills\skill_forge.py:452:36
    |
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
    |                                    ^^^^^^^^^^^^^^^
453 |     
454 |     forge = SkillForge(project_root)
    |
help: Replace with `Path(...).parent`

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:453:1
    |
451 |     script_dir = os.path.dirname(os.path.abspath(__file__))
452 |     project_root = os.path.dirname(os.path.dirname(script_dir))
453 |     
    | ^^^^
454 |     forge = SkillForge(project_root)
455 |     result = forge.forge(args.query, dry_run=args.dry_run)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\skills\skill_forge.py:456:1
    |
454 |     forge = SkillForge(project_root)
455 |     result = forge.forge(args.query, dry_run=args.dry_run)
456 |     
    | ^^^^
457 |     if args.dry_run and result["success"]:
458 |         print("\n" + "="*60)
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\skills\skill_forge.py:464:11
    |
463 | if __name__ == "__main__":
464 |     main()
    |           ^
    |
help: Add trailing newline

F401 [*] `typing.Optional` imported but unused
  --> src\synapse\synapse_auth.py:13:20
   |
11 | import os
12 | import random
13 | from typing import Optional
   |                    ^^^^^^^^
   |
help: Remove unused import: `typing.Optional`

W293 [*] Blank line contains whitespace
  --> src\synapse\synapse_auth.py:18:1
   |
16 | class PersonaVerifier:
17 |     """[ALFRED] Secure persona verification using hashed challenge-response."""
18 |     
   | ^^^^
19 |     def __init__(self, config_path: str) -> None:
20 |         self.config_path = config_path
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\synapse\synapse_auth.py:24:12
   |
23 |     def _load_secret(self) -> str:
24 |         if os.path.exists(self.config_path):
   |            ^^^^^^^^^^^^^^
25 |             with open(self.config_path, 'r') as f:
26 |                 config = json.load(f)
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\synapse\synapse_auth.py:25:18
   |
23 |     def _load_secret(self) -> str:
24 |         if os.path.exists(self.config_path):
25 |             with open(self.config_path, 'r') as f:
   |                  ^^^^
26 |                 config = json.load(f)
27 |                 secret = config.get("security", {}).get("neural_secret")
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\synapse\synapse_auth.py:25:41
   |
23 |     def _load_secret(self) -> str:
24 |         if os.path.exists(self.config_path):
25 |             with open(self.config_path, 'r') as f:
   |                                         ^^^
26 |                 config = json.load(f)
27 |                 secret = config.get("security", {}).get("neural_secret")
   |
help: Remove mode argument

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\synapse\synapse_auth.py:34:24
   |
32 |         """Generate a random 32-char challenge string."""
33 |         chars = "abcdef0123456789"
34 |         return "".join(random.choice(chars) for _ in range(32))
   |                        ^^^^^^^^^^^^^^^^^^^^
35 |
36 |     def solve_challenge(self, challenge: str, persona: str) -> str:
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\synapse\synapse_auth.py:48:18
   |
46 | def authenticate_sync(persona: str) -> bool:
47 |     """[ALFRED] High-level authentication helper for synapse_sync."""
48 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                  ^^^^^^^^^^^^^^^
49 |     config_path = os.path.join(os.path.dirname(script_dir), "config.json")
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\synapse\synapse_auth.py:48:34
   |
46 | def authenticate_sync(persona: str) -> bool:
47 |     """[ALFRED] High-level authentication helper for synapse_sync."""
48 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                                  ^^^^^^^^^^^^^^^
49 |     config_path = os.path.join(os.path.dirname(script_dir), "config.json")
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\synapse\synapse_auth.py:49:19
   |
47 |     """[ALFRED] High-level authentication helper for synapse_sync."""
48 |     script_dir = os.path.dirname(os.path.abspath(__file__))
49 |     config_path = os.path.join(os.path.dirname(script_dir), "config.json")
   |                   ^^^^^^^^^^^^
50 |     
51 |     verifier = PersonaVerifier(config_path)
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\synapse\synapse_auth.py:49:32
   |
47 |     """[ALFRED] High-level authentication helper for synapse_sync."""
48 |     script_dir = os.path.dirname(os.path.abspath(__file__))
49 |     config_path = os.path.join(os.path.dirname(script_dir), "config.json")
   |                                ^^^^^^^^^^^^^^^
50 |     
51 |     verifier = PersonaVerifier(config_path)
   |
help: Replace with `Path(...).parent`

W293 [*] Blank line contains whitespace
  --> src\synapse\synapse_auth.py:50:1
   |
48 |     script_dir = os.path.dirname(os.path.abspath(__file__))
49 |     config_path = os.path.join(os.path.dirname(script_dir), "config.json")
50 |     
   | ^^^^
51 |     verifier = PersonaVerifier(config_path)
52 |     challenge = verifier.generate_challenge()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\synapse\synapse_auth.py:56:1
   |
54 |     # Here, we simulate a 'local handshake' for security hardening.
55 |     response = verifier.solve_challenge(challenge, persona)
56 |     
   | ^^^^
57 |     return verifier.verify_response(challenge, response, persona)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\synapse\synapse_auth.py:65:1
   |
63 |         print(f"AUTHENTICATED: {p}")
64 |         sys.exit(0)
65 |     
   | ^^^^
66 |     print(f"REJECTED: {p}")
67 |     sys.exit(1)
   |
help: Remove whitespace from blank line

F401 [*] `datetime.datetime` imported but unused
  --> src\synapse\synapse_sync.py:13:22
   |
11 | import sys
12 | import time
13 | from datetime import datetime
   |                      ^^^^^^^^
14 | from pathlib import Path
15 | from typing import Any, Dict, List, Optional, Tuple
   |
help: Remove unused import: `datetime.datetime`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\synapse\synapse_sync.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | # Import Shared UI
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src\synapse\synapse_sync.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | # Import Shared UI
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src\synapse\synapse_sync.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | # Import Shared UI
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\synapse\synapse_sync.py:42:24
   |
40 |             return "unknown"
41 |
42 |     def _load(self) -> Dict[str, Any]:
   |                        ^^^^
43 |         if self.path.exists():
44 |             try:
   |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
  --> src\synapse\synapse_sync.py:47:20
   |
45 |                 data = json.loads(self.path.read_text(encoding="utf-8"))
46 |                 return data.get(self.client_id, {"attempts": [], "locked_until": None})
47 |             except (json.JSONDecodeError, IOError):
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |                 pass
49 |         return {"attempts": [], "locked_until": None}
   |
help: Replace with builtin `OSError`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\synapse\synapse_sync.py:53:19
   |
51 |     def _save(self) -> None:
52 |         try:
53 |             full: Dict[str, Any] = {}
   |                   ^^^^
54 |             if self.path.exists():
55 |                 full = json.loads(self.path.read_text(encoding="utf-8"))
   |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
  --> src\synapse\synapse_sync.py:58:16
   |
56 |             full[self.client_id] = self.data
57 |             self.path.write_text(json.dumps(full, indent=2), encoding="utf-8")
58 |         except IOError:
   |                ^^^^^^^
59 |             pass
   |
help: Replace `IOError` with builtin `OSError`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src\synapse\synapse_sync.py:61:24
   |
59 |             pass
60 |
61 |     def check(self) -> Tuple[bool, str]:
   |                        ^^^^^
62 |         now = time.time()
63 |         locked_until = self.data.get("locked_until")
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\synapse\synapse_sync.py:91:25
   |
89 |         self.path = repo_path
90 |
91 |     def run(self, args: List[str]) -> Tuple[bool, str]:
   |                         ^^^^
92 |         try:
93 |             res = subprocess.run(
   |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src\synapse\synapse_sync.py:91:39
   |
89 |         self.path = repo_path
90 |
91 |     def run(self, args: List[str]) -> Tuple[bool, str]:
   |                                       ^^^^^
92 |         try:
93 |             res = subprocess.run(
   |
help: Replace with `tuple`

S603 `subprocess` call: check for execution of untrusted input
  --> src\synapse\synapse_sync.py:93:19
   |
91 |     def run(self, args: List[str]) -> Tuple[bool, str]:
92 |         try:
93 |             res = subprocess.run(
   |                   ^^^^^^^^^^^^^^
94 |                 ["git"] + args,
95 |                 cwd=self.path,
   |

RUF005 Consider `["git", *args]` instead of concatenation
  --> src\synapse\synapse_sync.py:94:17
   |
92 |         try:
93 |             res = subprocess.run(
94 |                 ["git"] + args,
   |                 ^^^^^^^^^^^^^^
95 |                 cwd=self.path,
96 |                 capture_output=True,
   |
help: Replace with `["git", *args]`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src\synapse\synapse_sync.py:106:36
    |
104 |             return False, "git operation failed"
105 |
106 |     def check_permissions(self) -> Tuple[bool, str]:
    |                                    ^^^^^
107 |         ok, _ = self.run(["rev-parse", "--is-inside-work-tree"])
108 |         if not ok:
    |
help: Replace with `tuple`

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:110:1
    |
108 |         if not ok:
109 |             return False, "Target is not a git repository"
110 |         
    | ^^^^^^^^
111 |         ok_rem, rems = self.run(["remote"])
112 |         if not ok_rem or not rems:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:114:1
    |
112 |         if not ok_rem or not rems:
113 |             return True, "Local-Only Mode"
114 |             
    | ^^^^^^^^^^^^
115 |         # Check connectivity
116 |         if not self.run(["ls-remote", "--exit-code", "-q"])[0]:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:118:1
    |
116 |         if not self.run(["ls-remote", "--exit-code", "-q"])[0]:
117 |             return False, "Remote origin unreachable"
118 |             
    | ^^^^^^^^^^^^
119 |         user_name = self.run(["config", "user.name"])[1] or "Unknown"
120 |         return True, user_name
    |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\synapse\synapse_sync.py:132:30
    |
130 |         self.trace_dir = agent_dir / "traces" / "processed"
131 |
132 |     def extract_all(self) -> List[Dict[str, Any]]:
    |                              ^^^^
133 |         """Aggregates all relevant local knowledge updates."""
134 |         return self._extract_corrections() + self._extract_patterns()
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:132:35
    |
130 |         self.trace_dir = agent_dir / "traces" / "processed"
131 |
132 |     def extract_all(self) -> List[Dict[str, Any]]:
    |                                   ^^^^
133 |         """Aggregates all relevant local knowledge updates."""
134 |         return self._extract_corrections() + self._extract_patterns()
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\synapse\synapse_sync.py:136:39
    |
134 |         return self._extract_corrections() + self._extract_patterns()
135 |
136 |     def _extract_corrections(self) -> List[Dict[str, Any]]:
    |                                       ^^^^
137 |         extracted: List[Dict[str, Any]] = []
138 |         if not self.corrections_path.exists():
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:136:44
    |
134 |         return self._extract_corrections() + self._extract_patterns()
135 |
136 |     def _extract_corrections(self) -> List[Dict[str, Any]]:
    |                                            ^^^^
137 |         extracted: List[Dict[str, Any]] = []
138 |         if not self.corrections_path.exists():
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\synapse\synapse_sync.py:137:20
    |
136 |     def _extract_corrections(self) -> List[Dict[str, Any]]:
137 |         extracted: List[Dict[str, Any]] = []
    |                    ^^^^
138 |         if not self.corrections_path.exists():
139 |             return []
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:137:25
    |
136 |     def _extract_corrections(self) -> List[Dict[str, Any]]:
137 |         extracted: List[Dict[str, Any]] = []
    |                         ^^^^
138 |         if not self.corrections_path.exists():
139 |             return []
    |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
   --> src\synapse\synapse_sync.py:152:16
    |
150 |                         "target": target
151 |                     })
152 |         except (json.JSONDecodeError, IOError):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153 |             pass
154 |         return extracted
    |
help: Replace with builtin `OSError`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\synapse\synapse_sync.py:156:36
    |
154 |         return extracted
155 |
156 |     def _extract_patterns(self) -> List[Dict[str, Any]]:
    |                                    ^^^^
157 |         if not self.trace_dir.exists():
158 |             return []
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:156:41
    |
154 |         return extracted
155 |
156 |     def _extract_patterns(self) -> List[Dict[str, Any]]:
    |                                         ^^^^
157 |         if not self.trace_dir.exists():
158 |             return []
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:159:19
    |
157 |         if not self.trace_dir.exists():
158 |             return []
159 |         patterns: Dict[str, int] = {}
    |                   ^^^^
160 |         try:
161 |             for f in self.trace_dir.glob("*.json"):
    |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:166:1
    |
164 |                 if query:
165 |                     patterns[query] = patterns.get(query, 0) + 1
166 |             
    | ^^^^^^^^^^^^
167 |             return [
168 |                 {"type": "pattern", "query": q, "freq": c}
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:185:1
    |
183 |         self.agent_dir = self.script_path.parent.parent
184 |         self.project_root = self.agent_dir.parent
185 |         
    | ^^^^^^^^
186 |         self.config = self._load_config()
187 |         legacy_persona = self.config.get("persona") or self.config.get("Persona") or "ALFRED"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:189:1
    |
187 |         legacy_persona = self.config.get("persona") or self.config.get("Persona") or "ALFRED"
188 |         self.persona = self.config.get("system", {}).get("persona", legacy_persona)
189 |         
    | ^^^^^^^^
190 |         self.core_path, self.core_name = self._resolve_core(remote_alias)
191 |         if not self.core_path or not self.core_path.exists():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:194:1
    |
192 |             HUD.log("FAIL", "Knowledge Core Unreachable", remote_alias)
193 |             sys.exit(1)
194 |             
    | ^^^^^^^^^^^^
195 |         self.git = GitHelper(self.core_path)
196 |         self.limiter = PushRateLimiter(self.core_path)
    |
help: Remove whitespace from blank line

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\synapse\synapse_sync.py:199:31
    |
197 |         self.extractor = KnowledgeExtractor(self.project_root, self.agent_dir)
198 |
199 |     def _load_config(self) -> Dict[str, Any]:
    |                               ^^^^
200 |         # [O.D.I.N.] Config is in .agent/config.json
201 |         config_path = self.project_root / ".agent" / "config.json"
    |
help: Replace with `dict`

UP024 [*] Replace aliased errors with `OSError`
   --> src\synapse\synapse_sync.py:205:20
    |
203 |             try:
204 |                 return json.loads(config_path.read_text(encoding="utf-8"))
205 |             except (json.JSONDecodeError, IOError):
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
206 |                 pass
207 |         return {}
    |
help: Replace with builtin `OSError`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src\synapse\synapse_sync.py:209:44
    |
207 |         return {}
208 |
209 |     def _resolve_core(self, alias: str) -> Tuple[Optional[Path], str]:
    |                                            ^^^^^
210 |         cores = self.config.get("knowledge", {}).get("cores", {})
211 |         if not cores:
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src\synapse\synapse_sync.py:209:50
    |
207 |         return {}
208 |
209 |     def _resolve_core(self, alias: str) -> Tuple[Optional[Path], str]:
    |                                                  ^^^^^^^^^^^^^^
210 |         cores = self.config.get("knowledge", {}).get("cores", {})
211 |         if not cores:
    |
help: Convert to `X | None`

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:213:1
    |
211 |         if not cores:
212 |             cores = self.config.get("KnowledgeCores", {})
213 |             
    | ^^^^^^^^^^^^
214 |         for name, path_str in cores.items():
215 |             if name.lower() == alias.lower():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:217:1
    |
215 |             if name.lower() == alias.lower():
216 |                 return Path(path_str), name
217 |         
    | ^^^^^^^^
218 |         legacy = self.config.get("KnowledgeCore")
219 |         if legacy:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:221:1
    |
219 |         if legacy:
220 |             return Path(legacy), "Legacy"
221 |             
    | ^^^^^^^^^^^^
222 |         return Path(alias), "Explicit"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:230:1
    |
228 |         """
229 |         HUD.box_top(f"SYNAPSE: PULL [{self.core_name}]")
230 |         
    | ^^^^^^^^
231 |         # Git updates
232 |         ok_rem, rems = self.git.run(["remote"])
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:236:1
    |
234 |             ok, _ = self.git.run(["pull"])
235 |             HUD.log("INFO", "Git Pull Successful" if ok else "Git Pull Failed")
236 |         
    | ^^^^^^^^
237 |         # Directory Sync
238 |         self._sync_skills()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:247:1
    |
245 |         if not src.exists():
246 |             return
247 |             
    | ^^^^^^^^^^^^
248 |         dst.mkdir(exist_ok=True)
249 |         added = 0
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:265:1
    |
263 |         if not c_file.exists():
264 |             return
265 |             
    | ^^^^^^^^^^^^
266 |         try:
267 |             c_data = json.loads(c_file.read_text(encoding="utf-8"))
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:269:1
    |
267 |             c_data = json.loads(c_file.read_text(encoding="utf-8"))
268 |             l_data = json.loads(l_file.read_text(encoding="utf-8"))
269 |             
    | ^^^^^^^^^^^^
270 |             c_mappings = c_data.get("phrase_mappings", {})
271 |             l_mappings = l_data.get("phrase_mappings", {})
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:272:1
    |
270 |             c_mappings = c_data.get("phrase_mappings", {})
271 |             l_mappings = l_data.get("phrase_mappings", {})
272 |             
    | ^^^^^^^^^^^^
273 |             added = 0
274 |             for k, v in c_mappings.items():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:278:1
    |
276 |                     l_mappings[k] = v
277 |                     added += 1
278 |             
    | ^^^^^^^^^^^^
279 |             if added:
280 |                 l_data["phrase_mappings"] = l_mappings
    |
help: Remove whitespace from blank line

UP024 [*] Replace aliased errors with `OSError`
   --> src\synapse\synapse_sync.py:283:16
    |
281 |                 l_file.write_text(json.dumps(l_data, indent=4), encoding="utf-8")
282 |                 HUD.log("PASS", f"Wisdom: {added} new mappings")
283 |         except (json.JSONDecodeError, IOError):
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
284 |             HUD.log("WARN", "Corrections sync failed (JSON Error)")
    |
help: Replace with builtin `OSError`

W293 Blank line contains whitespace
   --> src\synapse\synapse_sync.py:290:1
    |
288 |         [ALFRED] Pushes local knowledge increments to the Knowledge Core.
289 |         Includes authentication handshake, rate limiting, and Git-based export.
290 |         
    | ^^^^^^^^
291 |         Args:
292 |             dry_run: If True, simulates the harvest without performing the push.
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:295:1
    |
293 |         """
294 |         HUD.box_top(f"SYNAPSE: PUSH [{self.core_name}]")
295 |         
    | ^^^^^^^^
296 |         # Authenticate
297 |         try:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:312:1
    |
310 |                 HUD.box_bottom()
311 |                 return
312 |         
    | ^^^^^^^^
313 |         ok_perm, ident = self.git.check_permissions()
314 |         if not ok_perm:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:318:1
    |
316 |             HUD.box_bottom()
317 |             return
318 |             
    | ^^^^^^^^^^^^
319 |         HUD.log("INFO", "Identity Secured", f"{ident} ({self.persona})")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:320:1
    |
319 |         HUD.log("INFO", "Identity Secured", f"{ident} ({self.persona})")
320 |         
    | ^^^^^^^^
321 |         # Knowledge Harvesting
322 |         knowledge = self.extractor.extract_all()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:328:1
    |
326 |             HUD.log("PASS", f"Harvested {len(knowledge)} knowledge units")
327 |             # Logic for staging knowledge to Core would go here
328 |             
    | ^^^^^^^^^^^^
329 |         if dry_run:
330 |             HUD.log("INFO", "Dry run complete. No modifications made.")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:334:1
    |
332 |             self.limiter.record(True)
333 |             HUD.log("INFO", "Push sequence initialized.")
334 |             
    | ^^^^^^^^^^^^
335 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:348:1
    |
346 |     parser.add_argument("--all", action="store_true", help="Sync with all configured cores")
347 |     args = parser.parse_args()
348 |     
    | ^^^^
349 |     try:
350 |         if args.all:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:358:1
    |
356 |         else:
357 |             core_names = [args.remote]
358 |             
    | ^^^^^^^^^^^^
359 |         for name in core_names:
360 |             sync = Synapse(remote_alias=name)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\synapse\synapse_sync.py:365:1
    |
363 |             else:
364 |                 sync.pull()
365 |                 
    | ^^^^^^^^^^^^^^^^
366 |     except Exception as e:
367 |         HUD.log("FAIL", "Critical Error", str(e))
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\synapse\synapse_sync.py:372:11
    |
371 | if __name__ == "__main__":
372 |     main()
    |           ^
    |
help: Add trailing newline

W291 Trailing whitespace
 --> src\tools\archive_consolidator.py:7:79
  |
5 | Purpose: Tech-Debt Analysis & Target Isolation.
6 |
7 | Analyzes the history (Git churn) and current coverage, identifying weak points 
  |                                                                               ^
8 | by cross-referencing Complexity + Churn + Coverage.
  |
help: Remove trailing whitespace

F401 [*] `os` imported but unused
  --> src\tools\archive_consolidator.py:17:8
   |
15 | import json
16 | import logging
17 | import os
   |        ^^
18 | import subprocess
19 | import sys
   |
help: Remove unused import: `os`

E402 Module level import not at top of file
  --> src\tools\archive_consolidator.py:32:1
   |
30 |     sys.path.append(str(project_root))
31 |
32 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 | # Configure Logging
   |

W291 [*] Trailing whitespace
  --> src\tools\archive_consolidator.py:62:76
   |
60 |             complexity = 1
61 |             for node in ast.walk(tree):
62 |                 if isinstance(node, (ast.If, ast.IfExp, ast.For, ast.While, 
   |                                                                            ^
63 |                                      ast.Try, ast.ExceptHandler, ast.With, ast.Match)):
64 |                     complexity += 1
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\archive_consolidator.py:82:1
   |
80 |         self.days = days
81 |         self.ledger_path = project_root / ".agent" / "tech_debt_ledger.json"
82 |         
   | ^^^^^^^^
83 |         # Enforce ALFRED persona for this tool
84 |         HUD.PERSONA = "ALFRED"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\archive_consolidator.py:89:1
   |
87 |         """Calculates line churn for files changed in the last N days."""
88 |         churn_data = defaultdict(int)
89 |         
   | ^^^^^^^^
90 |         try:
91 |             cmd = ["git", "log", f"--since={self.days}.days", "--oneline", "--numstat"]
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\archive_consolidator.py:92:22
   |
90 |         try:
91 |             cmd = ["git", "log", f"--since={self.days}.days", "--oneline", "--numstat"]
92 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, check=True)
   |                      ^^^^^^^^^^^^^^
93 |             
94 |             if result.stdout:
   |

E501 Line too long (110 > 100)
  --> src\tools\archive_consolidator.py:92:101
   |
90 |         try:
91 |             cmd = ["git", "log", f"--since={self.days}.days", "--oneline", "--numstat"]
92 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, check=True)
   |                                                                                                     ^^^^^^^^^^
93 |             
94 |             if result.stdout:
   |

W293 [*] Blank line contains whitespace
  --> src\tools\archive_consolidator.py:93:1
   |
91 |             cmd = ["git", "log", f"--since={self.days}.days", "--oneline", "--numstat"]
92 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, check=True)
93 |             
   | ^^^^^^^^^^^^
94 |             if result.stdout:
95 |                 for line in result.stdout.splitlines():
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:101:1
    |
 99 |                         deletions = parts[1]
100 |                         filepath = parts[2]
101 |                         
    | ^^^^^^^^^^^^^^^^^^^^^^^^
102 |                         if additions == "-" or deletions == "-":
103 |                             continue # Binary file
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:104:1
    |
102 |                         if additions == "-" or deletions == "-":
103 |                             continue # Binary file
104 |                             
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |                         churn_data[filepath] += int(additions) + int(deletions)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:106:1
    |
105 |                         churn_data[filepath] += int(additions) + int(deletions)
106 |                         
    | ^^^^^^^^^^^^^^^^^^^^^^^^
107 |         except (subprocess.CalledProcessError, FileNotFoundError) as e:
108 |             HUD.persona_log("WARN", "Git churn calculation failed. Returning empty data.")
    |
help: Remove whitespace from blank line

F841 [*] Local variable `e` is assigned to but never used
   --> src\tools\archive_consolidator.py:107:70
    |
105 |                         churn_data[filepath] += int(additions) + int(deletions)
106 |                         
107 |         except (subprocess.CalledProcessError, FileNotFoundError) as e:
    |                                                                      ^
108 |             HUD.persona_log("WARN", "Git churn calculation failed. Returning empty data.")
    |
help: Remove assignment to unused variable `e`

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:109:1
    |
107 |         except (subprocess.CalledProcessError, FileNotFoundError) as e:
108 |             HUD.persona_log("WARN", "Git churn calculation failed. Returning empty data.")
109 |         
    | ^^^^^^^^
110 |         return dict(churn_data)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:117:1
    |
115 |         if not source_path.name.endswith(".py"):
116 |             return True # Ignore non-python for now
117 |             
    | ^^^^^^^^^^^^
118 |         test_filename = f"test_{source_path.name}"
119 |         search_dirs = [
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:125:1
    |
123 |             project_root / "tests" / "empire_tests"
124 |         ]
125 |         
    | ^^^^^^^^
126 |         for sd in search_dirs:
127 |             if sd.exists():
    |
help: Remove whitespace from blank line

B007 Loop control variable `test_file` not used within loop body
   --> src\tools\archive_consolidator.py:128:21
    |
126 |         for sd in search_dirs:
127 |             if sd.exists():
128 |                 for test_file in sd.rglob(test_filename):
    |                     ^^^^^^^^^
129 |                     return True
130 |         return False
    |
help: Rename unused `test_file` to `_test_file`

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:138:1
    |
136 |         HUD.box_row("CHURN WINDOW", f"Last {self.days} days", HUD.CYAN)
137 |         HUD.box_separator()
138 |         
    | ^^^^^^^^
139 |         HUD.persona_log("INFO", "Gathering Git churn statistics...")
140 |         churn_data = self._get_git_churn()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:142:1
    |
140 |         churn_data = self._get_git_churn()
141 |         HUD.box_row("FILES MODIFIED", str(len(churn_data)), HUD.GREEN)
142 |         
    | ^^^^^^^^
143 |         target_files = []
144 |         HUD.persona_log("INFO", "Evaluating complexity and coverage matrix...")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:145:1
    |
143 |         target_files = []
144 |         HUD.persona_log("INFO", "Evaluating complexity and coverage matrix...")
145 |         
    | ^^^^^^^^
146 |         for rel_path, churn in churn_data.items():
147 |             if not rel_path.endswith('.py'):
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:149:1
    |
147 |             if not rel_path.endswith('.py'):
148 |                 continue
149 |                 
    | ^^^^^^^^^^^^^^^^
150 |             full_path = self.target_dir / rel_path
151 |             if not full_path.exists() or not full_path.is_file():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:153:1
    |
151 |             if not full_path.exists() or not full_path.is_file():
152 |                 continue
153 |                 
    | ^^^^^^^^^^^^^^^^
154 |             try:
155 |                 code = full_path.read_text(encoding='utf-8')
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:158:1
    |
156 |                 complexity = get_complexity(code)
157 |                 has_test = self._has_test_coverage(rel_path)
158 |                 
    | ^^^^^^^^^^^^^^^^
159 |                 # The "Risk Score" Algorithm
160 |                 # High churn multiplies complexity. Low coverage acts as a huge multiplier.
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\tools\archive_consolidator.py:163:66
    |
161 |                 coverage_multiplier = 1.0 if has_test else 3.0
162 |                 # Normalize churn slightly to prevent massive files from dwarfing everything
163 |                 normalized_churn = min(churn / 100.0, 10.0) + 1.0 
    |                                                                  ^
164 |                 
165 |                 risk_score = (complexity * normalized_churn) * coverage_multiplier
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:164:1
    |
162 |                 # Normalize churn slightly to prevent massive files from dwarfing everything
163 |                 normalized_churn = min(churn / 100.0, 10.0) + 1.0 
164 |                 
    | ^^^^^^^^^^^^^^^^
165 |                 risk_score = (complexity * normalized_churn) * coverage_multiplier
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:166:1
    |
165 |                 risk_score = (complexity * normalized_churn) * coverage_multiplier
166 |                 
    | ^^^^^^^^^^^^^^^^
167 |                 target_files.append({
168 |                     "file": str(full_path.relative_to(project_root)),
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:179:1
    |
177 |         # Sort by risk score, descending
178 |         target_files.sort(key=lambda x: x["risk_score"], reverse=True)
179 |         
    | ^^^^^^^^
180 |         self._write_ledger(target_files)
181 |         self._render_report(target_files)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:182:1
    |
180 |         self._write_ledger(target_files)
181 |         self._render_report(target_files)
182 |         
    | ^^^^^^^^
183 |         return target_files
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:188:1
    |
186 |         """Writes the prioritized targets to the ledger."""
187 |         self.ledger_path.parent.mkdir(parents=True, exist_ok=True)
188 |         
    | ^^^^^^^^
189 |         ledger_data = {
190 |             "timestamp": HUD._speak("timestamp", "Now"), # Standard timestamp fallback
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:193:1
    |
191 |             "top_targets": targets[:20] # Keep top 20
192 |         }
193 |         
    | ^^^^^^^^
194 |         self.ledger_path.write_text(json.dumps(ledger_data, indent=4), encoding='utf-8')
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:201:1
    |
199 |         HUD.box_row("TOP SECURITY TARGETS (RISK SCORE)", "CHURN | CC | TEST COV", HUD.RED)
200 |         HUD.box_separator()
201 |         
    | ^^^^^^^^
202 |         if not targets:
203 |             HUD.box_row("STATUS", "The archive is immaculate, sir.", HUD.GREEN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:210:1
    |
208 |                 cov_mark = "[OK]" if item['coverage'] else "[MISSING]"
209 |                 stats = f"{item['churn']:<5} | {item['complexity']:<4} | {cov_mark}"
210 |                 
    | ^^^^^^^^^^^^^^^^
211 |                 # Format: 1.  filename.py ... 142 | 5.2 | [MISSING]
212 |                 HUD.box_row(f"{idx:02d}. {f_name}", stats, color, dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:213:1
    |
211 |                 # Format: 1.  filename.py ... 142 | 5.2 | [MISSING]
212 |                 HUD.box_row(f"{idx:02d}. {f_name}", stats, color, dim_label=True)
213 |                 
    | ^^^^^^^^^^^^^^^^
214 |             if len(targets) > 10:
215 |                 HUD.box_row("...", f"+ {len(targets) - 10} more files analyzed", dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\archive_consolidator.py:216:1
    |
214 |             if len(targets) > 10:
215 |                 HUD.box_row("...", f"+ {len(targets) - 10} more files analyzed", dim_label=True)
216 |                 
    | ^^^^^^^^^^^^^^^^
217 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\tools\archive_consolidator.py:220:5
    |
220 | def main():
    |     ^^^^
221 |     parser = argparse.ArgumentParser(description="The Archive Consolidator - Tech Debt Analysis")
222 |     parser.add_argument("target", nargs="?", default=".", help="Target directory to scan")
    |
help: Add return type annotation: `int | None`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\benchmark_engine.py:8:15
   |
 7 | # Add script directory to path for module discovery
 8 | current_dir = os.path.dirname(os.path.abspath(__file__))
   |               ^^^^^^^^^^^^^^^
 9 | if current_dir not in sys.path:
10 |     sys.path.append(current_dir)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\benchmark_engine.py:8:31
   |
 7 | # Add script directory to path for module discovery
 8 | current_dir = os.path.dirname(os.path.abspath(__file__))
   |                               ^^^^^^^^^^^^^^^
 9 | if current_dir not in sys.path:
10 |     sys.path.append(current_dir)
   |
help: Replace with `Path(...).resolve()`

E402 Module level import not at top of file
  --> src\tools\benchmark_engine.py:12:1
   |
10 |     sys.path.append(current_dir)
11 |
12 | from report_engine import ReportEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

ANN201 Missing return type annotation for public function `benchmark`
  --> src\tools\benchmark_engine.py:15:5
   |
15 | def benchmark(n=100):
   |     ^^^^^^^^^
16 |     """
17 |     Executes a performance trial of the sv_engine.py startup latency.
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `n`
  --> src\tools\benchmark_engine.py:15:15
   |
15 | def benchmark(n=100):
   |               ^
16 |     """
17 |     Executes a performance trial of the sv_engine.py startup latency.
   |

W293 Blank line contains whitespace
  --> src\tools\benchmark_engine.py:18:1
   |
16 |     """
17 |     Executes a performance trial of the sv_engine.py startup latency.
18 |     
   | ^^^^
19 |     Args:
20 |         n: The number of trials to execute for statistical significance.
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\benchmark_engine.py:24:1
   |
22 |     cmd = ["python", ".agent/scripts/sv_engine.py", "--benchmark"]
23 |     times = []
24 |     
   | ^^^^
25 |     print(f"Executing {n} trials of sv_engine.py startup...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\benchmark_engine.py:26:1
   |
25 |     print(f"Executing {n} trials of sv_engine.py startup...")
26 |     
   | ^^^^
27 |     for i in range(n):
28 |         start = time.perf_counter()
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\benchmark_engine.py:29:9
   |
27 |     for i in range(n):
28 |         start = time.perf_counter()
29 |         subprocess.run(cmd, capture_output=True, check=True)
   |         ^^^^^^^^^^^^^^
30 |         end = time.perf_counter()
31 |         times.append((end - start) * 1000) # ms
   |

W293 [*] Blank line contains whitespace
  --> src\tools\benchmark_engine.py:32:1
   |
30 |         end = time.perf_counter()
31 |         times.append((end - start) * 1000) # ms
32 |         
   | ^^^^^^^^
33 |         if (i+1) % 10 == 0:
34 |             print(f"Completed {i+1}/{n} trials...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\benchmark_engine.py:42:1
   |
41 |     engine = ReportEngine()
42 |     
   | ^^^^
43 |     body = f"""
44 | | Metric | Result |
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\benchmark_engine.py:52:1
   |
50 | | **Std Dev** | {stdev:.2f} ms |
51 | """
52 |     
   | ^^^^
53 |     if avg_t < 100:
54 |         verdict = "HIGHLY VIABLE"
   |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\brave_search.py:7:1
   |
 5 |   """
 6 |
 7 | / import os
 8 | | import json
 9 | | import requests
10 | | from datetime import datetime
11 | | from pathlib import Path
12 | | from src.core.ui import HUD
   | |___________________________^
13 |
14 |   class BraveSearch:
   |
help: Organize imports

ANN202 Missing return type annotation for private function `_ensure_quota_ledger`
  --> src\tools\brave_search.py:24:9
   |
22 |         self._ensure_quota_ledger()
23 |
24 |     def _ensure_quota_ledger(self):
   |         ^^^^^^^^^^^^^^^^^^^^
25 |         """Initializes or resets the quota ledger based on the current month."""
26 |         current_month = datetime.now().strftime("%Y-%m")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\brave_search.py:29:1
   |
27 |         if not self.QUOTA_FILE.parent.exists():
28 |             self.QUOTA_FILE.parent.mkdir(parents=True, exist_ok=True)
29 |         
   | ^^^^^^^^
30 |         if not self.QUOTA_FILE.exists():
31 |             data = {"month": current_month, "count": 0}
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\brave_search.py:41:18
   |
39 |     def _read_ledger(self) -> dict:
40 |         try:
41 |             with open(self.QUOTA_FILE, "r", encoding="utf-8") as f:
   |                  ^^^^
42 |                 return json.load(f)
43 |         except (json.JSONDecodeError, OSError):
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\brave_search.py:41:40
   |
39 |     def _read_ledger(self) -> dict:
40 |         try:
41 |             with open(self.QUOTA_FILE, "r", encoding="utf-8") as f:
   |                                        ^^^
42 |                 return json.load(f)
43 |         except (json.JSONDecodeError, OSError):
   |
help: Remove mode argument

ANN202 Missing return type annotation for private function `_save_ledger`
  --> src\tools\brave_search.py:46:9
   |
44 |             return {"month": datetime.now().strftime("%Y-%m"), "count": 0}
45 |
46 |     def _save_ledger(self, data: dict):
   |         ^^^^^^^^^^^^
47 |         with open(self.QUOTA_FILE, "w", encoding="utf-8") as f:
48 |             json.dump(data, f, indent=2)
   |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\brave_search.py:47:14
   |
46 |     def _save_ledger(self, data: dict):
47 |         with open(self.QUOTA_FILE, "w", encoding="utf-8") as f:
   |              ^^^^
48 |             json.dump(data, f, indent=2)
   |
help: Replace with `Path.open()`

ANN202 Missing return type annotation for private function `_increment_quota`
  --> src\tools\brave_search.py:50:9
   |
48 |             json.dump(data, f, indent=2)
49 |
50 |     def _increment_quota(self):
   |         ^^^^^^^^^^^^^^^^
51 |         data = self._read_ledger()
52 |         data["count"] += 1
   |
help: Add return type annotation: `None`

W293 Blank line contains whitespace
  --> src\tools\brave_search.py:62:1
   |
60 |         """
61 |         Executes a Brave Search. Returns a list of result dictionaries.
62 |         
   | ^^^^^^^^
63 |         Args:
64 |             query (str): The search query.
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\tools\brave_search.py:65:1
   |
63 |         Args:
64 |             query (str): The search query.
65 |             
   | ^^^^^^^^^^^^
66 |         Returns:
67 |             list[dict]: A list of dictionaries, each containing:
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\tools\brave_search.py:71:1
   |
69 |                 - description (str): The snippet or description.
70 |                 - url (str): The direct URL.
71 |         
   | ^^^^^^^^
72 |         Enforces the 1,000 search/month limit.
73 |         """
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\brave_search.py:97:1
   |
95 |                 response.raise_for_status()
96 |                 self._increment_quota()
97 |                 
   | ^^^^^^^^^^^^^^^^
98 |                 data = response.json()
99 |                 results = []
   |
help: Remove whitespace from blank line

E501 Line too long (117 > 100)
   --> src\tools\brave_search.py:108:101
    |
106 |                 return results
107 |             except requests.exceptions.RequestException as e:
108 |                 HUD.persona_log("WARN", f"Brave Search Request Failed (Attempt {attempt+1}/{max_retries}): {str(e)}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^
109 |                 if attempt < max_retries - 1:
110 |                     time.sleep(2 ** attempt)
    |

RUF010 [*] Use explicit conversion flag
   --> src\tools\brave_search.py:108:109
    |
106 |                 return results
107 |             except requests.exceptions.RequestException as e:
108 |                 HUD.persona_log("WARN", f"Brave Search Request Failed (Attempt {attempt+1}/{max_retries}): {str(e)}")
    |                                                                                                             ^^^^^^
109 |                 if attempt < max_retries - 1:
110 |                     time.sleep(2 ** attempt)
    |
help: Replace with conversion flag

RUF010 [*] Use explicit conversion flag
   --> src\tools\brave_search.py:112:73
    |
110 |                     time.sleep(2 ** attempt)
111 |                 else:
112 |                     HUD.persona_log("ERROR", f"Brave Search Exhausted: {str(e)}")
    |                                                                         ^^^^^^
113 |                     return []
114 |             except Exception as e:
    |
help: Replace with conversion flag

RUF010 [*] Use explicit conversion flag
   --> src\tools\brave_search.py:115:65
    |
113 |                     return []
114 |             except Exception as e:
115 |                 HUD.persona_log("ERROR", f"Brave Search Error: {str(e)}")
    |                                                                 ^^^^^^
116 |                 return []
    |
help: Replace with conversion flag

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:117:1
    |
115 |                 HUD.persona_log("ERROR", f"Brave Search Error: {str(e)}")
116 |                 return []
117 |         
    | ^^^^^^^^
118 |         return []
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:122:1
    |
120 | if __name__ == "__main__":
121 |     import sys
122 |     
    | ^^^^
123 |     # [ALFRED] Ensure environment is loaded (e.g. .env.local)
124 |     try:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:132:1
    |
130 |     # Simple CLI dispatch
131 |     # Usage: python src/tools/brave_search.py "search query"
132 |     
    | ^^^^
133 |     searcher = BraveSearch()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:134:1
    |
133 |     searcher = BraveSearch()
134 |     
    | ^^^^
135 |     if len(sys.argv) > 1:
136 |         query = " ".join(sys.argv[1:]) # Handle multi-word queries without quotes if needed, or just take the rest
    |
help: Remove whitespace from blank line

E501 Line too long (114 > 100)
   --> src\tools\brave_search.py:136:101
    |
135 |     if len(sys.argv) > 1:
136 |         query = " ".join(sys.argv[1:]) # Handle multi-word queries without quotes if needed, or just take the rest
    |                                                                                                     ^^^^^^^^^^^^^^
137 |         
138 |         HUD.persona_log("INFO", f"Executing Brave Search for: {query}")
    |

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:137:1
    |
135 |     if len(sys.argv) > 1:
136 |         query = " ".join(sys.argv[1:]) # Handle multi-word queries without quotes if needed, or just take the rest
137 |         
    | ^^^^^^^^
138 |         HUD.persona_log("INFO", f"Executing Brave Search for: {query}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:139:1
    |
138 |         HUD.persona_log("INFO", f"Executing Brave Search for: {query}")
139 |         
    | ^^^^^^^^
140 |         results = searcher.search(query)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:141:1
    |
140 |         results = searcher.search(query)
141 |         
    | ^^^^^^^^
142 |         if results:
143 |             HUD.box_top(f"SEARCH RESULTS: {query}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:144:1
    |
142 |         if results:
143 |             HUD.box_top(f"SEARCH RESULTS: {query}")
144 |             
    | ^^^^^^^^^^^^
145 |             for i, res in enumerate(results):
146 |                 title = res.get('title', 'N/A')
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:149:1
    |
147 |                 url = res.get('url', 'N/A')
148 |                 desc = res.get('description', 'N/A')
149 |                 
    | ^^^^^^^^^^^^^^^^
150 |                 # Truncate description if too long for clean display
151 |                 if len(desc) > 80:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:153:1
    |
151 |                 if len(desc) > 80:
152 |                     desc = desc[:77] + "..."
153 |                     
    | ^^^^^^^^^^^^^^^^^^^^
154 |                 print(f"\n{HUD.CYAN}[{i+1}] {HUD.BOLD}{title}{HUD.RESET}")
155 |                 print(f"    {HUD.DIM}{url}{HUD.RESET}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:157:1
    |
155 |                 print(f"    {HUD.DIM}{url}{HUD.RESET}")
156 |                 print(f"    {desc}")
157 |                 
    | ^^^^^^^^^^^^^^^^
158 |             print(f"\n{HUD.DIM}Found {len(results)} results.{HUD.RESET}")
159 |         else:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\brave_search.py:161:1
    |
159 |         else:
160 |             HUD.persona_log("WARN", "No results returned.")
161 |             
    | ^^^^^^^^^^^^
162 |     else:
163 |         HUD.persona_log("WARN", "Usage: python -m src.tools.brave_search <query>")
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\tools\brave_search.py:163:83
    |
162 |     else:
163 |         HUD.persona_log("WARN", "Usage: python -m src.tools.brave_search <query>")
    |                                                                                   ^
    |
help: Add trailing newline

F401 [*] `os` imported but unused
  --> src\tools\code_sentinel.py:14:8
   |
12 | import ast
13 | import json
14 | import os
   |        ^^
15 | import subprocess
16 | import sys
   |
help: Remove unused import: `os`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\tools\code_sentinel.py:18:1
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | # Ensure UTF-8 output for box-drawing characters
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src\tools\code_sentinel.py:18:1
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | # Ensure UTF-8 output for box-drawing characters
   |

E402 Module level import not at top of file
  --> src\tools\code_sentinel.py:29:1
   |
27 |     sys.path.append(str(project_root))
28 |
29 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\tools\code_sentinel.py:38:16
   |
36 |       """
37 |
38 |       TEXT_MAP = {
   |  ________________^
39 | |         "O.D.I.N.": {
40 | |             "TITLE": "[Î©] HEIMDALL SECURITY SCAN",
41 | |             "PASS": "SECTOR SECURE. NO ANOMALIES.",
42 | |             "FAIL": "CONTAINMENT BREACH DETECTED.",
43 | |             "SCAN_TARGET": "TARGET SECTOR",
44 | |             "VIOLATIONS": "ANOMALIES",
45 | |             "V_PREFIX": "[!] BREACH",
46 | |             "STRUCT_CODE": "STRUCT-001"
47 | |         },
48 | |         "ALFRED": {
49 | |             "TITLE": "[A] THE PERIMETER SCAN",
50 | |             "PASS": "The manor is immaculate, sir.",
51 | |             "FAIL": "I found some items out of place, sir.",
52 | |             "SCAN_TARGET": "SCAN AREA",
53 | |             "VIOLATIONS": "FINDINGS",
54 | |             "V_PREFIX": "[i] NOTE",
55 | |             "STRUCT_CODE": "HOUSEKEEP-01"
56 | |         }
57 | |     }
   | |_____^
58 |
59 |       def __init__(self, target: str = ".", fix: bool = False, persona_override: Optional[str] = None) -> None:
   |

UP045 [*] Use `X | None` for type annotations
  --> src\tools\code_sentinel.py:59:80
   |
57 |     }
58 |
59 |     def __init__(self, target: str = ".", fix: bool = False, persona_override: Optional[str] = None) -> None:
   |                                                                                ^^^^^^^^^^^^^
60 |         self.target = Path(target)
61 |         self.fix = fix
   |
help: Convert to `X | None`

E501 Line too long (109 > 100)
  --> src\tools\code_sentinel.py:59:101
   |
57 |     }
58 |
59 |     def __init__(self, target: str = ".", fix: bool = False, persona_override: Optional[str] = None) -> None:
   |                                                                                                     ^^^^^^^^^
60 |         self.target = Path(target)
61 |         self.fix = fix
   |

E501 Line too long (116 > 100)
  --> src\tools\code_sentinel.py:65:101
   |
63 |         self.project_root = self.scripts_dir.parent.parent
64 |         self.config = self._load_config()
65 |         HUD.PERSONA = persona_override.upper() if persona_override else self.config.get("Persona", "ALFRED").upper()
   |                                                                                                     ^^^^^^^^^^^^^^^^
66 |         if HUD.PERSONA == "GOD":
67 |             HUD.PERSONA = "O.D.I.N."
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\code_sentinel.py:73:22
   |
71 |         if config_path.exists():
72 |             try:
73 |                 with open(config_path, encoding='utf-8') as f:
   |                      ^^^^
74 |                     return json.load(f)
75 |             except Exception:
   |
help: Replace with `Path.open()`

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\tools\code_sentinel.py:75:13
   |
73 |                   with open(config_path, encoding='utf-8') as f:
74 |                       return json.load(f)
75 | /             except Exception:
76 | |                 pass
   | |____________________^
77 |           return {}
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\code_sentinel.py:79:51
   |
77 |         return {}
78 |
79 |     def scan_for_orphans(self, filepath: Path) -> List[Dict[str, Any]]:
   |                                                   ^^^^
80 |         """AST-based scan for top-level functions (orphans)."""
81 |         if not filepath.suffix == ".py" or not filepath.is_file():
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\code_sentinel.py:79:56
   |
77 |         return {}
78 |
79 |     def scan_for_orphans(self, filepath: Path) -> List[Dict[str, Any]]:
   |                                                        ^^^^
80 |         """AST-based scan for top-level functions (orphans)."""
81 |         if not filepath.suffix == ".py" or not filepath.is_file():
   |
help: Replace with `dict`

SIM201 Use `filepath.suffix != ".py"` instead of `not filepath.suffix == ".py"`
  --> src\tools\code_sentinel.py:81:12
   |
79 |     def scan_for_orphans(self, filepath: Path) -> List[Dict[str, Any]]:
80 |         """AST-based scan for top-level functions (orphans)."""
81 |         if not filepath.suffix == ".py" or not filepath.is_file():
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |             return []
   |
help: Replace with `!=` operator

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\code_sentinel.py:86:18
   |
84 |         violations = []
85 |         try:
86 |             with open(filepath, "r", encoding="utf-8") as f:
   |                  ^^^^
87 |                 lines = f.readlines()
88 |                 content = "".join(lines)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\code_sentinel.py:86:33
   |
84 |         violations = []
85 |         try:
86 |             with open(filepath, "r", encoding="utf-8") as f:
   |                                 ^^^
87 |                 lines = f.readlines()
88 |                 content = "".join(lines)
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\code_sentinel.py:89:1
   |
87 |                 lines = f.readlines()
88 |                 content = "".join(lines)
89 |             
   | ^^^^^^^^^^^^
90 |             tree = ast.parse(content)
91 |         except Exception as e:
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\tools\code_sentinel.py:93:34
   |
91 |         except Exception as e:
92 |             return [{
93 |                 "code": "SYNTAX", 
   |                                  ^
94 |                 "filename": str(filepath), 
95 |                 "location": {"row": 1, "column": 0}, 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\code_sentinel.py:94:43
   |
92 |             return [{
93 |                 "code": "SYNTAX", 
94 |                 "filename": str(filepath), 
   |                                           ^
95 |                 "location": {"row": 1, "column": 0}, 
96 |                 "message": str(e), 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\code_sentinel.py:95:53
   |
93 |                 "code": "SYNTAX", 
94 |                 "filename": str(filepath), 
95 |                 "location": {"row": 1, "column": 0}, 
   |                                                     ^
96 |                 "message": str(e), 
97 |                 "severity": "CRITICAL"
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\code_sentinel.py:96:35
   |
94 |                 "filename": str(filepath), 
95 |                 "location": {"row": 1, "column": 0}, 
96 |                 "message": str(e), 
   |                                   ^
97 |                 "severity": "CRITICAL"
98 |             }]
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:119:1
    |
117 |                     "severity": "CRITICAL"
118 |                 })
119 |         
    | ^^^^^^^^
120 |         return violations
    |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\tools\code_sentinel.py:122:27
    |
120 |         return violations
121 |
122 |     def run_ruff(self) -> List[Dict[str, Any]]:
    |                           ^^^^
123 |         """Executes Ruff check for linting and style metrics."""
124 |         cmd = [sys.executable, "-m", "ruff", "check", str(self.target), "--output-format=json"]
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\tools\code_sentinel.py:122:32
    |
120 |         return violations
121 |
122 |     def run_ruff(self) -> List[Dict[str, Any]]:
    |                                ^^^^
123 |         """Executes Ruff check for linting and style metrics."""
124 |         cmd = [sys.executable, "-m", "ruff", "check", str(self.target), "--output-format=json"]
    |
help: Replace with `dict`

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\code_sentinel.py:135:22
    |
133 |         try:
134 |             # Use specific encoding for Windows compatibility
135 |             result = subprocess.run(cmd, capture_output=True, timeout=30)
    |                      ^^^^^^^^^^^^^^
136 |             stdout = result.stdout.decode('utf-8', errors='replace')
137 |             stderr = result.stderr.decode('utf-8', errors='replace')
    |

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:138:1
    |
136 |             stdout = result.stdout.decode('utf-8', errors='replace')
137 |             stderr = result.stderr.decode('utf-8', errors='replace')
138 |             
    | ^^^^^^^^^^^^
139 |             if not stdout.strip():
140 |                 if stderr and "error:" in stderr.lower():
    |
help: Remove whitespace from blank line

E741 Ambiguous variable name: `l`
   --> src\tools\code_sentinel.py:142:40
    |
140 |                 if stderr and "error:" in stderr.lower():
141 |                     # Strip lines for brevity
142 |                     err_lines = [l for l in stderr.splitlines() if l.strip()]
    |                                        ^
143 |                     HUD.box_row("RUFF ERROR", err_lines[0][:60] if err_lines else "Unknown", HUD.RED)
144 |                 return []
    |

E501 Line too long (101 > 100)
   --> src\tools\code_sentinel.py:143:101
    |
141 |                     # Strip lines for brevity
142 |                     err_lines = [l for l in stderr.splitlines() if l.strip()]
143 |                     HUD.box_row("RUFF ERROR", err_lines[0][:60] if err_lines else "Unknown", HUD.RED)
    |                                                                                                     ^
144 |                 return []
    |

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:150:1
    |
148 |             except json.JSONDecodeError:
149 |                 return []
150 |                 
    | ^^^^^^^^^^^^^^^^
151 |         except FileNotFoundError:
152 |             HUD.log("WARN", "Sentinel", "Ruff not found. Style scan skipped.")
    |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\tools\code_sentinel.py:161:42
    |
159 |             return []
160 |
161 |     def format_results(self, violations: List[Dict[str, Any]]) -> None:
    |                                          ^^^^
162 |         """Visual representation of scan results."""
163 |         persona = HUD.PERSONA if HUD.PERSONA in self.TEXT_MAP else "ALFRED"
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\tools\code_sentinel.py:161:47
    |
159 |             return []
160 |
161 |     def format_results(self, violations: List[Dict[str, Any]]) -> None:
    |                                               ^^^^
162 |         """Visual representation of scan results."""
163 |         persona = HUD.PERSONA if HUD.PERSONA in self.TEXT_MAP else "ALFRED"
    |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:165:1
    |
163 |         persona = HUD.PERSONA if HUD.PERSONA in self.TEXT_MAP else "ALFRED"
164 |         text = self.TEXT_MAP[persona]
165 |         
    | ^^^^^^^^
166 |         HUD.box_top(text["TITLE"])
167 |         HUD.box_row(text["SCAN_TARGET"], str(self.target), HUD.CYAN)
    |
help: Remove whitespace from blank line

E501 Line too long (121 > 100)
   --> src\tools\code_sentinel.py:181:101
    |
179 |                 loc = f"{filename}:{v['location']['row']}:{v['location']['column']}"
180 |                 severity = v.get('severity', '')
181 |                 color = HUD.RED if ("Error" in severity or "CRITICAL" in severity or severity == "ERROR") else HUD.YELLOW
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^
182 |                 prefix = text["V_PREFIX"]
183 |                 HUD.box_row(f"{prefix} {v['code']}", f"{loc} - {v['message'][:50]}", color, dim_label=True)
    |

E501 Line too long (107 > 100)
   --> src\tools\code_sentinel.py:183:101
    |
181 |                 color = HUD.RED if ("Error" in severity or "CRITICAL" in severity or severity == "ERROR") else HUD.YELLOW
182 |                 prefix = text["V_PREFIX"]
183 |                 HUD.box_row(f"{prefix} {v['code']}", f"{loc} - {v['message'][:50]}", color, dim_label=True)
    |                                                                                                     ^^^^^^^
184 |
185 |             if len(violations) > 15:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:195:1
    |
193 |         """Main entry point for the audit cycle."""
194 |         violations = self.run_ruff()
195 |         
    | ^^^^^^^^
196 |         # Structure Scan
197 |         if self.target.is_file():
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\code_sentinel.py:217:1
    |
215 |     heimdall = Heimdall(target=args.target, fix=args.fix, persona_override=args.persona)
216 |     success = heimdall.execute_audit()
217 |     
    | ^^^^
218 |     if not success:
219 |         sys.exit(1)
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\tools\code_sentinel.py:223:11
    |
222 | if __name__ == "__main__":
223 |     main()
    |           ^
    |
help: Add trailing newline

F401 [*] `json` imported but unused
 --> src\tools\compile_failure_report.py:1:8
  |
1 | import json
  |        ^^^^
2 | import os
3 | import sys
  |
help: Remove unused import: `json`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\compile_failure_report.py:7:20
  |
6 | # Import Shared UI
7 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
  |                    ^^^^^^^^^^^^
8 | from ui import HUD
  |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
 --> src\tools\compile_failure_report.py:7:33
  |
6 | # Import Shared UI
7 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
  |                                 ^^^^^^^^^^^^^^^
8 | from ui import HUD
  |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
 --> src\tools\compile_failure_report.py:7:49
  |
6 | # Import Shared UI
7 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
  |                                                 ^^^^^^^^^^^^^^^
8 | from ui import HUD
  |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
 --> src\tools\compile_failure_report.py:7:65
  |
6 | # Import Shared UI
7 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
  |                                                                 ^^^^^^^^^^^^^^^
8 | from ui import HUD
  |
help: Replace with `Path(...).resolve()`

E501 Line too long (101 > 100)
 --> src\tools\compile_failure_report.py:7:101
  |
6 | # Import Shared UI
7 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
  |                                                                                                     ^
8 | from ui import HUD
  |

ANN201 Missing return type annotation for public function `compile_report`
  --> src\tools\compile_failure_report.py:11:5
   |
11 | def compile_report(project_root):
   |     ^^^^^^^^^^^^^^
12 |     HUD.box_top("SOVEREIGN CYCLE: FAILURE ANALYSIS")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `project_root`
  --> src\tools\compile_failure_report.py:11:20
   |
11 | def compile_report(project_root):
   |                    ^^^^^^^^^^^^
12 |     HUD.box_top("SOVEREIGN CYCLE: FAILURE ANALYSIS")
   |

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:13:1
   |
11 | def compile_report(project_root):
12 |     HUD.box_top("SOVEREIGN CYCLE: FAILURE ANALYSIS")
13 |     
   | ^^^^
14 |     # Paths
15 |     base_dir = os.path.join(project_root, ".agent")
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\compile_failure_report.py:15:16
   |
14 |     # Paths
15 |     base_dir = os.path.join(project_root, ".agent")
   |                ^^^^^^^^^^^^
16 |     rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\compile_failure_report.py:16:16
   |
14 |     # Paths
15 |     base_dir = os.path.join(project_root, ".agent")
16 |     rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
   |                ^^^^^^^^^^^^
17 |     
18 |     rejections = []
   |

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:17:1
   |
15 |     base_dir = os.path.join(project_root, ".agent")
16 |     rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
17 |     
   | ^^^^
18 |     rejections = []
19 |     if os.path.exists(rej_path):
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\compile_failure_report.py:19:8
   |
18 |     rejections = []
19 |     if os.path.exists(rej_path):
   |        ^^^^^^^^^^^^^^
20 |         with open(rej_path, 'r', encoding='utf-8') as f:
21 |             lines = f.readlines()
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\compile_failure_report.py:20:14
   |
18 |     rejections = []
19 |     if os.path.exists(rej_path):
20 |         with open(rej_path, 'r', encoding='utf-8') as f:
   |              ^^^^
21 |             lines = f.readlines()
22 |             for line in lines:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\compile_failure_report.py:20:29
   |
18 |     rejections = []
19 |     if os.path.exists(rej_path):
20 |         with open(rej_path, 'r', encoding='utf-8') as f:
   |                             ^^^
21 |             lines = f.readlines()
22 |             for line in lines:
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:25:1
   |
23 |                 if line.startswith("- ["):
24 |                     rejections.append(line.strip())
25 |     
   | ^^^^
26 |     HUD.log("INFO", f"Found {len(rejections)} rejected traces in Quarantine.")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:27:1
   |
26 |     HUD.log("INFO", f"Found {len(rejections)} rejected traces in Quarantine.")
27 |     
   | ^^^^
28 |     # Categorize
29 |     categories = defaultdict(int)
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\tools\compile_failure_report.py:31:34
   |
29 |     categories = defaultdict(int)
30 |     for r in rejections:
31 |         if "latency" in r.lower(): categories["LATENCY"] += 1
   |                                  ^
32 |         elif "conflict" in r.lower(): categories["CONFLICT"] += 1
33 |         elif "score" in r.lower(): categories["CONFIDENCE"] += 1
   |

E701 Multiple statements on one line (colon)
  --> src\tools\compile_failure_report.py:32:37
   |
30 |     for r in rejections:
31 |         if "latency" in r.lower(): categories["LATENCY"] += 1
32 |         elif "conflict" in r.lower(): categories["CONFLICT"] += 1
   |                                     ^
33 |         elif "score" in r.lower(): categories["CONFIDENCE"] += 1
34 |         else: categories["UNKNOWN"] += 1
   |

E701 Multiple statements on one line (colon)
  --> src\tools\compile_failure_report.py:33:34
   |
31 |         if "latency" in r.lower(): categories["LATENCY"] += 1
32 |         elif "conflict" in r.lower(): categories["CONFLICT"] += 1
33 |         elif "score" in r.lower(): categories["CONFIDENCE"] += 1
   |                                  ^
34 |         else: categories["UNKNOWN"] += 1
   |

E701 Multiple statements on one line (colon)
  --> src\tools\compile_failure_report.py:34:13
   |
32 |         elif "conflict" in r.lower(): categories["CONFLICT"] += 1
33 |         elif "score" in r.lower(): categories["CONFIDENCE"] += 1
34 |         else: categories["UNKNOWN"] += 1
   |             ^
35 |         
36 |     HUD.box_separator()
   |

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:35:1
   |
33 |         elif "score" in r.lower(): categories["CONFIDENCE"] += 1
34 |         else: categories["UNKNOWN"] += 1
35 |         
   | ^^^^^^^^
36 |     HUD.box_separator()
37 |     HUD.box_row("CATEGORY", "COUNT", HUD.BOLD)
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\tools\compile_failure_report.py:40:28
   |
38 |     for cat, count in categories.items():
39 |         color = HUD.YELLOW
40 |         if cat == "LATENCY": color = HUD.RED
   |                            ^
41 |         HUD.box_row(cat, str(count), color)
   |

W293 [*] Blank line contains whitespace
  --> src\tools\compile_failure_report.py:42:1
   |
40 |         if cat == "LATENCY": color = HUD.RED
41 |         HUD.box_row(cat, str(count), color)
42 |         
   | ^^^^^^^^
43 |     HUD.box_bottom()
   |
help: Remove whitespace from blank line

E501 Line too long (107 > 100)
  --> src\tools\compile_failure_report.py:47:101
   |
45 |     # Recommendations
46 |     if categories["LATENCY"] > 5:
47 |         print(f"\n{HUD.RED}>> ADVISORY: Latency Spike Detected. Investigate network_watcher.py{HUD.RESET}")
   |                                                                                                     ^^^^^^^
48 |     if categories["CONFLICT"] > 5:
49 |         print(f"\n{HUD.YELLOW}>> ADVISORY: High Conflict Rate. Run 'python trace_viz.py --war-room'{HUD.RESET}")
   |

E501 Line too long (112 > 100)
  --> src\tools\compile_failure_report.py:49:101
   |
47 |         print(f"\n{HUD.RED}>> ADVISORY: Latency Spike Detected. Investigate network_watcher.py{HUD.RESET}")
48 |     if categories["CONFLICT"] > 5:
49 |         print(f"\n{HUD.YELLOW}>> ADVISORY: High Conflict Rate. Run 'python trace_viz.py --war-room'{HUD.RESET}")
   |                                                                                                     ^^^^^^^^^^^^
50 |
51 | if __name__ == "__main__":
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\compile_failure_report.py:52:20
   |
51 | if __name__ == "__main__":
52 |     compile_report(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
   |                    ^^^^^^^^^^^^^^^
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\compile_failure_report.py:52:36
   |
51 | if __name__ == "__main__":
52 |     compile_report(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
   |                                    ^^^^^^^^^^^^^^^
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\compile_failure_report.py:52:52
   |
51 | if __name__ == "__main__":
52 |     compile_report(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
   |                                                    ^^^^^^^^^^^^^^^
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\compile_failure_report.py:52:68
   |
51 | if __name__ == "__main__":
52 |     compile_report(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
   |                                                                    ^^^^^^^^^^^^^^^
   |
help: Replace with `Path(...).resolve()`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src\tools\compile_session_traces.py:6:1
  |
4 | import shutil
5 | from datetime import datetime
6 | from typing import Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src\tools\compile_session_traces.py:6:1
  |
4 | import shutil
5 | from datetime import datetime
6 | from typing import Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\compile_session_traces.py:11:32
   |
 9 | class TraceAnalyzer:
10 |     """[ALFRED] Advanced analytics for neural traces."""
11 |     def __init__(self, traces: List[dict]) -> None:
   |                                ^^^^
12 |         self.traces = traces
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\compile_session_traces.py:14:30
   |
12 |         self.traces = traces
13 |
14 |     def get_summary(self) -> Dict:
   |                              ^^^^
15 |         if not self.traces: return {}
16 |         scores = [t.get('score', 0) for t in self.traces]
   |
help: Replace with `dict`

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:15:27
   |
14 |     def get_summary(self) -> Dict:
15 |         if not self.traces: return {}
   |                           ^
16 |         scores = [t.get('score', 0) for t in self.traces]
17 |         return {
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\compile_session_traces.py:25:36
   |
23 |         }
24 |
25 |     def _group_by_persona(self) -> Dict[str, List[dict]]:
   |                                    ^^^^
26 |         grouped = {}
27 |         for t in self.traces:
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\compile_session_traces.py:25:46
   |
23 |         }
24 |
25 |     def _group_by_persona(self) -> Dict[str, List[dict]]:
   |                                              ^^^^
26 |         grouped = {}
27 |         for t in self.traces:
   |
help: Replace with `list`

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:29:32
   |
27 |         for t in self.traces:
28 |             p = t.get('persona', 'UNKNOWN').upper()
29 |             if p not in grouped: grouped[p] = []
   |                                ^
30 |             grouped[p].append(t)
31 |         return grouped
   |

ANN201 Missing return type annotation for public function `render`
  --> src\tools\compile_session_traces.py:45:9
   |
43 |         self.path = report_path
44 |
45 |     def render(self, traces: List[dict], stats: Dict):
   |         ^^^^^^
46 |         lines = [
47 |             "# ðŸ§  C* Neural Trace Report\n",
   |
help: Add return type annotation: `None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\compile_session_traces.py:45:30
   |
43 |         self.path = report_path
44 |
45 |     def render(self, traces: List[dict], stats: Dict):
   |                              ^^^^
46 |         lines = [
47 |             "# ðŸ§  C* Neural Trace Report\n",
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\compile_session_traces.py:45:49
   |
43 |         self.path = report_path
44 |
45 |     def render(self, traces: List[dict], stats: Dict):
   |                                                 ^^^^
46 |         lines = [
47 |             "# ðŸ§  C* Neural Trace Report\n",
   |
help: Replace with `dict`

E501 Line too long (112 > 100)
  --> src\tools\compile_session_traces.py:69:101
   |
67 |             lines.append("\n## ðŸš¨ Critical Failures (Score < 0.6)")
68 |             for f in stats['critical_fails']:
69 |                 lines.append(f"- `{f.get('query')}` matched `{f.get('match')}` with score {f.get('score'):.2f}")
   |                                                                                                     ^^^^^^^^^^^^
70 |
71 |         # Restoration of Suggested Improvements
   |

E501 Line too long (177 > 100)
  --> src\tools\compile_session_traces.py:75:101
   |
73 | â€¦
74 | â€¦
75 | â€¦idence is low ({t['score']:.2f}) for query `{t['query']}`. Consider expanding `thesaurus.qmd` clusters.")
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
76 | â€¦
77 | â€¦
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\compile_session_traces.py:81:14
   |
79 |             lines.extend(list(set(potential_improvements))[:5]) # Top 5 unique improvements
80 |
81 |         with open(self.path, "w", encoding="utf-8") as f: f.write("\n".join(lines))
   |              ^^^^
82 |
83 | def compile_traces(tdir: str = None, rpath: str = None):
   |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:81:57
   |
79 |             lines.extend(list(set(potential_improvements))[:5]) # Top 5 unique improvements
80 |
81 |         with open(self.path, "w", encoding="utf-8") as f: f.write("\n".join(lines))
   |                                                         ^
82 |
83 | def compile_traces(tdir: str = None, rpath: str = None):
   |

ANN201 Missing return type annotation for public function `compile_traces`
  --> src\tools\compile_session_traces.py:83:5
   |
81 |         with open(self.path, "w", encoding="utf-8") as f: f.write("\n".join(lines))
82 |
83 | def compile_traces(tdir: str = None, rpath: str = None):
   |     ^^^^^^^^^^^^^^
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |
help: Add return type annotation

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\tools\compile_session_traces.py:83:26
   |
81 |         with open(self.path, "w", encoding="utf-8") as f: f.write("\n".join(lines))
82 |
83 | def compile_traces(tdir: str = None, rpath: str = None):
   |                          ^^^
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |
help: Convert to `T | None`

RUF013 PEP 484 prohibits implicit `Optional`
  --> src\tools\compile_session_traces.py:83:45
   |
81 |         with open(self.path, "w", encoding="utf-8") as f: f.write("\n".join(lines))
82 |
83 | def compile_traces(tdir: str = None, rpath: str = None):
   |                                             ^^^
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |
help: Convert to `T | None`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\compile_session_traces.py:85:12
   |
83 | def compile_traces(tdir: str = None, rpath: str = None):
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |            ^^^^^^^^^^^^^^^
86 |     tdir = tdir or os.path.join(base, "traces")
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\compile_session_traces.py:85:28
   |
83 | def compile_traces(tdir: str = None, rpath: str = None):
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                            ^^^^^^^^^^^^^^^
86 |     tdir = tdir or os.path.join(base, "traces")
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\compile_session_traces.py:85:44
   |
83 | def compile_traces(tdir: str = None, rpath: str = None):
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                                            ^^^^^^^^^^^^^^^
86 |     tdir = tdir or os.path.join(base, "traces")
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\compile_session_traces.py:86:20
   |
84 |     """[ALFRED] Restored trace compiler with persona-awareness and identity-theming."""
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
86 |     tdir = tdir or os.path.join(base, "traces")
   |                    ^^^^^^^^^^^^
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\compile_session_traces.py:87:22
   |
85 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
86 |     tdir = tdir or os.path.join(base, "traces")
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
   |                      ^^^^^^^^^^^^
88 |
89 |     if not os.path.exists(tdir): return [], {}
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\compile_session_traces.py:89:12
   |
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
88 |
89 |     if not os.path.exists(tdir): return [], {}
   |            ^^^^^^^^^^^^^^
90 |     files = glob.glob(os.path.join(tdir, "*.json"))
91 |     if not files: return [], {}
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:89:32
   |
87 |     rpath = rpath or os.path.join(base, "TRACE_REPORT.qmd")
88 |
89 |     if not os.path.exists(tdir): return [], {}
   |                                ^
90 |     files = glob.glob(os.path.join(tdir, "*.json"))
91 |     if not files: return [], {}
   |

PTH207 Replace `glob` with `Path.glob` or `Path.rglob`
  --> src\tools\compile_session_traces.py:90:13
   |
89 |     if not os.path.exists(tdir): return [], {}
90 |     files = glob.glob(os.path.join(tdir, "*.json"))
   |             ^^^^^^^^^
91 |     if not files: return [], {}
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\compile_session_traces.py:90:23
   |
89 |     if not os.path.exists(tdir): return [], {}
90 |     files = glob.glob(os.path.join(tdir, "*.json"))
   |                       ^^^^^^^^^^^^
91 |     if not files: return [], {}
   |

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:91:17
   |
89 |     if not os.path.exists(tdir): return [], {}
90 |     files = glob.glob(os.path.join(tdir, "*.json"))
91 |     if not files: return [], {}
   |                 ^
92 |
93 |     raw_traces = []
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\compile_session_traces.py:96:18
   |
94 |     for f in files:
95 |         try:
96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
   |                  ^^^^
97 |         except (json.JSONDecodeError, IOError, OSError): pass
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\compile_session_traces.py:96:26
   |
94 |     for f in files:
95 |         try:
96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
   |                          ^^^
97 |         except (json.JSONDecodeError, IOError, OSError): pass
   |
help: Remove mode argument

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:96:35
   |
94 |     for f in files:
95 |         try:
96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
   |                                   ^
97 |         except (json.JSONDecodeError, IOError, OSError): pass
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\compile_session_traces.py:97:16
   |
95 |         try:
96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
97 |         except (json.JSONDecodeError, IOError, OSError): pass
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
98 |     
99 |     analyzer = TraceAnalyzer(raw_traces)
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\tools\compile_session_traces.py:97:56
   |
95 |         try:
96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
97 |         except (json.JSONDecodeError, IOError, OSError): pass
   |                                                        ^
98 |     
99 |     analyzer = TraceAnalyzer(raw_traces)
   |

W293 [*] Blank line contains whitespace
   --> src\tools\compile_session_traces.py:98:1
    |
 96 |             with open(f, 'r') as j: raw_traces.append(json.load(j))
 97 |         except (json.JSONDecodeError, IOError, OSError): pass
 98 |     
    | ^^^^
 99 |     analyzer = TraceAnalyzer(raw_traces)
100 |     stats = analyzer.get_summary()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\compile_session_traces.py:102:1
    |
100 |     stats = analyzer.get_summary()
101 |     ReportRenderer(rpath).render(raw_traces, stats)
102 |     
    | ^^^^
103 |     # Auto-Corrections
104 |     if stats.get('critical_fails'):
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\compile_session_traces.py:105:28
    |
103 |     # Auto-Corrections
104 |     if stats.get('critical_fails'):
105 |         corrections_path = os.path.join(base, ".agent", "corrections.json")
    |                            ^^^^^^^^^^^^
106 |         try:
107 |             data = {}
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\tools\compile_session_traces.py:108:16
    |
106 |         try:
107 |             data = {}
108 |             if os.path.exists(corrections_path):
    |                ^^^^^^^^^^^^^^
109 |                 with open(corrections_path, 'r') as f: data = json.load(f)
    |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\compile_session_traces.py:109:22
    |
107 |             data = {}
108 |             if os.path.exists(corrections_path):
109 |                 with open(corrections_path, 'r') as f: data = json.load(f)
    |                      ^^^^
110 |             
111 |             mappings = data.get("phrase_mappings", {})
    |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
   --> src\tools\compile_session_traces.py:109:45
    |
107 |             data = {}
108 |             if os.path.exists(corrections_path):
109 |                 with open(corrections_path, 'r') as f: data = json.load(f)
    |                                             ^^^
110 |             
111 |             mappings = data.get("phrase_mappings", {})
    |
help: Remove mode argument

E701 Multiple statements on one line (colon)
   --> src\tools\compile_session_traces.py:109:54
    |
107 |             data = {}
108 |             if os.path.exists(corrections_path):
109 |                 with open(corrections_path, 'r') as f: data = json.load(f)
    |                                                      ^
110 |             
111 |             mappings = data.get("phrase_mappings", {})
    |

W293 [*] Blank line contains whitespace
   --> src\tools\compile_session_traces.py:110:1
    |
108 |             if os.path.exists(corrections_path):
109 |                 with open(corrections_path, 'r') as f: data = json.load(f)
110 |             
    | ^^^^^^^^^^^^
111 |             mappings = data.get("phrase_mappings", {})
112 |             for fail in stats['critical_fails']:
    |
help: Remove whitespace from blank line

E501 Line too long (116 > 100)
   --> src\tools\compile_session_traces.py:116:101
    |
114 |                 # In traces, we might not have 'expected' unless it was a test case.
115 |                 # But if we have a match that was weak, maybe we confirm it?
116 |                 # The user requirement says: "finding critical_fails ... write these failed query -> expected pairs"
    |                                                                                                     ^^^^^^^^^^^^^^^^
117 |                 # If the trace doesn't have 'expected', we can't map it.
118 |                 # Assuming traces might come from fishtest or have 'expected' field.
    |

W293 [*] Blank line contains whitespace
   --> src\tools\compile_session_traces.py:121:1
    |
119 |                 if 'expected' in fail and 'query' in fail:
120 |                     mappings[fail['query']] = fail['expected']
121 |             
    | ^^^^^^^^^^^^
122 |             data["phrase_mappings"] = mappings
123 |             with open(corrections_path, 'w') as f: json.dump(data, f, indent=2)
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\compile_session_traces.py:123:18
    |
122 |             data["phrase_mappings"] = mappings
123 |             with open(corrections_path, 'w') as f: json.dump(data, f, indent=2)
    |                  ^^^^
124 |             print(f"Applied {len(stats['critical_fails'])} corrections to {corrections_path}")
125 |         except Exception as e:
    |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
   --> src\tools\compile_session_traces.py:123:50
    |
122 |             data["phrase_mappings"] = mappings
123 |             with open(corrections_path, 'w') as f: json.dump(data, f, indent=2)
    |                                                  ^
124 |             print(f"Applied {len(stats['critical_fails'])} corrections to {corrections_path}")
125 |         except Exception as e:
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\compile_session_traces.py:129:15
    |
128 |     # Archival
129 |     archive = os.path.join(tdir, "archive")
    |               ^^^^^^^^^^^^
130 |     os.makedirs(archive, exist_ok=True)
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
    |

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
   --> src\tools\compile_session_traces.py:130:5
    |
128 |     # Archival
129 |     archive = os.path.join(tdir, "archive")
130 |     os.makedirs(archive, exist_ok=True)
    |     ^^^^^^^^^^^
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
132 |     print(f"Report generated: {rpath}")
    |
help: Replace with `Path(...).mkdir(parents=True)`

E701 Multiple statements on one line (colon)
   --> src\tools\compile_session_traces.py:131:19
    |
129 |     archive = os.path.join(tdir, "archive")
130 |     os.makedirs(archive, exist_ok=True)
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
    |                   ^
132 |     print(f"Report generated: {rpath}")
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\compile_session_traces.py:131:36
    |
129 |     archive = os.path.join(tdir, "archive")
130 |     os.makedirs(archive, exist_ok=True)
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
    |                                    ^^^^^^^^^^^^
132 |     print(f"Report generated: {rpath}")
    |

PTH119 `os.path.basename()` should be replaced by `Path.name`
   --> src\tools\compile_session_traces.py:131:58
    |
129 |     archive = os.path.join(tdir, "archive")
130 |     os.makedirs(archive, exist_ok=True)
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
    |                                                          ^^^^^^^^^^^^^^^^
132 |     print(f"Report generated: {rpath}")
    |
help: Replace with `Path(...).name`

W293 [*] Blank line contains whitespace
   --> src\tools\compile_session_traces.py:133:1
    |
131 |     for f in files: shutil.move(f, os.path.join(archive, os.path.basename(f)))
132 |     print(f"Report generated: {rpath}")
133 |     
    | ^^^^
134 |     return raw_traces, stats
    |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
   --> src\tools\compile_session_traces.py:136:27
    |
134 |     return raw_traces, stats
135 |
136 | if __name__ == "__main__": 
    |                           ^
137 |     compile_traces()
    |
help: Remove trailing whitespace

W292 [*] No newline at end of file
   --> src\tools\compile_session_traces.py:137:21
    |
136 | if __name__ == "__main__": 
137 |     compile_traces()
    |                     ^
    |
help: Add trailing newline

F401 [*] `os` imported but unused
  --> src\tools\danger_room.py:16:8
   |
14 | import json
15 | import logging
16 | import os
   |        ^^
17 | import sys
18 | from pathlib import Path
   |
help: Remove unused import: `os`

E402 Module level import not at top of file
  --> src\tools\danger_room.py:29:1
   |
27 |     sys.path.append(str(project_root))
28 |
29 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 | from src.cstar.core.uplink import query_bridge
   |

E402 Module level import not at top of file
  --> src\tools\danger_room.py:30:1
   |
29 | from src.core.ui import HUD
30 | from src.cstar.core.uplink import query_bridge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 | # Configure Logging
   |

E501 Line too long (106 > 100)
  --> src\tools\danger_room.py:43:101
   |
41 |     """Automated Scaffolding with Human Oversight."""
42 |
43 |     def __init__(self, target_limit: int = 1, max_retries: int = 3, token_limit_per_session: int = 50000):
   |                                                                                                     ^^^^^^
44 |         self.ledger_path = project_root / ".agent" / "tech_debt_ledger.json"
45 |         self.target_limit = target_limit
   |

W293 [*] Blank line contains whitespace
  --> src\tools\danger_room.py:48:1
   |
46 |         self.max_retries = max_retries
47 |         self.token_limit = token_limit_per_session # Heuristic for now
48 |         
   | ^^^^^^^^
49 |         # Enforce ALFRED persona
50 |         HUD.PERSONA = "ALFRED"
   |
help: Remove whitespace from blank line

E501 Line too long (102 > 100)
  --> src\tools\danger_room.py:55:101
   |
53 |         """Reads the tech debt ledger generated by Archive Consolidator."""
54 |         if not self.ledger_path.exists():
55 |             HUD.persona_log("WARN", "No tech debt ledger found. Run `archive_consolidator.py` first.")
   |                                                                                                     ^^
56 |             return []
   |

W293 [*] Blank line contains whitespace
  --> src\tools\danger_room.py:57:1
   |
55 |             HUD.persona_log("WARN", "No tech debt ledger found. Run `archive_consolidator.py` first.")
56 |             return []
57 |             
   | ^^^^^^^^^^^^
58 |         try:
59 |             data = json.loads(self.ledger_path.read_text(encoding="utf-8"))
   |
help: Remove whitespace from blank line

UP045 [*] Use `X | None` for type annotations
  --> src\tools\danger_room.py:67:59
   |
65 |             return []
66 |
67 |     async def _scaffold_test(self, file_path_str: str) -> Optional[str]:
   |                                                           ^^^^^^^^^^^^^
68 |         """Queries the bridge to generate a test suite."""
69 |         full_path = project_root / file_path_str
   |
help: Convert to `X | None`

W293 [*] Blank line contains whitespace
  --> src\tools\danger_room.py:72:1
   |
70 |         if not full_path.exists():
71 |             return None
72 |             
   | ^^^^^^^^^^^^
73 |         code_content = full_path.read_text(encoding="utf-8")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\danger_room.py:74:1
   |
73 |         code_content = full_path.read_text(encoding="utf-8")
74 |         
   | ^^^^^^^^
75 |         prompt = f"""
76 | [CRITICAL INSTRUCTION]
   |
help: Remove whitespace from blank line

W291 Trailing whitespace
  --> src\tools\danger_room.py:89:95
   |
87 | 2. You MUST verify the actual mathematical or logical state changes of the functions.
88 | 3. If dependencies must be mocked, ensure the return values are structurally realistic.
89 | 4. Output ONLY the raw Python code for the test file. No markdown formatting, no explanations. 
   |                                                                                               ^
90 | 5. Start the file strictly with standard imports (pytest, etc).
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\danger_room.py:98:1
   |
96 |             "target_interface": file_path_str
97 |         }
98 |         
   | ^^^^^^^^
99 |         HUD.persona_log("INFO", f"Bridging to Forge for {Path(file_path_str).name}...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:100:1
    |
 99 |         HUD.persona_log("INFO", f"Bridging to Forge for {Path(file_path_str).name}...")
100 |         
    | ^^^^^^^^
101 |         for attempt in range(self.max_retries):
102 |             try:
    |
help: Remove whitespace from blank line

E501 Line too long (108 > 100)
   --> src\tools\danger_room.py:105:101
    |
103 |                 response = await query_bridge(prompt, context)
104 |                 if response and response.get("status") == "success":
105 |                     # The bridge can sometimes wrap the code in JSON even for ALFRED if we didn't ask it to.
    |                                                                                                     ^^^^^^^^
106 |                     # Or it might return raw text based on our prompt.
107 |                     data = response.get("data", {})
    |

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:108:1
    |
106 |                     # Or it might return raw text based on our prompt.
107 |                     data = response.get("data", {})
108 |                     
    | ^^^^^^^^^^^^^^^^^^^^
109 |                     # Handle varying bridge return structures
110 |                     if isinstance(data, dict):
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:120:1
    |
118 |                     else:
119 |                         code = str(data)
120 |                         
    | ^^^^^^^^^^^^^^^^^^^^^^^^
121 |                     # Standard sanitize block
122 |                     return self._clean_markdown(code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:123:1
    |
121 |                     # Standard sanitize block
122 |                     return self._clean_markdown(code)
123 |                     
    | ^^^^^^^^^^^^^^^^^^^^
124 |             except Exception as e:
125 |                 HUD.persona_log("WARN", f"Forge attempt {attempt+1} failed: {e}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:127:1
    |
125 |                 HUD.persona_log("WARN", f"Forge attempt {attempt+1} failed: {e}")
126 |                 await asyncio.sleep(2)
127 |                 
    | ^^^^^^^^^^^^^^^^
128 |         HUD.persona_log("ERROR", "Max retries exceeded for scaffolding.")
129 |         return None
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:148:1
    |
146 |         HUD.box_row("TARGET", target_file, HUD.CYAN)
147 |         HUD.box_separator()
148 |         
    | ^^^^^^^^
149 |         lines = test_code.splitlines()
150 |         preview_lines = lines[:15]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:153:1
    |
151 |         for line in preview_lines:
152 |              HUD.box_row("  ", line, HUD.GREEN, dim_label=True)
153 |              
    | ^^^^^^^^^^^^^
154 |         if len(lines) > 15:
155 |              HUD.box_row("  ", f"... (+ {len(lines)-15} more lines)", HUD.GREEN, dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:156:1
    |
154 |         if len(lines) > 15:
155 |              HUD.box_row("  ", f"... (+ {len(lines)-15} more lines)", HUD.GREEN, dim_label=True)
156 |              
    | ^^^^^^^^^^^^^
157 |         HUD.box_separator()
158 |         try:
    |
help: Remove whitespace from blank line

E501 Line too long (156 > 100)
   --> src\tools\danger_room.py:160:101
    |
158 | â€¦
159 | â€¦tual.
160 | â€¦ir, I have generated a framework. Shall I commit this to the test matrix? (y/N): {HUD.RESET}")
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 | â€¦
162 | â€¦
    |

W291 [*] Trailing whitespace
   --> src\tools\danger_room.py:168:56
    |
166 |         """Writes the approved test to the tests directory."""
167 |         target_path = Path(target_file)
168 |         # Attempt to map it to a logical test position. 
    |                                                        ^
169 |         # By default, empire_tests serves as our integration/generated holding pen.
170 |         test_dir = project_root / "tests" / "empire_tests"
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:172:1
    |
170 |         test_dir = project_root / "tests" / "empire_tests"
171 |         test_dir.mkdir(parents=True, exist_ok=True)
172 |         
    | ^^^^^^^^
173 |         test_name = f"test_{target_path.name}"
174 |         test_path = test_dir / test_name
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:175:1
    |
173 |         test_name = f"test_{target_path.name}"
174 |         test_path = test_dir / test_name
175 |         
    | ^^^^^^^^
176 |         try:
177 |              test_path.write_text(test_code, encoding="utf-8")
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `execute`
   --> src\tools\danger_room.py:184:15
    |
182 |              return False
183 |
184 |     async def execute(self):
    |               ^^^^^^^
185 |         """Main execution sequence."""
186 |         HUD.box_top("[A] THE DANGER ROOM")
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:188:1
    |
186 |         HUD.box_top("[A] THE DANGER ROOM")
187 |         HUD.box_row("DIRECTIVE", "TEST SCAFFOLDING & VERIFICATION", HUD.CYAN)
188 |         
    | ^^^^^^^^
189 |         targets = self._read_ledger()
190 |         if not targets:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:194:1
    |
192 |             HUD.box_bottom()
193 |             return
194 |             
    | ^^^^^^^^^^^^
195 |         selected_targets = targets[:self.target_limit]
196 |         HUD.box_row("ISOLATED TARGETS", str(len(selected_targets)), HUD.YELLOW)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:197:1
    |
195 |         selected_targets = targets[:self.target_limit]
196 |         HUD.box_row("ISOLATED TARGETS", str(len(selected_targets)), HUD.YELLOW)
197 |         
    | ^^^^^^^^
198 |         for t in selected_targets:
199 |             file_str = t['file']
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:202:1
    |
200 |             HUD.box_separator()
201 |             HUD.box_row("ENGAGING", Path(file_str).name, HUD.MAGENTA)
202 |             
    | ^^^^^^^^^^^^
203 |             test_code = await self._scaffold_test(file_str)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:204:1
    |
203 |             test_code = await self._scaffold_test(file_str)
204 |             
    | ^^^^^^^^^^^^
205 |             if not test_code:
206 |                 HUD.box_row("RESULT", "Scaffolding Failed.", HUD.RED)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:208:1
    |
206 |                 HUD.box_row("RESULT", "Scaffolding Failed.", HUD.RED)
207 |                 continue
208 |                 
    | ^^^^^^^^^^^^^^^^
209 |             approved = self._human_review(file_str, test_code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:210:1
    |
209 |             approved = self._human_review(file_str, test_code)
210 |             
    | ^^^^^^^^^^^^
211 |             if approved:
212 |                 self._commit_test(file_str, test_code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\danger_room.py:215:1
    |
213 |             else:
214 |                 HUD.persona_log("INFO", "Scaffolding rejected by user. Discarding trace.")
215 |                 
    | ^^^^^^^^^^^^^^^^
216 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\tools\danger_room.py:218:5
    |
216 |         HUD.box_bottom()
217 |
218 | def main():
    |     ^^^^
219 |     parser = argparse.ArgumentParser(description="The Danger Room - Test Scaffolding")
220 |     parser.add_argument("--limit", type=int, default=1, help="Number of files to process per session")
    |
help: Add return type annotation: `int | None`

E501 Line too long (102 > 100)
   --> src\tools\danger_room.py:220:101
    |
218 | def main():
219 |     parser = argparse.ArgumentParser(description="The Danger Room - Test Scaffolding")
220 |     parser.add_argument("--limit", type=int, default=1, help="Number of files to process per session")
    |                                                                                                     ^^
221 |     args = parser.parse_args()
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
 --> src\tools\data\dedupe_corrections.py:5:8
  |
4 | path = '.agent/corrections.json'
5 | if not os.path.exists(path):
  |        ^^^^^^^^^^^^^^
6 |     print(f"File not found: {path}")
7 |     exit(0)
  |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\dedupe_corrections.py:9:6
   |
 7 |     exit(0)
 8 |
 9 | with open(path, 'r', encoding='utf-8') as f:
   |      ^^^^
10 |     try:
11 |         data = json.load(f)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\data\dedupe_corrections.py:9:17
   |
 7 |     exit(0)
 8 |
 9 | with open(path, 'r', encoding='utf-8') as f:
   |                 ^^^
10 |     try:
11 |         data = json.load(f)
   |
help: Remove mode argument

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\dedupe_corrections.py:26:6
   |
24 | }
25 |
26 | with open(path, 'w', encoding='utf-8') as f:
   |      ^^^^
27 |     json.dump(new_content, f, indent=4, ensure_ascii=False)
   |
help: Replace with `Path.open()`

F401 [*] `os` imported but unused
 --> src\tools\data\expand_thesaurus.py:1:8
  |
1 | import os
  |        ^^
2 | import re
  |
help: Remove unused import: `os`

PTH123 `open()` should be replaced by `Path.open()`
 --> src\tools\data\expand_thesaurus.py:5:6
  |
4 | path = 'thesaurus.md'
5 | with open(path, 'r', encoding='utf-8') as f:
  |      ^^^^
6 |     content = f.read()
  |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
 --> src\tools\data\expand_thesaurus.py:5:17
  |
4 | path = 'thesaurus.md'
5 | with open(path, 'r', encoding='utf-8') as f:
  |                 ^^^
6 |     content = f.read()
  |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\data\expand_thesaurus.py:17:1
   |
15 |     words = [w.strip() for w in syns_str.split(',')]
16 |     words.append(headword.strip())
17 |     
   | ^^^^
18 |     # Each word in the cluster should map to every other word
19 |     for w in words:
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\tools\data\expand_thesaurus.py:21:29
   |
19 |     for w in words:
20 |         w = w.lower()
21 |         if w not in inverted: inverted[w] = set()
   |                             ^
22 |         for other in words:
23 |             other = other.lower()
   |

C414 Unnecessary `list()` call within `sorted()`
  --> src\tools\data\expand_thesaurus.py:36:12
   |
35 | for w in sorted(inverted.keys()):
36 |     syns = sorted(list(inverted[w]))
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     new_lines.append(f"- **{w}**: {', '.join(syns)}")
   |
help: Remove the inner `list()` call

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\expand_thesaurus.py:39:6
   |
37 |     new_lines.append(f"- **{w}**: {', '.join(syns)}")
38 |
39 | with open(path, 'w', encoding='utf-8') as f:
   |      ^^^^
40 |     f.write('\n'.join(new_lines))
   |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\data\overfit_corrections.py:6:17
  |
5 | # Add script path for engine import
6 | sys.path.append(os.path.join('.agent', 'scripts'))
  |                 ^^^^^^^^^^^^
7 | from sv_engine import SovereignVector
  |

ANN201 Missing return type annotation for public function `overfit`
  --> src\tools\data\overfit_corrections.py:10:5
   |
10 | def overfit():
   |     ^^^^^^^
11 |     # Initialize engine
12 |     engine = SovereignVector(
   |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\overfit_corrections.py:23:10
   |
22 |     # Load test cases
23 |     with open('fishtest_data.json', 'r', encoding='utf-8') as f:
   |          ^^^^
24 |         cases = json.load(f).get('test_cases', [])
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\data\overfit_corrections.py:23:37
   |
22 |     # Load test cases
23 |     with open('fishtest_data.json', 'r', encoding='utf-8') as f:
   |                                     ^^^
24 |         cases = json.load(f).get('test_cases', [])
   |
help: Remove mode argument

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\overfit_corrections.py:27:10
   |
26 |     # Load existing corrections
27 |     with open('.agent/corrections.json', 'r', encoding='utf-8') as f:
   |          ^^^^
28 |         coords = json.load(f)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\data\overfit_corrections.py:27:42
   |
26 |     # Load existing corrections
27 |     with open('.agent/corrections.json', 'r', encoding='utf-8') as f:
   |                                          ^^^
28 |         coords = json.load(f)
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\data\overfit_corrections.py:29:1
   |
27 |     with open('.agent/corrections.json', 'r', encoding='utf-8') as f:
28 |         coords = json.load(f)
29 |     
   | ^^^^
30 |     phrase_mappings = coords.get('phrase_mappings', {})
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\data\overfit_corrections.py:36:1
   |
34 |         query = case['query'].lower().strip()
35 |         expected = case['expected']
36 |         
   | ^^^^^^^^
37 |         # Test current engine
38 |         results = engine.search(query)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\data\overfit_corrections.py:41:1
   |
39 |         top = results[0] if results else {}
40 |         actual = top.get('trigger')
41 |         
   | ^^^^^^^^
42 |         if actual != expected:
43 |             phrase_mappings[query] = expected
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\overfit_corrections.py:48:10
   |
46 |     # Save back
47 |     coords['phrase_mappings'] = phrase_mappings
48 |     with open('.agent/corrections.json', 'w', encoding='utf-8') as f:
   |          ^^^^
49 |         json.dump(coords, f, indent=4, ensure_ascii=False)
   |
help: Replace with `Path.open()`

F401 [*] `json` imported but unused
 --> src\tools\data\sanitize_thesaurus.py:1:8
  |
1 | import json
  |        ^^^^
2 |
3 | # Re-initialize the clusters properly
  |
help: Remove unused import: `json`

E501 Line too long (143 > 100)
 --> src\tools\data\sanitize_thesaurus.py:6:101
  |
4 | â€¦
5 | â€¦ "kick-off", "fire-up", "boot", "spin-up"],
6 | â€¦t", "finalize", "finish", "pack-up", "quit", "stop", "wind-down", "wrap", "wrap-it-up"],
  |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 | â€¦ "debug", "dig-into", "error", "find", "investigate", "issue", "linter", "look-into", "sentinel", "track-down", "validate", "verify"],
8 | â€¦te", "develop", "feature", "generate", "implement", "make", "page", "run-task", "update", "modification"],
  |

E501 Line too long (189 > 100)
 --> src\tools\data\sanitize_thesaurus.py:7:101
  |
5 | â€¦ "boot", "spin-up"],
6 | â€¦", "pack-up", "quit", "stop", "wind-down", "wrap", "wrap-it-up"],
7 | â€¦error", "find", "investigate", "issue", "linter", "look-into", "sentinel", "track-down", "validate", "verify"],
  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | â€¦e", "generate", "implement", "make", "page", "run-task", "update", "modification"],
9 | â€¦epare", "strategy", "roadmap", "itinerary"],
  |

E501 Line too long (161 > 100)
  --> src\tools\data\sanitize_thesaurus.py:8:101
   |
 6 | â€¦lize", "finish", "pack-up", "quit", "stop", "wind-down", "wrap", "wrap-it-up"],
 7 | â€¦ "dig-into", "error", "find", "investigate", "issue", "linter", "look-into", "sentinel", "track-down", "validate", "verify"],
 8 | â€¦elop", "feature", "generate", "implement", "make", "page", "run-task", "update", "modification"],
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 | â€¦", "plan", "prepare", "strategy", "roadmap", "itinerary"],
10 | â€¦erify", "validate", "test", "verification"],
   |

E501 Line too long (122 > 100)
  --> src\tools\data\sanitize_thesaurus.py:9:101
   |
 7 |     "investigate": ["analyze", "audit", "bug", "check", "debug", "dig-into", "error", "find", "investigate", "issue", "linter", "look-â€¦
 8 |     "create": ["build", "component", "construct", "create", "develop", "feature", "generate", "implement", "make", "page", "run-task",â€¦
 9 |     "plan": ["architect", "blueprint", "design", "map", "outline", "plan", "prepare", "strategy", "roadmap", "itinerary"],
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
10 |     "test": ["check", "integrity", "performance", "validity", "verify", "validate", "test", "verification"],
11 |     "deploy": ["deploy", "deployment", "launch", "push", "release", "ship", "publish"],
   |

E501 Line too long (108 > 100)
  --> src\tools\data\sanitize_thesaurus.py:10:101
   |
 8 |     "create": ["build", "component", "construct", "create", "develop", "feature", "generate", "implement", "make", "page", "run-task",â€¦
 9 |     "plan": ["architect", "blueprint", "design", "map", "outline", "plan", "prepare", "strategy", "roadmap", "itinerary"],
10 |     "test": ["check", "integrity", "performance", "validity", "verify", "validate", "test", "verification"],
   |                                                                                                     ^^^^^^^^
11 |     "deploy": ["deploy", "deployment", "launch", "push", "release", "ship", "publish"],
12 |     "git": ["commit", "merge", "rebase", "git-assistant", "repo", "repository", "github"],
   |

E501 Line too long (175 > 100)
  --> src\tools\data\sanitize_thesaurus.py:14:101
   |
12 | â€¦sitory", "github"],
13 | â€¦ht", "playwright-e2e"],
14 | â€¦, "sci-fi", "ui-sci-fi", "visual", "beautify", "clean", "improve", "polish", "refine", "sovereignfish"],
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 | â€¦ "performance", "quick", "reinforcement", "rl", "speed", "velocity", "benchmark", "measure", "metrics", "perf", "perf-profiler", "proâ€¦
16 | â€¦ "scour", "hunter", "documentation", "knowledge-hunter"],
   |

E501 Line too long (221 > 100)
  --> src\tools\data\sanitize_thesaurus.py:15:101
   |
13 | â€¦
14 | â€¦, "visual", "beautify", "clean", "improve", "polish", "refine", "sovereignfish"],
15 | â€¦, "reinforcement", "rl", "speed", "velocity", "benchmark", "measure", "metrics", "perf", "perf-profiler", "profile", "timing"],
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 | â€¦cumentation", "knowledge-hunter"],
17 | â€¦me", "document", "write-docs", "write-documentation"],
   |

E501 Line too long (128 > 100)
  --> src\tools\data\sanitize_thesaurus.py:16:101
   |
14 |     "futuristic": ["aesthetics", "glass", "glow", "holographic", "neon", "sci-fi", "ui-sci-fi", "visual", "beautify", "clean", "improvâ€¦
15 |     "optimize": ["agent-lightning", "fast", "optimization", "optimize", "performance", "quick", "reinforcement", "rl", "speed", "velocâ€¦
16 |     "knowledge": ["search", "find", "where-is", "how-does", "research", "scour", "hunter", "documentation", "knowledge-hunter"],
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |     "docs": ["api-docs", "doc-generator", "docs", "docstring", "documentation", "jsdoc", "readme", "document", "write-docs", "write-doâ€¦
18 |     "health": ["agent-health", "status", "pulse", "monitoring", "heartbeat"]
   |

E501 Line too long (148 > 100)
  --> src\tools\data\sanitize_thesaurus.py:17:101
   |
15 | â€¦, "optimize", "performance", "quick", "reinforcement", "rl", "speed", "velocity", "benchmark", "measure", "metrics", "perf", "perf-prâ€¦
16 | â€¦, "research", "scour", "hunter", "documentation", "knowledge-hunter"],
17 | â€¦ng", "documentation", "jsdoc", "readme", "document", "write-docs", "write-documentation"],
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 | â€¦ing", "heartbeat"]
19 | â€¦
   |

RUF005 Consider `[*syns, head]` instead of concatenation
  --> src\tools\data\sanitize_thesaurus.py:24:13
   |
22 | inverted = {}
23 | for head, syns in clusters.items():
24 |     words = syns + [head]
   |             ^^^^^^^^^^^^^
25 |     for w in set(words):
26 |         w = w.lower().strip()
   |
help: Replace with `[*syns, head]`

E701 Multiple statements on one line (colon)
  --> src\tools\data\sanitize_thesaurus.py:27:17
   |
25 |     for w in set(words):
26 |         w = w.lower().strip()
27 |         if not w: continue
   |                 ^
28 |         if w not in inverted: inverted[w] = set()
29 |         for other in words:
   |

E701 Multiple statements on one line (colon)
  --> src\tools\data\sanitize_thesaurus.py:28:29
   |
26 |         w = w.lower().strip()
27 |         if not w: continue
28 |         if w not in inverted: inverted[w] = set()
   |                             ^
29 |         for other in words:
30 |             other = other.lower().strip()
   |

E501 Line too long (106 > 100)
  --> src\tools\data\sanitize_thesaurus.py:35:100
   |
34 | # Build file
35 | lines = ["# Corvus Star Thesaurus (Sanitized Expanded Version)", "", "## ðŸŒŠ Expanded Intent Clusters", ""]
   |                                                                                                     ^^^^^^
36 | for w in sorted(inverted.keys()):
37 |     syns = sorted(list(inverted[w]))
   |

C414 Unnecessary `list()` call within `sorted()`
  --> src\tools\data\sanitize_thesaurus.py:37:12
   |
35 | lines = ["# Corvus Star Thesaurus (Sanitized Expanded Version)", "", "## ðŸŒŠ Expanded Intent Clusters", ""]
36 | for w in sorted(inverted.keys()):
37 |     syns = sorted(list(inverted[w]))
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     lines.append(f"- **{w}**: {', '.join(syns)}")
   |
help: Remove the inner `list()` call

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\data\sanitize_thesaurus.py:40:6
   |
38 |     lines.append(f"- **{w}**: {', '.join(syns)}")
39 |
40 | with open('thesaurus.md', 'w', encoding='utf-8') as f:
   |      ^^^^
41 |     f.write('\n'.join(lines))
   |
help: Replace with `Path.open()`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\tools\debt_viz.py:12:1
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | # Ensure we can import shared UI
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src\tools\debt_viz.py:12:1
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | # Ensure we can import shared UI
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src\tools\debt_viz.py:12:1
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | # Ensure we can import shared UI
   |

F401 [*] `typing.Optional` imported but unused
  --> src\tools\debt_viz.py:12:37
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   |                                     ^^^^^^^^
13 |
14 | # Ensure we can import shared UI
   |
help: Remove unused import

F401 [*] `typing.Tuple` imported but unused
  --> src\tools\debt_viz.py:12:47
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional, Tuple
   |                                               ^^^^^
13 |
14 | # Ensure we can import shared UI
   |
help: Remove unused import

E702 Multiple statements on one line (semicolon)
  --> src\tools\debt_viz.py:21:25
   |
19 |     # Fallback if not in the expected structure
20 |     class HUD:
21 |         RED = "\033[31m"; YELLOW = "\033[33m"; GREEN = "\033[32m"
   |                         ^
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
23 |         @staticmethod
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\debt_viz.py:21:46
   |
19 |     # Fallback if not in the expected structure
20 |     class HUD:
21 |         RED = "\033[31m"; YELLOW = "\033[33m"; GREEN = "\033[32m"
   |                                              ^
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
23 |         @staticmethod
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\debt_viz.py:22:26
   |
20 |     class HUD:
21 |         RED = "\033[31m"; YELLOW = "\033[33m"; GREEN = "\033[32m"
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
   |                          ^
23 |         @staticmethod
24 |         def box_top(t): print(t)
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\debt_viz.py:22:45
   |
20 |     class HUD:
21 |         RED = "\033[31m"; YELLOW = "\033[33m"; GREEN = "\033[32m"
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
   |                                             ^
23 |         @staticmethod
24 |         def box_top(t): print(t)
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\debt_viz.py:22:63
   |
20 |     class HUD:
21 |         RED = "\033[31m"; YELLOW = "\033[33m"; GREEN = "\033[32m"
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
   |                                                               ^
23 |         @staticmethod
24 |         def box_top(t): print(t)
   |

ANN205 Missing return type annotation for staticmethod `box_top`
  --> src\tools\debt_viz.py:24:13
   |
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
23 |         @staticmethod
24 |         def box_top(t): print(t)
   |             ^^^^^^^
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `t`
  --> src\tools\debt_viz.py:24:21
   |
22 |         CYAN = "\033[36m"; RESET = "\033[0m"; BOLD = "\033[1m"; DIM = "\033[2m"
23 |         @staticmethod
24 |         def box_top(t): print(t)
   |                     ^
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |

ANN205 Missing return type annotation for staticmethod `box_row`
  --> src\tools\debt_viz.py:26:13
   |
24 |         def box_top(t): print(t)
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |             ^^^^^^^
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |
help: Add return type annotation: `None`

E741 Ambiguous variable name: `l`
  --> src\tools\debt_viz.py:26:21
   |
24 |         def box_top(t): print(t)
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |                     ^
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |

ANN001 Missing type annotation for function argument `l`
  --> src\tools\debt_viz.py:26:21
   |
24 |         def box_top(t): print(t)
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |                     ^
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |

ANN001 Missing type annotation for function argument `v`
  --> src\tools\debt_viz.py:26:24
   |
24 |         def box_top(t): print(t)
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |                        ^
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |

ANN003 Missing type annotation for `**k`
  --> src\tools\debt_viz.py:26:27
   |
24 |         def box_top(t): print(t)
25 |         @staticmethod
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
   |                           ^^^
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |

ANN205 Missing return type annotation for staticmethod `box_separator`
  --> src\tools\debt_viz.py:28:13
   |
26 |         def box_row(l, v, **k): print(f"{l}: {v}")
27 |         @staticmethod
28 |         def box_separator(): print("-" * 60)
   |             ^^^^^^^^^^^^^
29 |         @staticmethod
30 |         def box_bottom(): print("-" * 60)
   |
help: Add return type annotation: `None`

ANN205 Missing return type annotation for staticmethod `box_bottom`
  --> src\tools\debt_viz.py:30:13
   |
28 |         def box_separator(): print("-" * 60)
29 |         @staticmethod
30 |         def box_bottom(): print("-" * 60)
   |             ^^^^^^^^^^
31 |         @staticmethod
32 |         def log(lv, msg, d=""): print(f"[{lv}] {msg} {d}")
   |
help: Add return type annotation: `None`

ANN205 Missing return type annotation for staticmethod `log`
  --> src\tools\debt_viz.py:32:13
   |
30 |         def box_bottom(): print("-" * 60)
31 |         @staticmethod
32 |         def log(lv, msg, d=""): print(f"[{lv}] {msg} {d}")
   |             ^^^
33 |
34 | try:
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `lv`
  --> src\tools\debt_viz.py:32:17
   |
30 |         def box_bottom(): print("-" * 60)
31 |         @staticmethod
32 |         def log(lv, msg, d=""): print(f"[{lv}] {msg} {d}")
   |                 ^^
33 |
34 | try:
   |

ANN001 Missing type annotation for function argument `msg`
  --> src\tools\debt_viz.py:32:21
   |
30 |         def box_bottom(): print("-" * 60)
31 |         @staticmethod
32 |         def log(lv, msg, d=""): print(f"[{lv}] {msg} {d}")
   |                     ^^^
33 |
34 | try:
   |

ANN001 Missing type annotation for function argument `d`
  --> src\tools\debt_viz.py:32:26
   |
30 |         def box_bottom(): print("-" * 60)
31 |         @staticmethod
32 |         def log(lv, msg, d=""): print(f"[{lv}] {msg} {d}")
   |                          ^
33 |
34 | try:
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\tools\debt_viz.py:47:19
   |
45 |     """
46 |
47 |     IGNORE_DIRS = {".venv", ".git", "__pycache__", "mock_project", "node_modules"}
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |     HUD_WIDTH = 80
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\debt_viz.py:52:21
   |
50 |     def __init__(self, root_path: str = ".") -> None:
51 |         self.root_path = Path(root_path).absolute()
52 |         self.files: List[Path] = []
   |                     ^^^^
53 |         self.blocks: List[Dict[str, Any]] = []
54 |         self.distribution: Dict[str, int] = {"A": 0, "B": 0, "C": 0, "D": 0, "E": 0, "F": 0}
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\debt_viz.py:53:22
   |
51 |         self.root_path = Path(root_path).absolute()
52 |         self.files: List[Path] = []
53 |         self.blocks: List[Dict[str, Any]] = []
   |                      ^^^^
54 |         self.distribution: Dict[str, int] = {"A": 0, "B": 0, "C": 0, "D": 0, "E": 0, "F": 0}
55 |         self.avg_cc: float = 0.0
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\debt_viz.py:53:27
   |
51 |         self.root_path = Path(root_path).absolute()
52 |         self.files: List[Path] = []
53 |         self.blocks: List[Dict[str, Any]] = []
   |                           ^^^^
54 |         self.distribution: Dict[str, int] = {"A": 0, "B": 0, "C": 0, "D": 0, "E": 0, "F": 0}
55 |         self.avg_cc: float = 0.0
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\debt_viz.py:54:28
   |
52 |         self.files: List[Path] = []
53 |         self.blocks: List[Dict[str, Any]] = []
54 |         self.distribution: Dict[str, int] = {"A": 0, "B": 0, "C": 0, "D": 0, "E": 0, "F": 0}
   |                            ^^^^
55 |         self.avg_cc: float = 0.0
   |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
  --> src\tools\debt_viz.py:75:1
   |
73 |         count = 0
74 |         cwd = Path.cwd()
75 |         
   | ^^^^^^^^
76 |         for f in self.files:
77 |             try:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debt_viz.py:86:1
   |
84 |                         total_cc += b.complexity
85 |                         count += 1
86 |                         
   | ^^^^^^^^^^^^^^^^^^^^^^^^
87 |                         try:
88 |                             rel_file = str(f.relative_to(cwd))
   |
help: Remove whitespace from blank line

UP024 [*] Replace aliased errors with `OSError`
   --> src\tools\debt_viz.py:103:20
    |
101 |                 if log_errors:
102 |                     HUD.log("WARN", "Parse Failure", f.name)
103 |             except (IOError, PermissionError) as e:
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |                 if log_errors:
105 |                     HUD.log("FAIL", "IO Error", f"{f.name} ({str(e)})")
    |
help: Replace with builtin `OSError`

RUF010 [*] Use explicit conversion flag
   --> src\tools\debt_viz.py:105:62
    |
103 |             except (IOError, PermissionError) as e:
104 |                 if log_errors:
105 |                     HUD.log("FAIL", "IO Error", f"{f.name} ({str(e)})")
    |                                                              ^^^^^^
106 |             except Exception as e:
107 |                 if log_errors:
    |
help: Replace with conversion flag

RUF010 [*] Use explicit conversion flag
   --> src\tools\debt_viz.py:108:70
    |
106 |             except Exception as e:
107 |                 if log_errors:
108 |                     HUD.log("WARN", "Complexity Error", f"{f.name} ({str(e)})")
    |                                                                      ^^^^^^
109 |                 
110 |         self.avg_cc = total_cc / count if count > 0 else 0
    |
help: Replace with conversion flag

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:109:1
    |
107 |                 if log_errors:
108 |                     HUD.log("WARN", "Complexity Error", f"{f.name} ({str(e)})")
109 |                 
    | ^^^^^^^^^^^^^^^^
110 |         self.avg_cc = total_cc / count if count > 0 else 0
111 |         return len(self.blocks) > 0
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:127:1
    |
125 |         """Renders the HUD-styled complexity report."""
126 |         os.environ["HUD_WIDTH"] = str(self.HUD_WIDTH)
127 |         
    | ^^^^^^^^
128 |         # Sort blocks by CC descending
129 |         top_offenders = sorted(self.blocks, key=lambda x: x['cc'], reverse=True)[:10]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:130:1
    |
128 |         # Sort blocks by CC descending
129 |         top_offenders = sorted(self.blocks, key=lambda x: x['cc'], reverse=True)[:10]
130 |         
    | ^^^^^^^^
131 |         avg_rank = cc_rank(int(self.avg_cc)) if self.avg_cc > 0 else "A"
132 |         avg_color = HUD.GREEN if avg_rank == 'A' else (HUD.YELLOW if avg_rank in ['B', 'C'] else HUD.RED)
    |
help: Remove whitespace from blank line

E501 Line too long (105 > 100)
   --> src\tools\debt_viz.py:132:101
    |
131 |         avg_rank = cc_rank(int(self.avg_cc)) if self.avg_cc > 0 else "A"
132 |         avg_color = HUD.GREEN if avg_rank == 'A' else (HUD.YELLOW if avg_rank in ['B', 'C'] else HUD.RED)
    |                                                                                                     ^^^^^
133 |         
134 |         HUD.box_top("COMBAT ANALYSIS [RADON]")
    |

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:133:1
    |
131 |         avg_rank = cc_rank(int(self.avg_cc)) if self.avg_cc > 0 else "A"
132 |         avg_color = HUD.GREEN if avg_rank == 'A' else (HUD.YELLOW if avg_rank in ['B', 'C'] else HUD.RED)
133 |         
    | ^^^^^^^^
134 |         HUD.box_top("COMBAT ANALYSIS [RADON]")
135 |         HUD.box_row("TARGET", str(self.root_path))
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:139:1
    |
137 |         HUD.box_row("AVG COMPLEXITY", f"{self.avg_cc:.1f} ({avg_rank})", color=avg_color)
138 |         HUD.box_separator()
139 |         
    | ^^^^^^^^
140 |         HUD.box_row("[WAR ZONES]", "TOP OFFENDERS", dim_label=True)
141 |         for i, b in enumerate(top_offenders, 1):
    |
help: Remove whitespace from blank line

E501 Line too long (107 > 100)
   --> src\tools\debt_viz.py:142:101
    |
140 |         HUD.box_row("[WAR ZONES]", "TOP OFFENDERS", dim_label=True)
141 |         for i, b in enumerate(top_offenders, 1):
142 |             color = HUD.GREEN if b['rank'] == 'A' else (HUD.YELLOW if b['rank'] in ['B', 'C'] else HUD.RED)
    |                                                                                                     ^^^^^^^
143 |             rank_str = f"[{b['rank']}]"
144 |             label = f"{i}. {rank_str} {b['cc']:<3} {b['file']}"
    |

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:146:1
    |
144 |             label = f"{i}. {rank_str} {b['cc']:<3} {b['file']}"
145 |             HUD.box_row(label[:24], f"{b['name']} ({b['type']})", color=color)
146 |         
    | ^^^^^^^^
147 |         HUD.box_separator()
148 |         HUD.box_row("[DISTRIBUTION]", "CODEBASE SPREAD", dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:149:1
    |
147 |         HUD.box_separator()
148 |         HUD.box_row("[DISTRIBUTION]", "CODEBASE SPREAD", dim_label=True)
149 |         
    | ^^^^^^^^
150 |         total_items = sum(self.distribution.values())
151 |         if total_items > 0:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:158:1
    |
156 |                 bar = "â–ˆ" * bar_len + "â–‘" * (30 - bar_len)
157 |                 HUD.box_row(f"Rank {rank}", f"{bar} {perc:>3.0f}% ({count})")
158 |                 
    | ^^^^^^^^^^^^^^^^
159 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\debt_viz.py:168:1
    |
166 |     parser.add_argument("--json", action="store_true", help="Output in JSON format")
167 |     args = parser.parse_args()
168 |     
    | ^^^^
169 |     analyzer = DebtAnalyzer(args.path)
170 |     if not analyzer.analyze():
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\tools\debt_viz.py:184:11
    |
183 | if __name__ == "__main__":
184 |     main()
    |           ^
    |
help: Add trailing newline

F401 [*] `json` imported but unused
  --> src\tools\debug\audit_dialogue.py:9:8
   |
 8 | import argparse
 9 | import json
   |        ^^^^
10 | import sys
11 | from pathlib import Path
   |
help: Remove unused import: `json`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\tools\debug\audit_dialogue.py:12:1
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | # Ensure src can be imported
   |

F401 [*] `typing.Any` imported but unused
  --> src\tools\debug\audit_dialogue.py:12:20
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, Optional
   |                    ^^^
13 |
14 | # Ensure src can be imported
   |
help: Remove unused import

F401 [*] `typing.Dict` imported but unused
  --> src\tools\debug\audit_dialogue.py:12:25
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, Optional
   |                         ^^^^
13 |
14 | # Ensure src can be imported
   |
help: Remove unused import

F401 [*] `typing.Optional` imported but unused
  --> src\tools\debug\audit_dialogue.py:12:31
   |
10 | import sys
11 | from pathlib import Path
12 | from typing import Any, Dict, Optional
   |                               ^^^^^^^^
13 |
14 | # Ensure src can be imported
   |
help: Remove unused import

E402 Module level import not at top of file
  --> src\tools\debug\audit_dialogue.py:20:1
   |
19 | # [ALFRED] Use standard imports from project root
20 | from src.core.sv_engine import SovereignEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 | from src.core.ui import HUD
22 | from src.core.engine.dialogue import DialogueEngine
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\debug\audit_dialogue.py:20:1
   |
19 |   # [ALFRED] Use standard imports from project root
20 | / from src.core.sv_engine import SovereignEngine
21 | | from src.core.ui import HUD
22 | | from src.core.engine.dialogue import DialogueEngine
   | |___________________________________________________^
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\tools\debug\audit_dialogue.py:21:1
   |
19 | # [ALFRED] Use standard imports from project root
20 | from src.core.sv_engine import SovereignEngine
21 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 | from src.core.engine.dialogue import DialogueEngine
   |

E402 Module level import not at top of file
  --> src\tools\debug\audit_dialogue.py:22:1
   |
20 | from src.core.sv_engine import SovereignEngine
21 | from src.core.ui import HUD
22 | from src.core.engine.dialogue import DialogueEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:34:1
   |
32 |         self.project_root = PROJECT_ROOT
33 |         self.base_path = self.project_root / ".agent"
34 |         
   | ^^^^^^^^
35 |         # Initialize Engine
36 |         self.engine = SovereignEngine(self.project_root)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:47:1
   |
45 |         voice_file = ("O.D.I.N." if self.persona in ["GOD", "O.D.I.N."] else "alfred") + ".qmd"
46 |         dialogue_path = self._resolve(self.project_root, voice_file, "dialogue_db")
47 |         
   | ^^^^^^^^
48 |         # [ALFRED] Use DialogueEngine for context-aware audit
49 |         HUD.DIALOGUE = DialogueEngine(str(dialogue_path))
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:54:1
   |
52 |         # Calculate purity
53 |         score = self.engine.score_identity(text, self.persona)
54 |         
   | ^^^^^^^^
55 |         # Visual Output
56 |         HUD.box_top("IDENTITY PURITY AUDIT")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:58:1
   |
56 |         HUD.box_top("IDENTITY PURITY AUDIT")
57 |         HUD.box_row("PERSONA", self.persona, HUD.MAGENTA)
58 |         
   | ^^^^^^^^
59 |         bar = HUD.progress_bar(score)
60 |         color = HUD.GREEN if score > 0.4 else HUD.RED
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:62:1
   |
60 |         color = HUD.GREEN if score > 0.4 else HUD.RED
61 |         HUD.box_row("PURITY SCORE", f"{bar} {score:.2f}", color)
62 |         
   | ^^^^^^^^
63 |         if score > 0.4:
64 |             msg = "SOUL ALIGNMENT: STABLE" if self.persona in ["GOD", "O.D.I.N."] else "Fidelity check passed, sir."
   |
help: Remove whitespace from blank line

E501 Line too long (112 > 100)
  --> src\tools\debug\audit_dialogue.py:64:101
   |
63 |         if score > 0.4:
64 |             msg = "SOUL ALIGNMENT: STABLE" if self.persona in ["GOD", "O.D.I.N."] else "Fidelity check passed, sir."
   |                                                                                                     ^^^^^^^^^^^^
65 |             HUD.persona_log("SUCCESS", msg)
66 |         else:
   |

E501 Line too long (141 > 100)
  --> src\tools\debug\audit_dialogue.py:67:101
   |
65 | â€¦
66 | â€¦
67 | â€¦ if self.persona in ["GOD", "O.D.I.N."] else "I'm concerned about our tone stability, sir."
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 | â€¦
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\audit_dialogue.py:69:1
   |
67 | â€¦         msg = "DEVIANCE DETECTED. PURGE ENHANCED." if self.persona in ["GOD", "O.D.I.N."] else "I'm concerned about our tone stability, â€¦
68 | â€¦         HUD.persona_log("FAIL", msg)
69 | â€¦     
   ^^^^^^^^
70 | â€¦     HUD.box_bottom()
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
  --> src\tools\debug\audit_dialogue.py:73:5
   |
73 | def main():
   |     ^^^^
74 |     parser = argparse.ArgumentParser(description="Audit dialogue for persona alignment")
75 |     parser.add_argument("text", help="Text to audit")
   |
help: Add return type annotation: `None`

W292 [*] No newline at end of file
  --> src\tools\debug\audit_dialogue.py:84:11
   |
83 | if __name__ == "__main__":
84 |     main()
   |           ^
   |
help: Add trailing newline

F401 [*] `os` imported but unused
 --> src\tools\debug\catalog_check.py:1:8
  |
1 | import os
  |        ^^
2 | import sys
  |
help: Remove unused import: `os`

W291 [*] Trailing whitespace
  --> src\tools\debug\catalog_check.py:22:18
   |
20 |     # 2. Engine Initialization
21 |     e = SovereignVector(
22 |         THE_FILE, 
   |                  ^
23 |         CORR_FILE, 
24 |         STOP_FILE
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\debug\catalog_check.py:23:19
   |
21 |     e = SovereignVector(
22 |         THE_FILE, 
23 |         CORR_FILE, 
   |                   ^
24 |         STOP_FILE
25 |     )
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\debug\catalog_check.py:32:1
   |
30 |     query = "catalog start"
31 |     r = e.search(query)
32 |     
   | ^^^^
33 |     # Required output checks (Gherkin validation points)
34 |     print(f"Tokens: {e.tokenize(query)}")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\catalog_check.py:36:1
   |
34 |     print(f"Tokens: {e.tokenize(query)}")
35 |     print(f"Trigger Map for 'start': {e.trigger_map.get('start')}")
36 |     
   | ^^^^
37 |     if r:
38 |         print(f"Top Result: {r[0]}")
   |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
  --> src\tools\debug\catalog_check.py:46:16
   |
44 | except Exception as ex:
45 |     print(f"Critical execution failure: {ex}")
46 |     sys.exit(1)
   |                ^
   |
help: Add trailing newline

ANN201 Missing return type annotation for public function `main`
  --> src\tools\debug\check_pro.py:8:5
   |
 8 | def main():
   |     ^^^^
 9 |     """
10 |     Initializes the genai client, iterates through a list of candidate models,
   |
help: Add return type annotation: `int`

F841 Local variable `response` is assigned to but never used
  --> src\tools\debug\check_pro.py:35:13
   |
33 |         try:
34 |             # This network call will be mocked during tests
35 |             response = client.models.generate_content(
   |             ^^^^^^^^
36 |                 model=model_name,
37 |                 contents="Hello, are you online?"
   |
help: Remove assignment to unused variable `response`

W293 [*] Blank line contains whitespace
  --> src\tools\debug\check_pro.py:42:1
   |
40 |         except Exception as e:
41 |             print(f"FAILED ({e})")
42 |     
   | ^^^^
43 |     return 0 # Return success code
   |
help: Remove whitespace from blank line

F401 [*] `json` imported but unused
 --> src\tools\debug\cjk_check.py:1:8
  |
1 | import json
  |        ^^^^
2 | import os
3 | import sys
  |
help: Remove unused import: `json`

F401 [*] `os` imported but unused
 --> src\tools\debug\cjk_check.py:2:8
  |
1 | import json
2 | import os
  |        ^^
3 | import sys
  |
help: Remove unused import: `os`

ANN201 Missing return type annotation for public function `search_and_print`
  --> src\tools\debug\cjk_check.py:17:5
   |
15 | e.build_index()
16 |
17 | def search_and_print(query):
   |     ^^^^^^^^^^^^^^^^
18 |     r = e.search(query)
19 |     if r:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
  --> src\tools\debug\cjk_check.py:17:22
   |
15 | e.build_index()
16 |
17 | def search_and_print(query):
   |                      ^^^^^
18 |     r = e.search(query)
19 |     if r:
   |

W292 [*] No newline at end of file
  --> src\tools\debug\cjk_check.py:35:35
   |
33 |     # Non-existent CJK term
34 |     q2 = "ä¸å­˜åœ¨çš„è¯è¯­"
35 |     result2 = search_and_print(q2)
   |                                   ^
   |
help: Add trailing newline

ANN201 Missing return type annotation for public function `run_collision_investigation`
  --> src\tools\debug\collision_investigator.py:10:5
   |
10 | def run_collision_investigation():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |     """
12 |     Initializes SovereignVector, loads skills, builds the index,
   |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\debug\collision_investigator.py:22:14
   |
21 |     try:
22 |         with open('.agent/config.json', 'r') as f:
   |              ^^^^
23 |             config = json.load(f)
24 |     except FileNotFoundError:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\debug\collision_investigator.py:22:41
   |
21 |     try:
22 |         with open('.agent/config.json', 'r') as f:
   |                                         ^^^
23 |             config = json.load(f)
24 |     except FileNotFoundError:
   |
help: Remove mode argument

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\debug\collision_investigator.py:32:17
   |
30 |     e.load_skills_from_dir('.agent/skills')
31 |     root = config.get("FrameworkRoot")
32 |     if root and os.path.exists(os.path.join(root, "skills_db")):
   |                 ^^^^^^^^^^^^^^
33 |         e.load_skills_from_dir(os.path.join(root, "skills_db"), prefix="GLOBAL:")
   |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\collision_investigator.py:32:32
   |
30 |     e.load_skills_from_dir('.agent/skills')
31 |     root = config.get("FrameworkRoot")
32 |     if root and os.path.exists(os.path.join(root, "skills_db")):
   |                                ^^^^^^^^^^^^
33 |         e.load_skills_from_dir(os.path.join(root, "skills_db"), prefix="GLOBAL:")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\collision_investigator.py:33:32
   |
31 |     root = config.get("FrameworkRoot")
32 |     if root and os.path.exists(os.path.join(root, "skills_db")):
33 |         e.load_skills_from_dir(os.path.join(root, "skills_db"), prefix="GLOBAL:")
   |                                ^^^^^^^^^^^^
34 |     
35 |     print("Building index...")
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\collision_investigator.py:34:1
   |
32 |     if root and os.path.exists(os.path.join(root, "skills_db")):
33 |         e.load_skills_from_dir(os.path.join(root, "skills_db"), prefix="GLOBAL:")
34 |     
   | ^^^^
35 |     print("Building index...")
36 |     e.build_index()
   |
help: Remove whitespace from blank line

F401 [*] `json` imported but unused
 --> src\tools\debug\debug_engine.py:1:8
  |
1 | import json
  |        ^^^^
2 | import os
3 | import re
  |
help: Remove unused import: `json`

F401 [*] `re` imported but unused
 --> src\tools\debug\debug_engine.py:3:8
  |
1 | import json
2 | import os
3 | import re
  |        ^^
4 | import sys
  |
help: Remove unused import: `re`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\debug\debug_engine.py:7:17
  |
6 | # Add script path for engine import
7 | sys.path.append(os.path.join(os.getcwd(), ".agent", "scripts"))
  |                 ^^^^^^^^^^^^
8 | from sv_engine import HUD, SovereignVector
  |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
 --> src\tools\debug\debug_engine.py:7:30
  |
6 | # Add script path for engine import
7 | sys.path.append(os.path.join(os.getcwd(), ".agent", "scripts"))
  |                              ^^^^^^^^^
8 | from sv_engine import HUD, SovereignVector
  |
help: Replace with `Path.cwd()`

F401 [*] `sv_engine.HUD` imported but unused
 --> src\tools\debug\debug_engine.py:8:23
  |
6 | # Add script path for engine import
7 | sys.path.append(os.path.join(os.getcwd(), ".agent", "scripts"))
8 | from sv_engine import HUD, SovereignVector
  |                       ^^^
  |
help: Remove unused import: `sv_engine.HUD`

ANN201 Missing return type annotation for public function `debug_query`
  --> src\tools\debug\debug_engine.py:11:5
   |
11 | def debug_query(query):
   |     ^^^^^^^^^^^
12 |     cur_dir = os.getcwd()
13 |     base = os.path.join(cur_dir, ".agent")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `query`
  --> src\tools\debug\debug_engine.py:11:17
   |
11 | def debug_query(query):
   |                 ^^^^^
12 |     cur_dir = os.getcwd()
13 |     base = os.path.join(cur_dir, ".agent")
   |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> src\tools\debug\debug_engine.py:12:15
   |
11 | def debug_query(query):
12 |     cur_dir = os.getcwd()
   |               ^^^^^^^^^
13 |     base = os.path.join(cur_dir, ".agent")
   |
help: Replace with `Path.cwd()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:13:12
   |
11 | def debug_query(query):
12 |     cur_dir = os.getcwd()
13 |     base = os.path.join(cur_dir, ".agent")
   |            ^^^^^^^^^^^^
14 |     
15 |     # Use .qmd
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:14:1
   |
12 |     cur_dir = os.getcwd()
13 |     base = os.path.join(cur_dir, ".agent")
14 |     
   | ^^^^
15 |     # Use .qmd
16 |     thesaurus_path = os.path.join(cur_dir, "thesaurus.qmd")
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:16:22
   |
15 |     # Use .qmd
16 |     thesaurus_path = os.path.join(cur_dir, "thesaurus.qmd")
   |                      ^^^^^^^^^^^^
17 |         
18 |     engine = SovereignVector(
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:17:1
   |
15 |     # Use .qmd
16 |     thesaurus_path = os.path.join(cur_dir, "thesaurus.qmd")
17 |         
   | ^^^^^^^^
18 |     engine = SovereignVector(
19 |         thesaurus_path=thesaurus_path,
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:20:26
   |
18 |     engine = SovereignVector(
19 |         thesaurus_path=thesaurus_path,
20 |         corrections_path=os.path.join(base, "corrections.json"),
   |                          ^^^^^^^^^^^^
21 |         stopwords_path=os.path.join(base, "scripts", "stopwords.json")
22 |     )
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:21:24
   |
19 |         thesaurus_path=thesaurus_path,
20 |         corrections_path=os.path.join(base, "corrections.json"),
21 |         stopwords_path=os.path.join(base, "scripts", "stopwords.json")
   |                        ^^^^^^^^^^^^
22 |     )
23 |     engine.load_core_skills()
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:24:33
   |
22 |     )
23 |     engine.load_core_skills()
24 |     engine.load_skills_from_dir(os.path.join(base, "skills"))
   |                                 ^^^^^^^^^^^^
25 |     
26 |     skills_db = os.path.join(cur_dir, "skills_db")
   |

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:25:1
   |
23 |     engine.load_core_skills()
24 |     engine.load_skills_from_dir(os.path.join(base, "skills"))
25 |     
   | ^^^^
26 |     skills_db = os.path.join(cur_dir, "skills_db")
27 |     if os.path.exists(skills_db):
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\debug\debug_engine.py:26:17
   |
24 |     engine.load_skills_from_dir(os.path.join(base, "skills"))
25 |     
26 |     skills_db = os.path.join(cur_dir, "skills_db")
   |                 ^^^^^^^^^^^^
27 |     if os.path.exists(skills_db):
28 |         engine.load_skills_from_dir(skills_db, prefix="GLOBAL:")
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\debug\debug_engine.py:27:8
   |
26 |     skills_db = os.path.join(cur_dir, "skills_db")
27 |     if os.path.exists(skills_db):
   |        ^^^^^^^^^^^^^^
28 |         engine.load_skills_from_dir(skills_db, prefix="GLOBAL:")
   |
help: Replace with `Path(...).exists()`

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:29:1
   |
27 |     if os.path.exists(skills_db):
28 |         engine.load_skills_from_dir(skills_db, prefix="GLOBAL:")
29 |         
   | ^^^^^^^^
30 |     engine.build_index()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:31:1
   |
30 |     engine.build_index()
31 |     
   | ^^^^
32 |     # Print a few thesaurus entries to verify loading
33 |     print("\n--- Thesaurus Check ---")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:37:1
   |
35 |     for w in check_words:
36 |         print(f"  {w}: {engine.thesaurus.get(w)}")
37 |     
   | ^^^^
38 |     print(f"\n--- Debugging Query: '{query}' ---")
39 |     tokens = engine.tokenize(query)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:41:1
   |
39 |     tokens = engine.tokenize(query)
40 |     print(f"Tokens: {tokens}")
41 |     
   | ^^^^
42 |     weighted = engine.expand_query(query)
43 |     sorted_weighted = sorted(weighted.items(), key=lambda x: x[1], reverse=True)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_engine.py:45:1
   |
43 |     sorted_weighted = sorted(weighted.items(), key=lambda x: x[1], reverse=True)
44 |     print(f"Top 10 Expanded Tokens: {sorted_weighted[:10]}")
45 |     
   | ^^^^
46 |     results = engine.search(query)
47 |     print("\nTop 5 Results:")
   |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
  --> src\tools\debug\debug_engine.py:56:23
   |
54 |     ]
55 |     for q in queries:
56 |         debug_query(q)
   |                       ^
   |
help: Add trailing newline

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\debug\debug_fishtest.py:5:17
  |
3 | import sys
4 |
5 | sys.path.append(os.path.join('.agent', 'scripts'))
  |                 ^^^^^^^^^^^^
6 | from sv_engine import SovereignVector
  |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\debug\debug_fishtest.py:20:6
   |
19 | # Load test cases
20 | with open('fishtest_data.json', 'r', encoding='utf-8') as f:
   |      ^^^^
21 |     cases = json.load(f).get('test_cases', [])
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\debug\debug_fishtest.py:20:33
   |
19 | # Load test cases
20 | with open('fishtest_data.json', 'r', encoding='utf-8') as f:
   |                                 ^^^
21 |     cases = json.load(f).get('test_cases', [])
   |
help: Remove mode argument

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\debug\debug_fishtest_phase2.py:6:17
  |
5 | # Add script path for engine import
6 | sys.path.append(os.path.join('.agent', 'scripts'))
  |                 ^^^^^^^^^^^^
7 | from sv_engine import SovereignVector
  |

ANN201 Missing return type annotation for public function `debug_phase2`
  --> src\tools\debug\debug_fishtest_phase2.py:10:5
   |
10 | def debug_phase2():
   |     ^^^^^^^^^^^^
11 |     # Initialize engine
12 |     engine = SovereignVector(
   |
help: Add return type annotation: `None`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\debug\debug_fishtest_phase2.py:23:10
   |
22 |     # Load test cases
23 |     with open('fishtest_phase2_data.json', 'r', encoding='utf-8') as f:
   |          ^^^^
24 |         cases = json.load(f).get('test_cases', [])
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\debug\debug_fishtest_phase2.py:23:44
   |
22 |     # Load test cases
23 |     with open('fishtest_phase2_data.json', 'r', encoding='utf-8') as f:
   |                                            ^^^
24 |         cases = json.load(f).get('test_cases', [])
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_fishtest_phase2.py:32:1
   |
30 |         query = case['query']
31 |         expected = case['expected']
32 |         
   | ^^^^^^^^
33 |         results = engine.search(query)
34 |         top = results[0] if results else {}
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_fishtest_phase2.py:37:1
   |
35 |         actual = top.get('trigger')
36 |         score = top.get('score', 0.0)
37 |         
   | ^^^^^^^^
38 |         if actual == expected:
39 |             passed += 1
   |
help: Remove whitespace from blank line

E501 Line too long (108 > 100)
  --> src\tools\debug\debug_fishtest_phase2.py:49:101
   |
48 |     for f in failures:
49 |         print(f"FAIL: \"{f['query']}\" -> {f['actual']} (expected {f['expected']}, score {f['score']:.2f})")
   |                                                                                                     ^^^^^^^^
50 |
51 |     print(f"\nPASSED: {passed}/{len(cases)} ({passed/len(cases)*100:.1f}%)")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\debug\debug_perf.py:7:17
  |
6 | # Add path to agent scripts
7 | sys.path.append(os.path.join(os.getcwd(), '.agent', 'scripts'))
  |                 ^^^^^^^^^^^^
8 |
9 | from sv_engine import SovereignVector
  |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
 --> src\tools\debug\debug_perf.py:7:30
  |
6 | # Add path to agent scripts
7 | sys.path.append(os.path.join(os.getcwd(), '.agent', 'scripts'))
  |                              ^^^^^^^^^
8 |
9 | from sv_engine import SovereignVector
  |
help: Replace with `Path.cwd()`

ANN201 Missing return type annotation for public function `profile`
  --> src\tools\debug\debug_perf.py:12:5
   |
12 | def profile():
   |     ^^^^^^^
13 |     print("Initializing Engine...")
14 |     t0 = time.time()
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\debug\debug_perf.py:30:1
   |
28 |     print(f"Skills Count: {len(engine.skills)}")
29 |     print(f"Vectors Count: {len(engine.vectors)}")
30 |     
   | ^^^^
31 |     # Test Uncached
32 |     print("\n--- Uncached Search Test (100 unique queries) ---")
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
 --> src\tools\debug\diag_engine.py:5:17
  |
4 | # Add script path for engine import
5 | sys.path.append(os.path.join('.agent', 'scripts'))
  |                 ^^^^^^^^^^^^
6 | from sv_engine import SovereignVector
  |

F401 [*] `os` imported but unused
 --> src\tools\debug\quick_check.py:1:8
  |
1 | import os
  |        ^^
2 | import sys
  |
help: Remove unused import: `os`

W291 [*] Trailing whitespace
  --> src\tools\debug\quick_check.py:9:21
   |
 8 | e = SovereignVector(
 9 |     'thesaurus.qmd', 
   |                     ^
10 |     '.agent/corrections.json', 
11 |     '.agent/scripts/stopwords.json'
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\debug\quick_check.py:10:31
   |
 8 | e = SovereignVector(
 9 |     'thesaurus.qmd', 
10 |     '.agent/corrections.json', 
   |                               ^
11 |     '.agent/scripts/stopwords.json'
12 | )
   |
help: Remove trailing whitespace

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> src\tools\debug\verify_fish.py:17:17
   |
16 | # Add current dir to path
17 | sys.path.append(os.getcwd())
   |                 ^^^^^^^^^
18 |
19 | print("--- VERIFYING SOVEREIGN FISH ---")
   |
help: Replace with `Path.cwd()`

W293 [*] Blank line contains whitespace
  --> src\tools\debug\verify_fish.py:23:1
   |
21 |     import sovereign_fish
22 |     print("SUCCESS: sovereign_fish imported.")
23 |     
   | ^^^^
24 |     # Mock API key
25 |     os.environ["GOOGLE_API_KEY"] = "TEST"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\verify_fish.py:26:1
   |
24 |     # Mock API key
25 |     os.environ["GOOGLE_API_KEY"] = "TEST"
26 |     
   | ^^^^
27 |     # Init
28 |     fish = sovereign_fish.SovereignFish(".")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\debug\verify_fish.py:30:1
   |
28 |     fish = sovereign_fish.SovereignFish(".")
29 |     print("SUCCESS: SovereignFish initialized.")
30 |     
   | ^^^^
31 | except ImportError as e:
32 |     print(f"FAILURE: ImportError in sovereign_fish: {e}")
   |
help: Remove whitespace from blank line

F401 `main_loop` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> src\tools\debug\verify_fish.py:38:12
   |
36 | print("\n--- VERIFYING MAIN LOOP ---")
37 | try:
38 |     import main_loop
   |            ^^^^^^^^^
39 |     print("SUCCESS: main_loop imported.")
40 | except ImportError as e:
   |
help: Remove unused import: `main_loop`

F401 [*] `os` imported but unused
 --> src\tools\generate_tests.py:3:8
  |
1 | import argparse
2 | import json
3 | import os
  |        ^^
4 | import random
5 | import sys
  |
help: Remove unused import: `os`

F401 [*] `sys` imported but unused
 --> src\tools\generate_tests.py:5:8
  |
3 | import os
4 | import random
5 | import sys
  |        ^^^
  |
help: Remove unused import: `sys`

ANN201 Missing return type annotation for public function `generate_cases`
 --> src\tools\generate_tests.py:8:5
  |
8 | def generate_cases(n=1000, threshold=0.3):
  |     ^^^^^^^^^^^^^^
9 |     print(f"Generating {n} synthetic test cases...")
  |
help: Add return type annotation

ANN001 Missing type annotation for function argument `n`
 --> src\tools\generate_tests.py:8:20
  |
8 | def generate_cases(n=1000, threshold=0.3):
  |                    ^
9 |     print(f"Generating {n} synthetic test cases...")
  |

ANN001 Missing type annotation for function argument `threshold`
 --> src\tools\generate_tests.py:8:28
  |
8 | def generate_cases(n=1000, threshold=0.3):
  |                            ^^^^^^^^^
9 |     print(f"Generating {n} synthetic test cases...")
  |

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:10:1
   |
 8 | def generate_cases(n=1000, threshold=0.3):
 9 |     print(f"Generating {n} synthetic test cases...")
10 |     
   | ^^^^
11 |     # Vocabulary Aligned with sv_engine.py for High Confidence
12 |     vocab = {
   |
help: Remove whitespace from blank line

E501 Line too long (103 > 100)
  --> src\tools\generate_tests.py:29:101
   |
27 |         },
28 |         "/wrap-it-up": {
29 |             "verbs": ["finish", "done", "wrap", "complete", "finalize", "quit", "exit", "stop", "end"],
   |                                                                                                     ^^^
30 |             "nouns": ["session", "day", "work"],
31 |             "modifiers": ["it", "up", "now", "for the day", "immediately"]
   |

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:45:1
   |
44 |     cases = []
45 |     
   | ^^^^
46 |     # 1. Ensure we cover the "Core" manually first (to ensure variety)
47 |     for intent, words in vocab.items():
   |
help: Remove whitespace from blank line

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:49:20
   |
47 |     for intent, words in vocab.items():
48 |         for _ in range(int(n * 0.1)): # 10% of N dedicated to simple core coverage
49 |             verb = random.choice(words["verbs"])
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 |             noun = random.choice(words["nouns"])
51 |             query = f"{verb} {noun}"
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:50:20
   |
48 |         for _ in range(int(n * 0.1)): # 10% of N dedicated to simple core coverage
49 |             verb = random.choice(words["verbs"])
50 |             noun = random.choice(words["nouns"])
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |             query = f"{verb} {noun}"
52 |             cases.append({
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:61:18
   |
59 |     # 2. Random Combinatorial Fill
60 |     while len(cases) < n:
61 |         intent = random.choice(list(vocab.keys()))
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 |         words = vocab[intent]
63 |         template = random.choice(templates)
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:63:20
   |
61 |         intent = random.choice(list(vocab.keys()))
62 |         words = vocab[intent]
63 |         template = random.choice(templates)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
64 |         
65 |         query = template.format(
   |

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:64:1
   |
62 |         words = vocab[intent]
63 |         template = random.choice(templates)
64 |         
   | ^^^^^^^^
65 |         query = template.format(
66 |             verb=random.choice(words["verbs"]),
   |
help: Remove whitespace from blank line

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:66:18
   |
65 |         query = template.format(
66 |             verb=random.choice(words["verbs"]),
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |             noun=random.choice(words["nouns"]),
68 |             modifier=random.choice(words["modifiers"])
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:67:18
   |
65 |         query = template.format(
66 |             verb=random.choice(words["verbs"]),
67 |             noun=random.choice(words["nouns"]),
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |             modifier=random.choice(words["modifiers"])
69 |         )
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> src\tools\generate_tests.py:68:22
   |
66 |             verb=random.choice(words["verbs"]),
67 |             noun=random.choice(words["nouns"]),
68 |             modifier=random.choice(words["modifiers"])
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |         )
   |

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:70:1
   |
68 |             modifier=random.choice(words["modifiers"])
69 |         )
70 |         
   | ^^^^^^^^
71 |         cases.append({
72 |             "query": query,
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:80:1
   |
78 |     # Shuffle to ensure distribution
79 |     random.shuffle(cases)
80 |     
   | ^^^^
81 |     return {
82 |         "baseline_accuracy": 100.0,
   |
help: Remove whitespace from blank line

E501 Line too long (107 > 100)
  --> src\tools\generate_tests.py:89:101
   |
87 |     parser = argparse.ArgumentParser(description="Generate synthetic fishtest data.")
88 |     parser.add_argument("-n", type=int, default=1000, help="Number of test cases to generate")
89 |     parser.add_argument("-o", "--offset", type=int, default=1, help="Multiplier for routine 10x increases")
   |                                                                                                     ^^^^^^^
90 |     parser.add_argument("-t", "--threshold", type=float, default=0.3, help="Minimum score threshold for synthetic cases")
91 |     args = parser.parse_args()
   |

E501 Line too long (121 > 100)
  --> src\tools\generate_tests.py:90:101
   |
88 |     parser.add_argument("-n", type=int, default=1000, help="Number of test cases to generate")
89 |     parser.add_argument("-o", "--offset", type=int, default=1, help="Multiplier for routine 10x increases")
90 |     parser.add_argument("-t", "--threshold", type=float, default=0.3, help="Minimum score threshold for synthetic cases")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^
91 |     args = parser.parse_args()
   |

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:92:1
   |
90 |     parser.add_argument("-t", "--threshold", type=float, default=0.3, help="Minimum score threshold for synthetic cases")
91 |     args = parser.parse_args()
92 |     
   | ^^^^
93 |     total_n = args.n * args.offset
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:94:1
   |
93 |     total_n = args.n * args.offset
94 |     
   | ^^^^
95 |     data = generate_cases(total_n, threshold=args.threshold)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\generate_tests.py:96:1
   |
95 |     data = generate_cases(total_n, threshold=args.threshold)
96 |     
   | ^^^^
97 |     filename = f"fishtest_N{total_n}.json"
98 |     with open(filename, 'w', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\generate_tests.py:98:10
   |
97 |     filename = f"fishtest_N{total_n}.json"
98 |     with open(filename, 'w', encoding='utf-8') as f:
   |          ^^^^
99 |         json.dump(data, f, indent=2)
   |
help: Replace with `Path.open()`

W293 [*] Blank line contains whitespace
   --> src\tools\generate_tests.py:100:1
    |
 98 |     with open(filename, 'w', encoding='utf-8') as f:
 99 |         json.dump(data, f, indent=2)
100 |         
    | ^^^^^^^^
101 |     print(f"Values exported to {filename}")
    |
help: Remove whitespace from blank line

UP035 `typing.List` is deprecated, use `list` instead
  --> src\tools\latency_check.py:12:1
   |
10 | import sys
11 | import time
12 | from typing import List
   | ^^^^^^^^^^^^^^^^^^^^^^^
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\latency_check.py:23:28
   |
21 |     def __init__(self, iterations: int = 5) -> None:
22 |         self.iterations = iterations
23 |         self.scripts_dir = os.path.dirname(os.path.abspath(__file__))
   |                            ^^^^^^^^^^^^^^^
24 |         self.agent_dir = os.path.dirname(self.scripts_dir)
25 |         self.project_root = os.path.dirname(self.agent_dir)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\latency_check.py:23:44
   |
21 |     def __init__(self, iterations: int = 5) -> None:
22 |         self.iterations = iterations
23 |         self.scripts_dir = os.path.dirname(os.path.abspath(__file__))
   |                                            ^^^^^^^^^^^^^^^
24 |         self.agent_dir = os.path.dirname(self.scripts_dir)
25 |         self.project_root = os.path.dirname(self.agent_dir)
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\latency_check.py:24:26
   |
22 |         self.iterations = iterations
23 |         self.scripts_dir = os.path.dirname(os.path.abspath(__file__))
24 |         self.agent_dir = os.path.dirname(self.scripts_dir)
   |                          ^^^^^^^^^^^^^^^
25 |         self.project_root = os.path.dirname(self.agent_dir)
26 |         self.engine_path = os.path.join(self.scripts_dir, "sv_engine.py")
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\latency_check.py:25:29
   |
23 |         self.scripts_dir = os.path.dirname(os.path.abspath(__file__))
24 |         self.agent_dir = os.path.dirname(self.scripts_dir)
25 |         self.project_root = os.path.dirname(self.agent_dir)
   |                             ^^^^^^^^^^^^^^^
26 |         self.engine_path = os.path.join(self.scripts_dir, "sv_engine.py")
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\latency_check.py:26:28
   |
24 |         self.agent_dir = os.path.dirname(self.scripts_dir)
25 |         self.project_root = os.path.dirname(self.agent_dir)
26 |         self.engine_path = os.path.join(self.scripts_dir, "sv_engine.py")
   |                            ^^^^^^^^^^^^
27 |
28 |     def measure_startup(self) -> float:
   |

W293 Blank line contains whitespace
  --> src\tools\latency_check.py:31:1
   |
29 |         """
30 |         Runs the engine multiple times to calculate average latency.
31 |         
   | ^^^^^^^^
32 |         Returns:
33 |             Average startup latency in milliseconds.
   |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\latency_check.py:36:20
   |
34 |         """
35 |         cmd = [sys.executable, self.engine_path, "--json", "ping"]
36 |         latencies: List[float] = []
   |                    ^^^^
37 |         
38 |         for _ in range(self.iterations):
   |
help: Replace with `list`

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:37:1
   |
35 |         cmd = [sys.executable, self.engine_path, "--json", "ping"]
36 |         latencies: List[float] = []
37 |         
   | ^^^^^^^^
38 |         for _ in range(self.iterations):
39 |             try:
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\latency_check.py:41:17
   |
39 |             try:
40 |                 start = time.perf_counter()
41 |                 subprocess.run(
   |                 ^^^^^^^^^^^^^^
42 |                     cmd, 
43 |                     capture_output=True, 
   |

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:42:25
   |
40 |                 start = time.perf_counter()
41 |                 subprocess.run(
42 |                     cmd, 
   |                         ^
43 |                     capture_output=True, 
44 |                     cwd=self.project_root, 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:43:41
   |
41 |                 subprocess.run(
42 |                     cmd, 
43 |                     capture_output=True, 
   |                                         ^
44 |                     cwd=self.project_root, 
45 |                     timeout=10,
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:44:43
   |
42 |                     cmd, 
43 |                     capture_output=True, 
44 |                     cwd=self.project_root, 
   |                                           ^
45 |                     timeout=10,
46 |                     check=False
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:53:1
   |
51 |                 # Penalty for failed execution
52 |                 latencies.append(10000.0)
53 |             
   | ^^^^^^^^^^^^
54 |         if not latencies:
55 |             return 10000.0
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:56:1
   |
54 |         if not latencies:
55 |             return 10000.0
56 |             
   | ^^^^^^^^^^^^
57 |         return sum(latencies) / len(latencies)
   |
help: Remove whitespace from blank line

W293 Blank line contains whitespace
  --> src\tools\latency_check.py:62:1
   |
60 |         """
61 |         Measures the raw search latency of the engine.
62 |         
   | ^^^^^^^^
63 |         Returns:
64 |             Average search latency in milliseconds.
   |
help: Remove whitespace from blank line

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\latency_check.py:67:20
   |
65 |         """
66 |         cmd = [sys.executable, self.engine_path, "--json", query]
67 |         latencies: List[float] = []
   |                    ^^^^
68 |         
69 |         for _ in range(self.iterations):
   |
help: Replace with `list`

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:68:1
   |
66 |         cmd = [sys.executable, self.engine_path, "--json", query]
67 |         latencies: List[float] = []
68 |         
   | ^^^^^^^^
69 |         for _ in range(self.iterations):
70 |             try:
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\latency_check.py:72:17
   |
70 |             try:
71 |                 start = time.perf_counter()
72 |                 subprocess.run(
   |                 ^^^^^^^^^^^^^^
73 |                     cmd, 
74 |                     capture_output=True, 
   |

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:73:25
   |
71 |                 start = time.perf_counter()
72 |                 subprocess.run(
73 |                     cmd, 
   |                         ^
74 |                     capture_output=True, 
75 |                     cwd=self.project_root, 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:74:41
   |
72 |                 subprocess.run(
73 |                     cmd, 
74 |                     capture_output=True, 
   |                                         ^
75 |                     cwd=self.project_root, 
76 |                     timeout=5,
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\latency_check.py:75:43
   |
73 |                     cmd, 
74 |                     capture_output=True, 
75 |                     cwd=self.project_root, 
   |                                           ^
76 |                     timeout=5,
77 |                     check=False
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:83:1
   |
81 |             except (subprocess.SubprocessError, subprocess.TimeoutExpired):
82 |                 latencies.append(5000.0)
83 |                 
   | ^^^^^^^^^^^^^^^^
84 |         return sum(latencies) / len(latencies) if latencies else 5000.0
   |
help: Remove whitespace from blank line

SIM105 Use `contextlib.suppress(ValueError)` instead of `try`-`except`-`pass`
  --> src\tools\latency_check.py:91:9
   |
89 |       iterations = 5
90 |       if len(sys.argv) > 1:
91 | /         try:
92 | |             iterations = int(sys.argv[1])
93 | |         except ValueError:
94 | |             pass
   | |________________^
95 |               
96 |       profiler = LatencyProfiler(iterations=iterations)
   |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(ValueError): ...`

W293 [*] Blank line contains whitespace
  --> src\tools\latency_check.py:95:1
   |
93 |         except ValueError:
94 |             pass
95 |             
   | ^^^^^^^^^^^^
96 |     profiler = LatencyProfiler(iterations=iterations)
97 |     avg_startup = profiler.measure_startup()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\latency_check.py:99:1
    |
 97 |     avg_startup = profiler.measure_startup()
 98 |     avg_search = profiler.measure_search()
 99 |     
    | ^^^^
100 |     # [ALFRED] Return as CSV: Startup,Search
101 |     print(f"{avg_startup:.2f},{avg_search:.2f}")
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\tools\latency_check.py:105:11
    |
104 | if __name__ == "__main__":
105 |     main()
    |           ^
    |
help: Add trailing newline

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
 --> src\tools\lightning_rod.py:6:17
  |
5 | # Ensure we can import from the same directory
6 | sys.path.append(os.path.dirname(os.path.abspath(__file__)))
  |                 ^^^^^^^^^^^^^^^
7 |
8 | try:
  |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
 --> src\tools\lightning_rod.py:6:33
  |
5 | # Ensure we can import from the same directory
6 | sys.path.append(os.path.dirname(os.path.abspath(__file__)))
  |                                 ^^^^^^^^^^^^^^^
7 |
8 | try:
  |
help: Replace with `Path(...).resolve()`

ANN205 Missing return type annotation for staticmethod `box_top`
  --> src\tools\lightning_rod.py:20:13
   |
18 |         BOLD = ""
19 |         @staticmethod
20 |         def box_top(t): print(f"--- {t} ---")
   |             ^^^^^^^
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `t`
  --> src\tools\lightning_rod.py:20:21
   |
18 |         BOLD = ""
19 |         @staticmethod
20 |         def box_top(t): print(f"--- {t} ---")
   |                     ^
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |

ANN205 Missing return type annotation for staticmethod `box_row`
  --> src\tools\lightning_rod.py:22:13
   |
20 |         def box_top(t): print(f"--- {t} ---")
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |             ^^^^^^^
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |
help: Add return type annotation: `None`

E741 Ambiguous variable name: `l`
  --> src\tools\lightning_rod.py:22:21
   |
20 |         def box_top(t): print(f"--- {t} ---")
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |                     ^
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `l`
  --> src\tools\lightning_rod.py:22:21
   |
20 |         def box_top(t): print(f"--- {t} ---")
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |                     ^
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `v`
  --> src\tools\lightning_rod.py:22:24
   |
20 |         def box_top(t): print(f"--- {t} ---")
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |                        ^
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `c`
  --> src\tools\lightning_rod.py:22:27
   |
20 |         def box_top(t): print(f"--- {t} ---")
21 |         @staticmethod
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
   |                           ^
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |

ANN205 Missing return type annotation for staticmethod `box_bottom`
  --> src\tools\lightning_rod.py:24:13
   |
22 |         def box_row(l, v, c=""): print(f"{l}: {v}")
23 |         @staticmethod
24 |         def box_bottom(): print("------")
   |             ^^^^^^^^^^
25 |
26 | def optimize_file(file_path):
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `optimize_file`
  --> src\tools\lightning_rod.py:26:5
   |
24 |         def box_bottom(): print("------")
25 |
26 | def optimize_file(file_path):
   |     ^^^^^^^^^^^^^
27 |     if not os.path.exists(file_path):
28 |         print(f"{HUD.RED}Error: File not found: {file_path}{HUD.RESET}")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `file_path`
  --> src\tools\lightning_rod.py:26:19
   |
24 |         def box_bottom(): print("------")
25 |
26 | def optimize_file(file_path):
   |                   ^^^^^^^^^
27 |     if not os.path.exists(file_path):
28 |         print(f"{HUD.RED}Error: File not found: {file_path}{HUD.RESET}")
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\lightning_rod.py:27:12
   |
26 | def optimize_file(file_path):
27 |     if not os.path.exists(file_path):
   |            ^^^^^^^^^^^^^^
28 |         print(f"{HUD.RED}Error: File not found: {file_path}{HUD.RESET}")
29 |         return
   |
help: Replace with `Path(...).exists()`

PTH119 `os.path.basename()` should be replaced by `Path.name`
  --> src\tools\lightning_rod.py:32:27
   |
31 |     HUD.box_top("AGENT LIGHTNING v0.1")
32 |     HUD.box_row("Target", os.path.basename(file_path))
   |                           ^^^^^^^^^^^^^^^^
33 |     HUD.box_row("Status", "Analyzing...", HUD.YELLOW)
   |
help: Replace with `Path(...).name`

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:34:1
   |
32 |     HUD.box_row("Target", os.path.basename(file_path))
33 |     HUD.box_row("Status", "Analyzing...", HUD.YELLOW)
34 |     
   | ^^^^
35 |     # 1. Read
36 |     with open(file_path, 'r', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\lightning_rod.py:36:10
   |
35 |     # 1. Read
36 |     with open(file_path, 'r', encoding='utf-8') as f:
   |          ^^^^
37 |         content = f.read()
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\lightning_rod.py:36:26
   |
35 |     # 1. Read
36 |     with open(file_path, 'r', encoding='utf-8') as f:
   |                          ^^^
37 |         content = f.read()
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:38:1
   |
36 |     with open(file_path, 'r', encoding='utf-8') as f:
37 |         content = f.read()
38 |     
   | ^^^^
39 |     time.sleep(0.5) # Simulate processing
40 |     HUD.box_row("Analysis", f"{len(content)} bytes read", HUD.CYAN)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:41:1
   |
39 |     time.sleep(0.5) # Simulate processing
40 |     HUD.box_row("Analysis", f"{len(content)} bytes read", HUD.CYAN)
41 |     
   | ^^^^
42 |     # 2. Simulate Optimization (Mock)
43 |     HUD.box_row("Optimizer", "Applying enhancements...", HUD.MAGENTA)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:45:1
   |
43 |     HUD.box_row("Optimizer", "Applying enhancements...", HUD.MAGENTA)
44 |     time.sleep(0.5)
45 |     
   | ^^^^
46 |     # Simple "Optimization": Add a timestamp comment if not present, or update it.
47 |     # checking for existing signature
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\lightning_rod.py:58:14
   |
56 |     # 3. Write
57 |     if action != "Already Optimized":
58 |         with open(file_path, 'w', encoding='utf-8') as f:
   |              ^^^^
59 |             f.write(new_content)
   |
help: Replace with `Path.open()`

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:60:1
   |
58 |         with open(file_path, 'w', encoding='utf-8') as f:
59 |             f.write(new_content)
60 |     
   | ^^^^
61 |     HUD.box_row("Result", action, HUD.GREEN)
62 |     HUD.box_bottom()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\lightning_rod.py:68:1
   |
66 |         print("Usage: python lightning_rod.py <file_path>")
67 |         sys.exit(1)
68 |     
   | ^^^^
69 |     optimize_file(sys.argv[1])
   |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
 --> src\tools\list_models.py:1:1
  |
1 | / import os
2 | | from dotenv import load_dotenv
3 | | from google import genai
4 | | from google.genai import types
  | |______________________________^
5 |
6 |   # Load .env.local explicitly
  |
help: Organize imports

F401 [*] `google.genai.types` imported but unused
 --> src\tools\list_models.py:4:26
  |
2 | from dotenv import load_dotenv
3 | from google import genai
4 | from google.genai import types
  |                          ^^^^^
5 |
6 | # Load .env.local explicitly
  |
help: Remove unused import: `google.genai.types`

ANN201 Missing return type annotation for public function `list_models`
  --> src\tools\list_models.py:9:5
   |
 7 | load_dotenv(".env.local")
 8 |
 9 | def list_models():
   |     ^^^^^^^^^^^
10 |     api_key = os.getenv("GOOGLE_API_KEY")
11 |     if not api_key:
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\list_models.py:16:1
   |
15 |     print(f"Using API Key: {api_key[:5]}...")
16 |     
   | ^^^^
17 |     try:
18 |         client = genai.Client(api_key=api_key)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\list_models.py:23:1
   |
21 |         for m in client.models.list():
22 |             print(f"- {m.name} (Display: {m.display_name})")
23 |             
   | ^^^^^^^^^^^^
24 |     except Exception as e:
25 |         print(f"Error listing models: {e}")
   |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\loop.py:2:1
   |
 2 | / import os
 3 | | import sys
 4 | | import gc
 5 | | import types
 6 | | import time
 7 | | import shutil
 8 | | import logging
 9 | | import asyncio
10 | | from pathlib import Path
11 | | from typing import Optional, Dict, Any
   | |______________________________________^
12 |
13 |   # Ensure project root is in sys.path
   |
help: Organize imports

F401 [*] `types` imported but unused
 --> src\tools\loop.py:5:8
  |
3 | import sys
4 | import gc
5 | import types
  |        ^^^^^
6 | import time
7 | import shutil
  |
help: Remove unused import: `types`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\tools\loop.py:11:1
   |
 9 | import asyncio
10 | from pathlib import Path
11 | from typing import Optional, Dict, Any
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | # Ensure project root is in sys.path
   |

E402 Module level import not at top of file
  --> src\tools\loop.py:18:1
   |
16 |     sys.path.append(str(PROJECT_ROOT))
17 |
18 | from src.sentinel.wardens.norn import NornWarden
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from src.tools.wrap_it_up import SovereignWrapper
20 | from src.core.ui import HUD
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\loop.py:18:1
   |
16 |       sys.path.append(str(PROJECT_ROOT))
17 |
18 | / from src.sentinel.wardens.norn import NornWarden
19 | | from src.tools.wrap_it_up import SovereignWrapper
20 | | from src.core.ui import HUD
21 | | # We will use AntigravityUplink for the "Act" phase
22 | | from src.cstar.core.uplink import AntigravityUplink
   | |___________________________________________________^
23 |
24 |   # Configure Logging
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\tools\loop.py:19:1
   |
18 | from src.sentinel.wardens.norn import NornWarden
19 | from src.tools.wrap_it_up import SovereignWrapper
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
20 | from src.core.ui import HUD
21 | # We will use AntigravityUplink for the "Act" phase
   |

E402 Module level import not at top of file
  --> src\tools\loop.py:20:1
   |
18 | from src.sentinel.wardens.norn import NornWarden
19 | from src.tools.wrap_it_up import SovereignWrapper
20 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 | # We will use AntigravityUplink for the "Act" phase
22 | from src.cstar.core.uplink import AntigravityUplink
   |

E402 Module level import not at top of file
  --> src\tools\loop.py:22:1
   |
20 | from src.core.ui import HUD
21 | # We will use AntigravityUplink for the "Act" phase
22 | from src.cstar.core.uplink import AntigravityUplink
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |
24 | # Configure Logging
   |

E501 Line too long (102 > 100)
  --> src\tools\loop.py:25:101
   |
24 | # Configure Logging
25 | logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
   |                                                                                                     ^^
26 | logger = logging.getLogger("SovereignLoop")
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\loop.py:38:32
   |
36 |         self.max_retries = 3
37 |
38 |     def forge_task(self, task: Dict[str, Any]) -> bool:
   |                                ^^^^
39 |         """
40 |         Attempts to resolve the task with retries.
   |
help: Replace with `dict`

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:50:1
   |
48 |         # We ask the Uplink to identify the target file and implementation plan
49 |         # This is a mini-chain.
50 |         
   | ^^^^^^^^
51 |         target_file = self._orient_target(task_desc)
52 |         if not target_file:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:57:1
   |
56 |         HUD.persona_log("O.D.I.N.", f"Target Locked: {target_file}")
57 |         
   | ^^^^^^^^
58 |         # 2. The Loop (Edit -> Verify)
59 |         for attempt in range(1, self.max_retries + 1):
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:61:1
   |
59 |         for attempt in range(1, self.max_retries + 1):
60 |             HUD.persona_log("O.D.I.N.", f"Attempt {attempt}/{self.max_retries}: Forging Code...")
61 |             
   | ^^^^^^^^^^^^
62 |             # Backup
63 |             self._backup(target_file)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:64:1
   |
62 |             # Backup
63 |             self._backup(target_file)
64 |             
   | ^^^^^^^^^^^^
65 |             # Generate Code
66 |             success = self._generate_code(task_desc, target_file, attempt)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:82:1
   |
80 |                 self._rollback(target_file)
81 |                 gc.collect() # Memory Safety
82 |                 
   | ^^^^^^^^^^^^^^^^
83 |         # Kill Switch Triggered
84 |         HUD.persona_log("HEIMDALL", "BREACH: Kill Switch Triggered. Max retries exceeded.")
   |
help: Remove whitespace from blank line

UP045 [*] Use `X | None` for type annotations
  --> src\tools\loop.py:88:44
   |
86 |         return False
87 |
88 |     def _orient_target(self, task: str) -> Optional[Path]:
   |                                            ^^^^^^^^^^^^^^
89 |         """
90 |         Asks LLM to identify the target file from the task description.
   |
help: Convert to `X | None`

F841 Local variable `prompt` is assigned to but never used
  --> src\tools\loop.py:94:9
   |
92 |         # Simulation Logic for Activation Phase
93 |         # If we can't really call LLM, we default to a safe scratch file for testing the loop.
94 |         prompt = f"Identify target for: {task}"
   |         ^^^^^^
95 |         
96 |         # Try simplistic extraction
   |
help: Remove assignment to unused variable `prompt`

W293 [*] Blank line contains whitespace
  --> src\tools\loop.py:95:1
   |
93 |         # If we can't really call LLM, we default to a safe scratch file for testing the loop.
94 |         prompt = f"Identify target for: {task}"
95 |         
   | ^^^^^^^^
96 |         # Try simplistic extraction
97 |         if "(Target: " in task:
   |
help: Remove whitespace from blank line

E722 Do not use bare `except`
   --> src\tools\loop.py:103:13
    |
101 |                 path_str = task[start:end]
102 |                 return (self.root / path_str).resolve()
103 |             except:
    |             ^^^^^^
104 |                 pass
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> src\tools\loop.py:103:13
    |
101 |                   path_str = task[start:end]
102 |                   return (self.root / path_str).resolve()
103 | /             except:
104 | |                 pass
    | |____________________^
105 |
106 |           # Fallback for verification/scaffold
    |

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:118:1
    |
116 |         """
117 |         HUD.persona_log("O.D.I.N.", f"Transmitting objective to Antigravity (Attempt {attempt})...")
118 |         
    | ^^^^^^^^
119 |         # Read content for context
120 |         content = target.read_text(encoding='utf-8') if target.exists() else ""
    |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `call_uplink`
   --> src\tools\loop.py:129:19
    |
128 |         # Async Call Wrapper
129 |         async def call_uplink():
    |                   ^^^^^^^^^^^
130 |             return await self.uplink.send_payload(f"FORGE: {task}", context)
    |
help: Add return type annotation

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:131:1
    |
129 |         async def call_uplink():
130 |             return await self.uplink.send_payload(f"FORGE: {task}", context)
131 |         
    | ^^^^^^^^
132 |         try:
133 |             response = asyncio.run(call_uplink())
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:147:1
    |
145 |             timestamp = time.strftime("%H:%M:%S")
146 |             new_code = content + f"\n# [O.D.I.N.] Forged Update ({timestamp}): {task}\n"
147 |         
    | ^^^^^^^^
148 |         if new_code:
149 |             target.write_text(new_code, encoding='utf-8')
    |
help: Remove whitespace from blank line

F841 Local variable `wrapper` is assigned to but never used
   --> src\tools\loop.py:159:9
    |
157 |         Runs the Gungnir Gate (Ruff + Pytest).
158 |         """
159 |         wrapper = SovereignWrapper() # Initializes at root
    |         ^^^^^^^
160 |         # We need to suppress sys.exit in wrapper or catch it
161 |         try:
    |
help: Remove assignment to unused variable `wrapper`

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:166:1
    |
164 |             # Wrapper.run_gungnir_gate() calls sys.exit(1).
165 |             # We should refactor wrapper or run subprocess manually.
166 |             
    | ^^^^^^^^^^^^
167 |             # Manual Check
168 |             import subprocess
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\loop.py:169:24
    |
167 | â€¦     # Manual Check
168 | â€¦     import subprocess
169 | â€¦     res_lint = subprocess.run([sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], cwd=str(self.root), capturâ€¦
    |                  ^^^^^^^^^^^^^^
170 | â€¦     if res_lint.returncode != 0: return False
    |

E501 Line too long (153 > 100)
   --> src\tools\loop.py:169:101
    |
167 | â€¦
168 | â€¦
169 | â€¦"ruff", "check", ".", "--select", "E9,F63,F7,F82"], cwd=str(self.root), capture_output=True)
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 | â€¦
    |

E701 Multiple statements on one line (colon)
   --> src\tools\loop.py:170:40
    |
168 | â€¦     import subprocess
169 | â€¦     res_lint = subprocess.run([sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], cwd=str(self.root), capturâ€¦
170 | â€¦     if res_lint.returncode != 0: return False
    |                                  ^
171 | â€¦     
172 | â€¦     res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:171:1
    |
169 | â€¦     res_lint = subprocess.run([sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], cwd=str(self.root), capturâ€¦
170 | â€¦     if res_lint.returncode != 0: return False
171 | â€¦     
^^^^^^^^^^^^
172 | â€¦     res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
173 | â€¦     if res_test.returncode != 0: return False
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\loop.py:172:24
    |
170 |             if res_lint.returncode != 0: return False
171 |             
172 |             res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
    |                        ^^^^^^^^^^^^^^
173 |             if res_test.returncode != 0: return False
    |

E501 Line too long (112 > 100)
   --> src\tools\loop.py:172:101
    |
170 |             if res_lint.returncode != 0: return False
171 |             
172 |             res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
    |                                                                                                     ^^^^^^^^^^^^
173 |             if res_test.returncode != 0: return False
    |

SIM103 Return the condition `res_test.returncode == 0` directly
   --> src\tools\loop.py:173:13
    |
172 |               res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
173 | /             if res_test.returncode != 0: return False
174 | |             
175 | |             return True
    | |_______________________^
176 |           except Exception:
177 |               return False
    |
help: Replace with `return res_test.returncode == 0`

E701 Multiple statements on one line (colon)
   --> src\tools\loop.py:173:40
    |
172 |             res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
173 |             if res_test.returncode != 0: return False
    |                                        ^
174 |             
175 |             return True
    |

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:174:1
    |
172 |             res_test = subprocess.run([sys.executable, "-m", "pytest"], cwd=str(self.root), capture_output=True)
173 |             if res_test.returncode != 0: return False
174 |             
    | ^^^^^^^^^^^^
175 |             return True
176 |         except Exception:
    |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `_backup`
   --> src\tools\loop.py:179:9
    |
177 |             return False
178 |
179 |     def _backup(self, target: Path):
    |         ^^^^^^^
180 |         try:
181 |             shutil.copy(target, target.with_suffix(target.suffix + ".bak"))
    |
help: Add return type annotation: `None`

SIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`
   --> src\tools\loop.py:180:9
    |
179 |       def _backup(self, target: Path):
180 | /         try:
181 | |             shutil.copy(target, target.with_suffix(target.suffix + ".bak"))
182 | |         except OSError:
183 | |             pass
    | |________________^
184 |
185 |       def _rollback(self, target: Path):
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`

ANN202 Missing return type annotation for private function `_rollback`
   --> src\tools\loop.py:185:9
    |
183 |             pass
184 |
185 |     def _rollback(self, target: Path):
    |         ^^^^^^^^^
186 |         bak = target.with_suffix(target.suffix + ".bak")
187 |         if bak.exists():
    |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_cleanup_backup`
   --> src\tools\loop.py:190:9
    |
188 |             shutil.move(bak, target)
189 |
190 |     def _cleanup_backup(self, target: Path):
    |         ^^^^^^^^^^^^^^^
191 |         bak = target.with_suffix(target.suffix + ".bak")
192 |         if bak.exists():
    |
help: Add return type annotation: `None`

PTH107 `os.remove()` should be replaced by `Path.unlink()`
   --> src\tools\loop.py:193:13
    |
191 |         bak = target.with_suffix(target.suffix + ".bak")
192 |         if bak.exists():
193 |             os.remove(bak)
    |             ^^^^^^^^^
    |
help: Replace with `Path(...).unlink()`

ANN201 Missing return type annotation for public function `sovereign_lifecycle`
   --> src\tools\loop.py:196:5
    |
196 | def sovereign_lifecycle():
    |     ^^^^^^^^^^^^^^^^^^^
197 |     """
198 |     The Main Loop.
    |
help: Add return type annotation: `None`

W291 [*] Trailing whitespace
   --> src\tools\loop.py:209:27
    |
207 |         # 1. Observe (Norn)
208 |         HUD.box_top("SOVEREIGN OBSERVE")
209 |         task = norn.scan() 
    |                           ^
210 |         # Norn.scan() returns a list of breaches. For Campaign, it returns one object.
211 |         if not task:
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:214:1
    |
212 |             HUD.persona_log("O.D.I.N.", "No active tasks in queue. The Cycle pauses.")
213 |             break
214 |         
    | ^^^^^^^^
215 |         target_task = task[0] # The breach object
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:216:1
    |
215 |         target_task = task[0] # The breach object
216 |         
    | ^^^^^^^^
217 |         # 2. Act (Forge)
218 |         # Note: 'task' is a Campaign Task breach.
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:220:1
    |
218 |         # Note: 'task' is a Campaign Task breach.
219 |         success = forge.forge_task(target_task)
220 |         
    | ^^^^^^^^
221 |         if success:
222 |             # 3. Finalize
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:226:1
    |
224 |             # Mark complete in tasks.qmd
225 |             norn.mark_complete(target_task)
226 |             
    | ^^^^^^^^^^^^
227 |             # Commit & Push
228 |             # Wrapper sovereign_commit computes stats. We can run compile_traces or just pass empty stats
    |
help: Remove whitespace from blank line

E501 Line too long (105 > 100)
   --> src\tools\loop.py:228:101
    |
227 |             # Commit & Push
228 |             # Wrapper sovereign_commit computes stats. We can run compile_traces or just pass empty stats
    |                                                                                                     ^^^^^
229 |             wrapper.sovereign_commit({}) # We arguably should compile traces first
    |

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:230:1
    |
228 |             # Wrapper sovereign_commit computes stats. We can run compile_traces or just pass empty stats
229 |             wrapper.sovereign_commit({}) # We arguably should compile traces first
230 |             
    | ^^^^^^^^^^^^
231 |             # 4. Handshake (Nuke Context)
232 |             HUD.persona_log("ALFRED", "Purging memory context for next cycle.")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:236:1
    |
234 |             del target_task
235 |             gc.collect()
236 |             
    | ^^^^^^^^^^^^
237 |             # In a real agentic loop, we might restart the script or just clear the LLM client.
238 |             # forge.uplink should be reset in next iteration if needed.
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\loop.py:239:1
    |
237 |             # In a real agentic loop, we might restart the script or just clear the LLM client.
238 |             # forge.uplink should be reset in next iteration if needed.
239 |             
    | ^^^^^^^^^^^^
240 |         else:
241 |             # Kill Switch
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\merge_traces.py:11:24
   |
 9 |     from ui import HUD
10 | except ImportError:
11 |     sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                        ^^^^^^^^^^^^
12 |     from ui import HUD
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\merge_traces.py:11:37
   |
 9 |     from ui import HUD
10 | except ImportError:
11 |     sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                     ^^^^^^^^^^^^^^^
12 |     from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\merge_traces.py:11:53
   |
 9 |     from ui import HUD
10 | except ImportError:
11 |     sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                     ^^^^^^^^^^^^^^^
12 |     from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\merge_traces.py:11:69
   |
 9 |     from ui import HUD
10 | except ImportError:
11 |     sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                     ^^^^^^^^^^^^^^^
12 |     from ui import HUD
   |
help: Replace with `Path(...).resolve()`

E501 Line too long (105 > 100)
  --> src\tools\merge_traces.py:11:101
   |
 9 |     from ui import HUD
10 | except ImportError:
11 |     sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                                                     ^^^^^
12 |     from ui import HUD
   |

ANN202 Missing return type annotation for private function `_load_dataset`
  --> src\tools\merge_traces.py:14:5
   |
12 |     from ui import HUD
13 |
14 | def _load_dataset(target_path):
   |     ^^^^^^^^^^^^^
15 |     """Safely load the existing test dataset."""
16 |     if not target_path.exists():
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `target_path`
  --> src\tools\merge_traces.py:14:19
   |
12 |     from ui import HUD
13 |
14 | def _load_dataset(target_path):
   |                   ^^^^^^^^^^^
15 |     """Safely load the existing test dataset."""
16 |     if not target_path.exists():
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\merge_traces.py:19:14
   |
17 |         return {"test_cases": []}
18 |     try:
19 |         with open(target_path, 'r', encoding='utf-8') as f:
   |              ^^^^
20 |             return json.load(f)
21 |     except Exception as e:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\merge_traces.py:19:32
   |
17 |         return {"test_cases": []}
18 |     try:
19 |         with open(target_path, 'r', encoding='utf-8') as f:
   |                                ^^^
20 |             return json.load(f)
21 |     except Exception as e:
   |
help: Remove mode argument

ANN202 Missing return type annotation for private function `_save_dataset`
  --> src\tools\merge_traces.py:25:5
   |
23 |         return {"test_cases": []}
24 |
25 | def _save_dataset(dataset, target_path):
   |     ^^^^^^^^^^^^^
26 |     """Atomic save of the test dataset."""
27 |     temp_target = str(target_path) + ".tmp"
   |
help: Add return type annotation: `bool | None`

ANN001 Missing type annotation for function argument `dataset`
  --> src\tools\merge_traces.py:25:19
   |
23 |         return {"test_cases": []}
24 |
25 | def _save_dataset(dataset, target_path):
   |                   ^^^^^^^
26 |     """Atomic save of the test dataset."""
27 |     temp_target = str(target_path) + ".tmp"
   |

ANN001 Missing type annotation for function argument `target_path`
  --> src\tools\merge_traces.py:25:28
   |
23 |         return {"test_cases": []}
24 |
25 | def _save_dataset(dataset, target_path):
   |                            ^^^^^^^^^^^
26 |     """Atomic save of the test dataset."""
27 |     temp_target = str(target_path) + ".tmp"
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\merge_traces.py:29:14
   |
27 |     temp_target = str(target_path) + ".tmp"
28 |     try:
29 |         with open(temp_target, 'w', encoding='utf-8') as f:
   |              ^^^^
30 |             json.dump(dataset, f, indent=2)
31 |         os.replace(temp_target, str(target_path))
   |
help: Replace with `Path.open()`

PTH105 `os.replace()` should be replaced by `Path.replace()`
  --> src\tools\merge_traces.py:31:9
   |
29 |         with open(temp_target, 'w', encoding='utf-8') as f:
30 |             json.dump(dataset, f, indent=2)
31 |         os.replace(temp_target, str(target_path))
   |         ^^^^^^^^^^
32 |         return True
33 |     except (IOError, PermissionError) as e:
   |
help: Replace with `Path(...).replace(...)`

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\merge_traces.py:33:12
   |
31 |         os.replace(temp_target, str(target_path))
32 |         return True
33 |     except (IOError, PermissionError) as e:
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |         HUD.log("FAIL", "Database Save Failed", str(e)[:30])
35 |         if os.path.exists(temp_target): os.remove(temp_target)
   |
help: Replace with builtin `OSError`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\merge_traces.py:35:12
   |
33 |     except (IOError, PermissionError) as e:
34 |         HUD.log("FAIL", "Database Save Failed", str(e)[:30])
35 |         if os.path.exists(temp_target): os.remove(temp_target)
   |            ^^^^^^^^^^^^^^
36 |         return False
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\merge_traces.py:35:39
   |
33 |     except (IOError, PermissionError) as e:
34 |         HUD.log("FAIL", "Database Save Failed", str(e)[:30])
35 |         if os.path.exists(temp_target): os.remove(temp_target)
   |                                       ^
36 |         return False
   |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
  --> src\tools\merge_traces.py:35:41
   |
33 |     except (IOError, PermissionError) as e:
34 |         HUD.log("FAIL", "Database Save Failed", str(e)[:30])
35 |         if os.path.exists(temp_target): os.remove(temp_target)
   |                                         ^^^^^^^^^
36 |         return False
   |
help: Replace with `Path(...).unlink()`

ANN202 Missing return type annotation for private function `_process_single_trace`
  --> src\tools\merge_traces.py:38:5
   |
36 |         return False
37 |
38 | def _process_single_trace(trace, existing_queries, dataset):
   |     ^^^^^^^^^^^^^^^^^^^^^
39 |     """Integrate a single trace object into the dataset."""
40 |     if not isinstance(trace, dict): return 0, 0
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `trace`
  --> src\tools\merge_traces.py:38:27
   |
36 |         return False
37 |
38 | def _process_single_trace(trace, existing_queries, dataset):
   |                           ^^^^^
39 |     """Integrate a single trace object into the dataset."""
40 |     if not isinstance(trace, dict): return 0, 0
   |

ANN001 Missing type annotation for function argument `existing_queries`
  --> src\tools\merge_traces.py:38:34
   |
36 |         return False
37 |
38 | def _process_single_trace(trace, existing_queries, dataset):
   |                                  ^^^^^^^^^^^^^^^^
39 |     """Integrate a single trace object into the dataset."""
40 |     if not isinstance(trace, dict): return 0, 0
   |

ANN001 Missing type annotation for function argument `dataset`
  --> src\tools\merge_traces.py:38:52
   |
36 |         return False
37 |
38 | def _process_single_trace(trace, existing_queries, dataset):
   |                                                    ^^^^^^^
39 |     """Integrate a single trace object into the dataset."""
40 |     if not isinstance(trace, dict): return 0, 0
   |

E701 Multiple statements on one line (colon)
  --> src\tools\merge_traces.py:40:35
   |
38 | def _process_single_trace(trace, existing_queries, dataset):
39 |     """Integrate a single trace object into the dataset."""
40 |     if not isinstance(trace, dict): return 0, 0
   |                                   ^
41 |     query, match = trace.get('query'), trace.get('match')
42 |     if not query or not match or not isinstance(query, str) or not isinstance(match, str):
   |

C414 Unnecessary `list()` call within `sorted()`
  --> src\tools\merge_traces.py:47:17
   |
45 |     new_case = {
46 |         "query": query, "expected": match, "min_score": 0.85,
47 |         "tags": sorted(list(set(["federated", "real-user"] + [trace.get('persona', 'unknown')])))
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |     }
49 |     if trace.get('is_global'): new_case['expected_global'] = True
   |
help: Remove the inner `list()` call

RUF005 Consider iterable unpacking instead of concatenation
  --> src\tools\merge_traces.py:47:33
   |
45 |     new_case = {
46 |         "query": query, "expected": match, "min_score": 0.85,
47 |         "tags": sorted(list(set(["federated", "real-user"] + [trace.get('persona', 'unknown')])))
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
48 |     }
49 |     if trace.get('is_global'): new_case['expected_global'] = True
   |
help: Replace with iterable unpacking

E701 Multiple statements on one line (colon)
  --> src\tools\merge_traces.py:49:30
   |
47 |         "tags": sorted(list(set(["federated", "real-user"] + [trace.get('persona', 'unknown')])))
48 |     }
49 |     if trace.get('is_global'): new_case['expected_global'] = True
   |                              ^
50 |
51 |     if query in existing_queries:
   |

C414 Unnecessary `list()` call within `sorted()`
  --> src\tools\merge_traces.py:54:28
   |
52 |         existing = existing_queries[query]
53 |         existing['expected'] = match
54 |         existing['tags'] = sorted(list(set(existing.get('tags', []) + new_case['tags'])))
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |         if 'expected_global' in new_case: existing['expected_global'] = True
56 |         return 0, 1
   |
help: Remove the inner `list()` call

E701 Multiple statements on one line (colon)
  --> src\tools\merge_traces.py:55:41
   |
53 |         existing['expected'] = match
54 |         existing['tags'] = sorted(list(set(existing.get('tags', []) + new_case['tags'])))
55 |         if 'expected_global' in new_case: existing['expected_global'] = True
   |                                         ^
56 |         return 0, 1
57 |     else:
   |

ANN202 Missing return type annotation for private function `_process_trace_file`
  --> src\tools\merge_traces.py:62:5
   |
60 |         return 1, 0
61 |
62 | def _process_trace_file(trace_file, existing_queries, dataset, failed_dir):
   |     ^^^^^^^^^^^^^^^^^^^
63 |     """Load and process a single trace JSON file."""
64 |     try:
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `trace_file`
  --> src\tools\merge_traces.py:62:25
   |
60 |         return 1, 0
61 |
62 | def _process_trace_file(trace_file, existing_queries, dataset, failed_dir):
   |                         ^^^^^^^^^^
63 |     """Load and process a single trace JSON file."""
64 |     try:
   |

ANN001 Missing type annotation for function argument `existing_queries`
  --> src\tools\merge_traces.py:62:37
   |
60 |         return 1, 0
61 |
62 | def _process_trace_file(trace_file, existing_queries, dataset, failed_dir):
   |                                     ^^^^^^^^^^^^^^^^
63 |     """Load and process a single trace JSON file."""
64 |     try:
   |

ANN001 Missing type annotation for function argument `dataset`
  --> src\tools\merge_traces.py:62:55
   |
60 |         return 1, 0
61 |
62 | def _process_trace_file(trace_file, existing_queries, dataset, failed_dir):
   |                                                       ^^^^^^^
63 |     """Load and process a single trace JSON file."""
64 |     try:
   |

ANN001 Missing type annotation for function argument `failed_dir`
  --> src\tools\merge_traces.py:62:64
   |
60 |         return 1, 0
61 |
62 | def _process_trace_file(trace_file, existing_queries, dataset, failed_dir):
   |                                                                ^^^^^^^^^^
63 |     """Load and process a single trace JSON file."""
64 |     try:
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\merge_traces.py:67:14
   |
65 |         if trace_file.stat().st_size > 5 * 1024 * 1024:
66 |             raise ValueError("Size limit exceeded")
67 |         with open(trace_file, 'r', encoding='utf-8') as f:
   |              ^^^^
68 |             content = json.load(f)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\merge_traces.py:67:31
   |
65 |         if trace_file.stat().st_size > 5 * 1024 * 1024:
66 |             raise ValueError("Size limit exceeded")
67 |         with open(trace_file, 'r', encoding='utf-8') as f:
   |                               ^^^
68 |             content = json.load(f)
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\merge_traces.py:69:1
   |
67 |         with open(trace_file, 'r', encoding='utf-8') as f:
68 |             content = json.load(f)
69 |         
   | ^^^^^^^^
70 |         n_added, n_updated = 0, 0
71 |         for t in (content if isinstance(content, list) else [content]):
   |
help: Remove whitespace from blank line

E702 Multiple statements on one line (semicolon)
  --> src\tools\merge_traces.py:73:25
   |
71 |         for t in (content if isinstance(content, list) else [content]):
72 |             a, u = _process_single_trace(t, existing_queries, dataset)
73 |             n_added += a; n_updated += u
   |                         ^
74 |         return True, n_added, n_updated
75 |     except Exception as e:
   |

ANN201 Missing return type annotation for public function `merge_traces`
  --> src\tools\merge_traces.py:80:5
   |
78 |         return False, 0, 0
79 |
80 | def merge_traces(source_dir, target_file="fishtest_data.json"):
   |     ^^^^^^^^^^^^
81 |     """[ALFRED] Refactored trace merger with O(1) lookups and atomic persistence."""
82 |     source_path, target_path = Path(source_dir), Path(target_file)
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `source_dir`
  --> src\tools\merge_traces.py:80:18
   |
78 |         return False, 0, 0
79 |
80 | def merge_traces(source_dir, target_file="fishtest_data.json"):
   |                  ^^^^^^^^^^
81 |     """[ALFRED] Refactored trace merger with O(1) lookups and atomic persistence."""
82 |     source_path, target_path = Path(source_dir), Path(target_file)
   |

ANN001 Missing type annotation for function argument `target_file`
  --> src\tools\merge_traces.py:80:30
   |
78 |         return False, 0, 0
79 |
80 | def merge_traces(source_dir, target_file="fishtest_data.json"):
   |                              ^^^^^^^^^^^
81 |     """[ALFRED] Refactored trace merger with O(1) lookups and atomic persistence."""
82 |     source_path, target_path = Path(source_dir), Path(target_file)
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\merge_traces.py:84:39
   |
82 |     source_path, target_path = Path(source_dir), Path(target_file)
83 |     processed_dir, failed_dir = source_path / "processed", source_path / "failed"
84 |     processed_dir.mkdir(exist_ok=True); failed_dir.mkdir(exist_ok=True)
   |                                       ^
85 |
86 |     dataset = _load_dataset(target_path)
   |

W293 [*] Blank line contains whitespace
  --> src\tools\merge_traces.py:88:1
   |
86 |     dataset = _load_dataset(target_path)
87 |     existing_queries = {c['query']: c for c in dataset.get('test_cases', [])}
88 |     
   | ^^^^
89 |     total_new, total_upd, files_ok = 0, 0, 0
90 |     for trace_file in source_path.glob("*.json"):
   |
help: Remove whitespace from blank line

E702 Multiple statements on one line (semicolon)
  --> src\tools\merge_traces.py:94:27
   |
92 |         if ok:
93 |             shutil.move(str(trace_file), str(processed_dir / trace_file.name))
94 |             total_new += n; total_upd += u; files_ok += 1
   |                           ^
95 |
96 |     if files_ok > 0:
   |

E702 Multiple statements on one line (semicolon)
  --> src\tools\merge_traces.py:94:43
   |
92 |         if ok:
93 |             shutil.move(str(trace_file), str(processed_dir / trace_file.name))
94 |             total_new += n; total_upd += u; files_ok += 1
   |                                           ^
95 |
96 |     if files_ok > 0:
   |

E701 Multiple statements on one line (colon)
   --> src\tools\merge_traces.py:104:25
    |
103 | if __name__ == "__main__":
104 |     if len(sys.argv) < 2: print("Usage: python merge_traces.py <source_dir> [target_file]")
    |                         ^
105 |     else: merge_traces(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else "fishtest_data.json")
    |

E701 Multiple statements on one line (colon)
   --> src\tools\merge_traces.py:105:9
    |
103 | if __name__ == "__main__":
104 |     if len(sys.argv) < 2: print("Usage: python merge_traces.py <source_dir> [target_file]")
105 |     else: merge_traces(sys.argv[1], sys.argv[2] if len(sys.argv) > 2 else "fishtest_data.json")
    |         ^
    |

F401 [*] `os` imported but unused
 --> src\tools\migrate_to_qmd.py:7:8
  |
5 | """
6 | import hashlib
7 | import os
  |        ^^
8 | import subprocess
9 | import sys
  |
help: Remove unused import: `os`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\migrate_to_qmd.py:21:14
   |
19 |         if path.stat().st_size == 0:
20 |             return "EMPTY_FILE"
21 |         with open(path, 'rb') as f:
   |              ^^^^
22 |             return hashlib.sha256(f.read()).hexdigest()
23 |     except Exception:
   |
help: Replace with `Path.open()`

ANN001 Missing type annotation for function argument `dry_run`
  --> src\tools\migrate_to_qmd.py:26:33
   |
24 |         return "ERROR"
25 |
26 | def migrate_file(md_path: Path, dry_run=False) -> tuple[bool, str]:
   |                                 ^^^^^^^
27 |     """Rename .md to .qmd using git mv."""
28 |     qmd_path = md_path.with_suffix('.qmd')
   |

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:29:1
   |
27 |     """Rename .md to .qmd using git mv."""
28 |     qmd_path = md_path.with_suffix('.qmd')
29 |     
   | ^^^^
30 |     # Skip if already .qmd
31 |     if md_path.suffix != '.md':
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:33:1
   |
31 |     if md_path.suffix != '.md':
32 |         return False, f"SKIP: {md_path} (not .md)"
33 |     
   | ^^^^
34 |     # Check if target exists
35 |     if qmd_path.exists():
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:37:1
   |
35 |     if qmd_path.exists():
36 |         return False, f"CONFLICT: {qmd_path} already exists"
37 |     
   | ^^^^
38 |     if dry_run:
39 |         return True, f"DRY-RUN: {md_path} â†’ {qmd_path}"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:40:1
   |
38 |     if dry_run:
39 |         return True, f"DRY-RUN: {md_path} â†’ {qmd_path}"
40 |     
   | ^^^^
41 |     try:
42 |         result = subprocess.run(
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\migrate_to_qmd.py:42:18
   |
41 |     try:
42 |         result = subprocess.run(
   |                  ^^^^^^^^^^^^^^
43 |             ['git', 'mv', str(md_path), str(qmd_path)],
44 |             capture_output=True, text=True, cwd=PROJECT_ROOT
   |

S607 Starting a process with a partial executable path
  --> src\tools\migrate_to_qmd.py:43:13
   |
41 |     try:
42 |         result = subprocess.run(
43 |             ['git', 'mv', str(md_path), str(qmd_path)],
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
44 |             capture_output=True, text=True, cwd=PROJECT_ROOT
45 |         )
   |

RUF010 [*] Use explicit conversion flag
  --> src\tools\migrate_to_qmd.py:50:54
   |
48 |         return True, f"OK: {md_path.name} â†’ {qmd_path.name}"
49 |     except Exception as e:
50 |         return False, f"EXCEPTION: {md_path.name} - {str(e)}"
   |                                                      ^^^^^^
51 |
52 | def main():
   |
help: Replace with conversion flag

ANN201 Missing return type annotation for public function `main`
  --> src\tools\migrate_to_qmd.py:52:5
   |
50 |         return False, f"EXCEPTION: {md_path.name} - {str(e)}"
51 |
52 | def main():
   |     ^^^^
53 |     dry_run = "--dry-run" in sys.argv
54 |     md_files = list(PROJECT_ROOT.rglob("*.md"))
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:55:1
   |
53 |     dry_run = "--dry-run" in sys.argv
54 |     md_files = list(PROJECT_ROOT.rglob("*.md"))
55 |     
   | ^^^^
56 |     # Exclude backup directories and .gemini temp files
57 |     exclude = ["docs_backup", "CorvusStar_backup", ".gemini", "node_modules", ".git", ".corvus_quarantine"]
   |
help: Remove whitespace from blank line

E501 Line too long (107 > 100)
  --> src\tools\migrate_to_qmd.py:57:101
   |
56 |     # Exclude backup directories and .gemini temp files
57 |     exclude = ["docs_backup", "CorvusStar_backup", ".gemini", "node_modules", ".git", ".corvus_quarantine"]
   |                                                                                                     ^^^^^^^
58 |     md_files = [f for f in md_files if not any(x in str(f) for x in exclude)]
   |

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:59:1
   |
57 |     exclude = ["docs_backup", "CorvusStar_backup", ".gemini", "node_modules", ".git", ".corvus_quarantine"]
58 |     md_files = [f for f in md_files if not any(x in str(f) for x in exclude)]
59 |     
   | ^^^^
60 |     print(f"Found {len(md_files)} .md files to migrate" + (" (DRY RUN)" if dry_run else ""))
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:61:1
   |
60 |     print(f"Found {len(md_files)} .md files to migrate" + (" (DRY RUN)" if dry_run else ""))
61 |     
   | ^^^^
62 |     success = 0
63 |     failed = 0
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:64:1
   |
62 |     success = 0
63 |     failed = 0
64 |     
   | ^^^^
65 |     for md_file in sorted(md_files):
66 |         ok, msg = migrate_file(md_file, dry_run=dry_run)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\migrate_to_qmd.py:73:1
   |
71 |             if "SKIP" not in msg:
72 |                 failed += 1
73 |     
   | ^^^^
74 |     print(f"\n{'='*50}")
75 |     print(f"SUCCESS: {success} | FAILED: {failed}")
   |
help: Remove whitespace from blank line

F401 [*] `json` imported but unused
 --> src\tools\network_watcher.py:1:8
  |
1 | import json
  |        ^^^^
2 | import os
3 | import shutil
  |
help: Remove unused import: `json`

F401 [*] `pathlib.Path` imported but unused
 --> src\tools\network_watcher.py:7:21
  |
5 | import sys
6 | import time
7 | from pathlib import Path
  |                     ^^^^
8 |
9 | # Resolve shared UI from src/core/
  |
help: Remove unused import: `pathlib.Path`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:10:20
   |
 9 | # Resolve shared UI from src/core/
10 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                    ^^^^^^^^^^^^
11 | from ui import HUD
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:10:33
   |
 9 | # Resolve shared UI from src/core/
10 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                 ^^^^^^^^^^^^^^^
11 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:10:49
   |
 9 | # Resolve shared UI from src/core/
10 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                 ^^^^^^^^^^^^^^^
11 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\network_watcher.py:10:65
   |
 9 | # Resolve shared UI from src/core/
10 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                 ^^^^^^^^^^^^^^^
11 | from ui import HUD
   |
help: Replace with `Path(...).resolve()`

E501 Line too long (101 > 100)
  --> src\tools\network_watcher.py:10:101
   |
 9 | # Resolve shared UI from src/core/
10 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                                                     ^
11 | from ui import HUD
   |

E501 Line too long (143 > 100)
  --> src\tools\network_watcher.py:15:101
   |
13 | â€¦
14 | â€¦
15 | â€¦TED": "Anomaly Sector", "PASS": "Subjugated", "FAIL": "Defiant", "COLOR_MAIN": HUD.RED},
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 | â€¦CTED": "Trace Detected", "PASS": "Ingested", "FAIL": "Rejected", "COLOR_MAIN": HUD.CYAN}
17 | â€¦
   |

E501 Line too long (143 > 100)
  --> src\tools\network_watcher.py:16:101
   |
14 | â€¦
15 | â€¦TED": "Anomaly Sector", "PASS": "Subjugated", "FAIL": "Defiant", "COLOR_MAIN": HUD.RED},
16 | â€¦CTED": "Trace Detected", "PASS": "Ingested", "FAIL": "Rejected", "COLOR_MAIN": HUD.CYAN}
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 | â€¦
   |

ANN201 Missing return type annotation for public function `get_theme`
  --> src\tools\network_watcher.py:19:5
   |
17 | }
18 |
19 | def get_theme():
   |     ^^^^^^^^^
20 |     """Module-level theme retriever for legacy tests."""
21 |     return THEMES.get(HUD.PERSONA, THEMES["ALFRED"])
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `log_rejection`
  --> src\tools\network_watcher.py:23:5
   |
21 |     return THEMES.get(HUD.PERSONA, THEMES["ALFRED"])
22 |
23 | def log_rejection(filename: str, reason: str):
   |     ^^^^^^^^^^^^^
24 |     """Module-level rejection log."""
25 |     HUD.log_rejection(HUD.PERSONA, reason, filename)
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `process_file`
  --> src\tools\network_watcher.py:27:5
   |
25 |     HUD.log_rejection(HUD.PERSONA, reason, filename)
26 |
27 | def process_file(file_path: str):
   |     ^^^^^^^^^^^^
28 |     """Module-level process alias."""
29 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |
help: Add return type annotation: `None`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:29:18
   |
27 | def process_file(file_path: str):
28 |     """Module-level process alias."""
29 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                  ^^^^^^^^^^^^^^^
30 |     base = os.path.dirname(script_dir)
31 |     root = os.path.dirname(base)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\network_watcher.py:29:34
   |
27 | def process_file(file_path: str):
28 |     """Module-level process alias."""
29 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                                  ^^^^^^^^^^^^^^^
30 |     base = os.path.dirname(script_dir)
31 |     root = os.path.dirname(base)
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:30:12
   |
28 |     """Module-level process alias."""
29 |     script_dir = os.path.dirname(os.path.abspath(__file__))
30 |     base = os.path.dirname(script_dir)
   |            ^^^^^^^^^^^^^^^
31 |     root = os.path.dirname(base)
32 |     CruciblePipeline(root, base).process(file_path)
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:31:12
   |
29 |     script_dir = os.path.dirname(os.path.abspath(__file__))
30 |     base = os.path.dirname(script_dir)
31 |     root = os.path.dirname(base)
   |            ^^^^^^^^^^^^^^^
32 |     CruciblePipeline(root, base).process(file_path)
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:38:22
   |
36 |     def __init__(self, root: str, base: str) -> None:
37 |         self.root, self.base = root, base
38 |         self.stage = os.path.join(base, "traces", "staging")
   |                      ^^^^^^^^^^^^
39 |         self.proc = os.path.join(base, "traces", "processed")
40 |         self.quar = os.path.join(base, "traces", "quarantine")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:39:21
   |
37 |         self.root, self.base = root, base
38 |         self.stage = os.path.join(base, "traces", "staging")
39 |         self.proc = os.path.join(base, "traces", "processed")
   |                     ^^^^^^^^^^^^
40 |         self.quar = os.path.join(base, "traces", "quarantine")
41 |         self.db = os.path.join(root, "fishtest_data.json")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:40:21
   |
38 |         self.stage = os.path.join(base, "traces", "staging")
39 |         self.proc = os.path.join(base, "traces", "processed")
40 |         self.quar = os.path.join(base, "traces", "quarantine")
   |                     ^^^^^^^^^^^^
41 |         self.db = os.path.join(root, "fishtest_data.json")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:41:19
   |
39 |         self.proc = os.path.join(base, "traces", "processed")
40 |         self.quar = os.path.join(base, "traces", "quarantine")
41 |         self.db = os.path.join(root, "fishtest_data.json")
   |                   ^^^^^^^^^^^^
42 |
43 |     def process(self, file_path: str):
   |

ANN201 Missing return type annotation for public function `process`
  --> src\tools\network_watcher.py:43:9
   |
41 |         self.db = os.path.join(root, "fishtest_data.json")
42 |
43 |     def process(self, file_path: str):
   |         ^^^^^^^
44 |         name = os.path.basename(file_path)
45 |         HUD.box_top("CRUCIBLE SCAN")
   |
help: Add return type annotation: `None`

PTH119 `os.path.basename()` should be replaced by `Path.name`
  --> src\tools\network_watcher.py:44:16
   |
43 |     def process(self, file_path: str):
44 |         name = os.path.basename(file_path)
   |                ^^^^^^^^^^^^^^^^
45 |         HUD.box_top("CRUCIBLE SCAN")
46 |         HUD.log("INFO", f"Ingesting {name}")
   |
help: Replace with `Path(...).name`

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:47:1
   |
45 |         HUD.box_top("CRUCIBLE SCAN")
46 |         HUD.log("INFO", f"Ingesting {name}")
47 |         
   | ^^^^^^^^
48 |         try:
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
   |
help: Remove whitespace from blank line

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\tools\network_watcher.py:49:16
   |
48 |         try:
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
   |                ^^^^^^^^^^^^^^^
50 |             os.makedirs(self.stage, exist_ok=True)
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
   |
help: Replace with `Path(...).stat().st_size`

E701 Multiple statements on one line (colon)
  --> src\tools\network_watcher.py:49:52
   |
48 |         try:
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
   |                                                    ^
50 |             os.makedirs(self.stage, exist_ok=True)
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
   |

PTH103 `os.makedirs()` should be replaced by `Path.mkdir(parents=True)`
  --> src\tools\network_watcher.py:50:13
   |
48 |         try:
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
50 |             os.makedirs(self.stage, exist_ok=True)
   |             ^^^^^^^^^^^
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
   |
help: Replace with `Path(...).mkdir(parents=True)`

F841 Local variable `staging_path` is assigned to but never used
  --> src\tools\network_watcher.py:51:13
   |
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
50 |             os.makedirs(self.stage, exist_ok=True)
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
   |             ^^^^^^^^^^^^
52 |             
53 |             # Merge & Ordeal
   |
help: Remove assignment to unused variable `staging_path`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:51:51
   |
49 |             if os.path.getsize(file_path) > 5*10**6: raise ValueError("DoS: Oversized")
50 |             os.makedirs(self.stage, exist_ok=True)
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
   |                                                   ^^^^^^^^^^^^
52 |             
53 |             # Merge & Ordeal
   |

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:52:1
   |
50 |             os.makedirs(self.stage, exist_ok=True)
51 |             staging_path = shutil.move(file_path, os.path.join(self.stage, name))
52 |             
   | ^^^^^^^^^^^^
53 |             # Merge & Ordeal
54 |             backup = self.db + ".bak"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:56:1
   |
54 |             backup = self.db + ".bak"
55 |             shutil.copy2(self.db, backup)
56 |             
   | ^^^^^^^^^^^^
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:57:24
   |
55 |             shutil.copy2(self.db, backup)
56 |             
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
   |                        ^^^^^^^^^^^^
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:57:37
   |
55 |             shutil.copy2(self.db, backup)
56 |             
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
   |                                     ^^^^^^^^^^^^^^^
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
   |
help: Replace with `Path(...).parent`

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\network_watcher.py:58:19
   |
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
   |                   ^^^^^^^^^^^^^^
59 |             
60 |             if res.returncode == 0:
   |

E501 Line too long (102 > 100)
  --> src\tools\network_watcher.py:58:101
   |
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
   |                                                                                                     ^^
59 |             
60 |             if res.returncode == 0:
   |

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:59:1
   |
57 |             m_script = os.path.join(os.path.dirname(__file__), "merge_traces.py")
58 |             res = subprocess.run([sys.executable, m_script, self.stage, self.db], capture_output=True)
59 |             
   | ^^^^^^^^^^^^
60 |             if res.returncode == 0:
61 |                 HUD.log("PASS", "Trace Ingested")
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\network_watcher.py:62:20
   |
60 |             if res.returncode == 0:
61 |                 HUD.log("PASS", "Trace Ingested")
62 |                 if os.path.exists(backup): os.remove(backup)
   |                    ^^^^^^^^^^^^^^
63 |             else:
64 |                 HUD.log("FAIL", "Merge Error")
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\network_watcher.py:62:42
   |
60 |             if res.returncode == 0:
61 |                 HUD.log("PASS", "Trace Ingested")
62 |                 if os.path.exists(backup): os.remove(backup)
   |                                          ^
63 |             else:
64 |                 HUD.log("FAIL", "Merge Error")
   |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
  --> src\tools\network_watcher.py:62:44
   |
60 |             if res.returncode == 0:
61 |                 HUD.log("PASS", "Trace Ingested")
62 |                 if os.path.exists(backup): os.remove(backup)
   |                                            ^^^^^^^^^
63 |             else:
64 |                 HUD.log("FAIL", "Merge Error")
   |
help: Replace with `Path(...).unlink()`

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:66:1
   |
64 |                 HUD.log("FAIL", "Merge Error")
65 |                 shutil.copy2(backup, self.db)
66 |                 
   | ^^^^^^^^^^^^^^^^
67 |         except Exception as e:
68 |             HUD.log("FAIL", f"Pipeline Error: {str(e)[:40]}")
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `watch`
  --> src\tools\network_watcher.py:80:9
   |
78 |         self.pipeline = pipeline
79 |
80 |     def watch(self):
   |         ^^^^^
81 |         print(f"{HUD.CYAN}>> The Crucible is active. Watching: {self.share}...{HUD.RESET}")
82 |         while True:
   |
help: Add return type annotation: `None`

PTH208 Use `pathlib.Path.iterdir()` instead.
  --> src\tools\network_watcher.py:84:38
   |
82 |         while True:
83 |             try:
84 |                 for f in [f for f in os.listdir(self.share) if f.endswith('.json')]:
   |                                      ^^^^^^^^^^
85 |                     self.pipeline.process(os.path.join(self.share, f))
86 |                 time.sleep(3)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:85:43
   |
83 |             try:
84 |                 for f in [f for f in os.listdir(self.share) if f.endswith('.json')]:
85 |                     self.pipeline.process(os.path.join(self.share, f))
   |                                           ^^^^^^^^^^^^
86 |                 time.sleep(3)
87 |             except KeyboardInterrupt: break
   |

E701 Multiple statements on one line (colon)
  --> src\tools\network_watcher.py:87:37
   |
85 |                     self.pipeline.process(os.path.join(self.share, f))
86 |                 time.sleep(3)
87 |             except KeyboardInterrupt: break
   |                                     ^
88 |             except (IOError, OSError): time.sleep(5)
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\network_watcher.py:88:20
   |
86 |                 time.sleep(3)
87 |             except KeyboardInterrupt: break
88 |             except (IOError, OSError): time.sleep(5)
   |                    ^^^^^^^^^^^^^^^^^^
89 |
90 | if __name__ == "__main__":
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\tools\network_watcher.py:88:38
   |
86 |                 time.sleep(3)
87 |             except KeyboardInterrupt: break
88 |             except (IOError, OSError): time.sleep(5)
   |                                      ^
89 |
90 | if __name__ == "__main__":
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:91:18
   |
90 | if __name__ == "__main__":
91 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                  ^^^^^^^^^^^^^^^
92 |     base = os.path.dirname(script_dir)
93 |     root = os.path.dirname(base)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\network_watcher.py:91:34
   |
90 | if __name__ == "__main__":
91 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                                  ^^^^^^^^^^^^^^^
92 |     base = os.path.dirname(script_dir)
93 |     root = os.path.dirname(base)
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:92:12
   |
90 | if __name__ == "__main__":
91 |     script_dir = os.path.dirname(os.path.abspath(__file__))
92 |     base = os.path.dirname(script_dir)
   |            ^^^^^^^^^^^^^^^
93 |     root = os.path.dirname(base)
94 |     share = os.path.join(root, "mock_project", "network_share")
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\network_watcher.py:93:12
   |
91 |     script_dir = os.path.dirname(os.path.abspath(__file__))
92 |     base = os.path.dirname(script_dir)
93 |     root = os.path.dirname(base)
   |            ^^^^^^^^^^^^^^^
94 |     share = os.path.join(root, "mock_project", "network_share")
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\network_watcher.py:94:13
   |
92 |     base = os.path.dirname(script_dir)
93 |     root = os.path.dirname(base)
94 |     share = os.path.join(root, "mock_project", "network_share")
   |             ^^^^^^^^^^^^
95 |     
96 |     pipe = CruciblePipeline(root, base)
   |

W293 [*] Blank line contains whitespace
  --> src\tools\network_watcher.py:95:1
   |
93 |     root = os.path.dirname(base)
94 |     share = os.path.join(root, "mock_project", "network_share")
95 |     
   | ^^^^
96 |     pipe = CruciblePipeline(root, base)
97 |     NetworkWatcher(share, pipe).watch()
   |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
  --> src\tools\network_watcher.py:97:40
   |
96 |     pipe = CruciblePipeline(root, base)
97 |     NetworkWatcher(share, pipe).watch()
   |                                        ^
   |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\tools\overwatch.py:1:1
  |
1 | import json
  | ^^^^^^^^^^^
2 | try:
3 |     import msvcrt
  |
help: Organize imports

F401 [*] `datetime.datetime` imported but unused
  --> src\tools\overwatch.py:10:22
   |
 8 | import sys
 9 | import time
10 | from datetime import datetime
   |                      ^^^^^^^^
11 | from typing import Dict, List, Optional, Tuple
   |
help: Remove unused import: `datetime.datetime`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src\tools\overwatch.py:11:1
   |
 9 | import time
10 | from datetime import datetime
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | # Resolve shared UI from src/core/
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src\tools\overwatch.py:11:1
   |
 9 | import time
10 | from datetime import datetime
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | # Resolve shared UI from src/core/
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src\tools\overwatch.py:11:1
   |
 9 | import time
10 | from datetime import datetime
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | # Resolve shared UI from src/core/
   |

F401 [*] `typing.Tuple` imported but unused
  --> src\tools\overwatch.py:11:42
   |
 9 | import time
10 | from datetime import datetime
11 | from typing import Dict, List, Optional, Tuple
   |                                          ^^^^^
12 |
13 | # Resolve shared UI from src/core/
   |
help: Remove unused import: `typing.Tuple`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\overwatch.py:14:20
   |
13 | # Resolve shared UI from src/core/
14 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                    ^^^^^^^^^^^^
15 | from ui import HUD
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\overwatch.py:14:33
   |
13 | # Resolve shared UI from src/core/
14 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                 ^^^^^^^^^^^^^^^
15 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\overwatch.py:14:49
   |
13 | # Resolve shared UI from src/core/
14 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                 ^^^^^^^^^^^^^^^
15 | from ui import HUD
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\overwatch.py:14:65
   |
13 | # Resolve shared UI from src/core/
14 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                 ^^^^^^^^^^^^^^^
15 | from ui import HUD
   |
help: Replace with `Path(...).resolve()`

E501 Line too long (101 > 100)
  --> src\tools\overwatch.py:14:101
   |
13 | # Resolve shared UI from src/core/
14 | sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core"))
   |                                                                                                     ^
15 | from ui import HUD
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\overwatch.py:23:24
   |
21 |         self.root = project_root
22 |         self.base = base_dir
23 |         self.db_path = os.path.join(project_root, "fishtest_data.json")
   |                        ^^^^^^^^^^^^
24 |         self.rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\overwatch.py:24:25
   |
22 |         self.base = base_dir
23 |         self.db_path = os.path.join(project_root, "fishtest_data.json")
24 |         self.rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
   |                         ^^^^^^^^^^^^
25 |
26 |     def collect(self) -> Dict[str, int]:
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src\tools\overwatch.py:26:26
   |
24 |         self.rej_path = os.path.join(base_dir, "traces", "quarantine", "REJECTIONS.qmd")
25 |
26 |     def collect(self) -> Dict[str, int]:
   |                          ^^^^
27 |         stats = {"cases": 0, "rejections": 0, "war_zones": 0}
28 |         try:
   |
help: Replace with `dict`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\overwatch.py:29:16
   |
27 |         stats = {"cases": 0, "rejections": 0, "war_zones": 0}
28 |         try:
29 |             if os.path.exists(self.db_path):
   |                ^^^^^^^^^^^^^^
30 |                 with open(self.db_path, 'r', encoding='utf-8') as f:
31 |                     cases = json.load(f).get("test_cases", [])
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\overwatch.py:30:22
   |
28 |         try:
29 |             if os.path.exists(self.db_path):
30 |                 with open(self.db_path, 'r', encoding='utf-8') as f:
   |                      ^^^^
31 |                     cases = json.load(f).get("test_cases", [])
32 |                     stats["cases"] = len(cases)
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\overwatch.py:30:41
   |
28 |         try:
29 |             if os.path.exists(self.db_path):
30 |                 with open(self.db_path, 'r', encoding='utf-8') as f:
   |                                         ^^^
31 |                     cases = json.load(f).get("test_cases", [])
32 |                     stats["cases"] = len(cases)
   |
help: Remove mode argument

E501 Line too long (121 > 100)
  --> src\tools\overwatch.py:33:101
   |
31 |                     cases = json.load(f).get("test_cases", [])
32 |                     stats["cases"] = len(cases)
33 |                     stats["war_zones"] = sum(1 for c in cases if all(p in c.get("tags", []) for p in ["O.D.I.N.", "ALFRED"]))
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^
34 |             
35 |             if os.path.exists(self.rej_path):
   |

W293 [*] Blank line contains whitespace
  --> src\tools\overwatch.py:34:1
   |
32 |                     stats["cases"] = len(cases)
33 |                     stats["war_zones"] = sum(1 for c in cases if all(p in c.get("tags", []) for p in ["O.D.I.N.", "ALFRED"]))
34 |             
   | ^^^^^^^^^^^^
35 |             if os.path.exists(self.rej_path):
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\overwatch.py:35:16
   |
33 |                     stats["war_zones"] = sum(1 for c in cases if all(p in c.get("tags", []) for p in ["O.D.I.N.", "ALFRED"]))
34 |             
35 |             if os.path.exists(self.rej_path):
   |                ^^^^^^^^^^^^^^
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
37 |                     stats["rejections"] = max(0, len(f.readlines()) - 3)
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\overwatch.py:36:22
   |
35 |             if os.path.exists(self.rej_path):
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
   |                      ^^^^
37 |                     stats["rejections"] = max(0, len(f.readlines()) - 3)
38 |         except (json.JSONDecodeError, IOError, OSError): pass
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\overwatch.py:36:42
   |
35 |             if os.path.exists(self.rej_path):
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
   |                                          ^^^
37 |                     stats["rejections"] = max(0, len(f.readlines()) - 3)
38 |         except (json.JSONDecodeError, IOError, OSError): pass
   |
help: Remove mode argument

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\overwatch.py:38:16
   |
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
37 |                     stats["rejections"] = max(0, len(f.readlines()) - 3)
38 |         except (json.JSONDecodeError, IOError, OSError): pass
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |         return stats
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\tools\overwatch.py:38:56
   |
36 |                 with open(self.rej_path, 'r', encoding='utf-8') as f:
37 |                     stats["rejections"] = max(0, len(f.readlines()) - 3)
38 |         except (json.JSONDecodeError, IOError, OSError): pass
   |                                                        ^
39 |         return stats
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\overwatch.py:44:29
   |
42 |     """[ALFRED] Dashboard renderer for the Neural Overwatch TUI."""
43 |     def __init__(self) -> None:
44 |         self.latency_trend: List[float] = []
   |                             ^^^^
45 |
46 |     def render_header(self):
   |
help: Replace with `list`

ANN201 Missing return type annotation for public function `render_header`
  --> src\tools\overwatch.py:46:9
   |
44 |         self.latency_trend: List[float] = []
45 |
46 |     def render_header(self):
   |         ^^^^^^^^^^^^^
47 |         print(f"\n{HUD.RED}{HUD.BOLD}Î© NEURAL OVERWATCH Î©{HUD.RESET}")
48 |         print(f"{HUD.DIM}Monitoring Federated Network...{HUD.RESET}\n")
   |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `render_heatmap`
  --> src\tools\overwatch.py:51:9
   |
49 |         HUD.log("INFO", "System Online", "Listening on mock_project/network_share")
50 |
51 |     def render_heatmap(self, threat_matrix: List[float]):
   |         ^^^^^^^^^^^^^^
52 |         """Render a 5x5 sc-fi security heatmap."""
53 |         print(f"\n{HUD.BOLD}SECURITY HEATMAP [HEIMDALL SCAN]{HUD.RESET}")
   |
help: Add return type annotation: `None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\overwatch.py:51:45
   |
49 |         HUD.log("INFO", "System Online", "Listening on mock_project/network_share")
50 |
51 |     def render_heatmap(self, threat_matrix: List[float]):
   |                                             ^^^^
52 |         """Render a 5x5 sc-fi security heatmap."""
53 |         print(f"\n{HUD.BOLD}SECURITY HEATMAP [HEIMDALL SCAN]{HUD.RESET}")
   |
help: Replace with `list`

E701 Multiple statements on one line (colon)
  --> src\tools\overwatch.py:61:21
   |
60 |     def _color_cell(self, val: float) -> str:
61 |         if val > 0.8: return f"{HUD.RED}â– {HUD.RESET}"
   |                     ^
62 |         if val > 0.4: return f"{HUD.YELLOW}â– {HUD.RESET}"
63 |         return f"{HUD.GREEN}â– {HUD.RESET}"
   |

E701 Multiple statements on one line (colon)
  --> src\tools\overwatch.py:62:21
   |
60 |     def _color_cell(self, val: float) -> str:
61 |         if val > 0.8: return f"{HUD.RED}â– {HUD.RESET}"
62 |         if val > 0.4: return f"{HUD.YELLOW}â– {HUD.RESET}"
   |                     ^
63 |         return f"{HUD.GREEN}â– {HUD.RESET}"
   |

ANN201 Missing return type annotation for public function `render_pulse_logs`
  --> src\tools\overwatch.py:65:9
   |
63 |         return f"{HUD.GREEN}â– {HUD.RESET}"
64 |
65 |     def render_pulse_logs(self, logs: List[str]):
   |         ^^^^^^^^^^^^^^^^^
66 |         """Render the 5 most recent neural pulse events."""
67 |         print(f"\n{HUD.BOLD}NEURAL PULSE LOGS [LATEST INTENTS]{HUD.RESET}")
   |
help: Add return type annotation: `None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src\tools\overwatch.py:65:39
   |
63 |         return f"{HUD.GREEN}â– {HUD.RESET}"
64 |
65 |     def render_pulse_logs(self, logs: List[str]):
   |                                       ^^^^
66 |         """Render the 5 most recent neural pulse events."""
67 |         print(f"\n{HUD.BOLD}NEURAL PULSE LOGS [LATEST INTENTS]{HUD.RESET}")
   |
help: Replace with `list`

E701 Multiple statements on one line (colon)
  --> src\tools\overwatch.py:70:20
   |
68 |         for log in logs[-5:]:
69 |             print(f"  {HUD.DIM}Â»{HUD.RESET} {HUD.CYAN}{log}{HUD.RESET}")
70 |         if not logs: print(f"  {HUD.DIM}(Waiting for signal...){HUD.RESET}")
   |                    ^
71 |
72 |     def update_latency(self, lat: float):
   |

ANN201 Missing return type annotation for public function `update_latency`
  --> src\tools\overwatch.py:72:9
   |
70 |         if not logs: print(f"  {HUD.DIM}(Waiting for signal...){HUD.RESET}")
71 |
72 |     def update_latency(self, lat: float):
   |         ^^^^^^^^^^^^^^
73 |         self.latency_trend.append(lat)
74 |         if len(self.latency_trend) > 20: self.latency_trend.pop(0)
   |
help: Add return type annotation: `None`

E701 Multiple statements on one line (colon)
  --> src\tools\overwatch.py:74:40
   |
72 |     def update_latency(self, lat: float):
73 |         self.latency_trend.append(lat)
74 |         if len(self.latency_trend) > 20: self.latency_trend.pop(0)
   |                                        ^
75 |         status = "PASS" if lat < 100 else "WARN"
76 |         HUD.log(status, f"Engine Latency: {lat:.2f}ms", f"Trend: {HUD.render_sparkline(self.latency_trend)}")
   |

E501 Line too long (109 > 100)
  --> src\tools\overwatch.py:76:101
   |
74 |         if len(self.latency_trend) > 20: self.latency_trend.pop(0)
75 |         status = "PASS" if lat < 100 else "WARN"
76 |         HUD.log(status, f"Engine Latency: {lat:.2f}ms", f"Trend: {HUD.render_sparkline(self.latency_trend)}")
   |                                                                                                     ^^^^^^^^^
77 |
78 | class InputManager:
   |

UP045 [*] Use `X | None` for type annotations
  --> src\tools\overwatch.py:81:19
   |
79 |     """[ALFRED] Non-blocking input handler for interactive controls."""
80 |     @staticmethod
81 |     def poll() -> Optional[str]:
   |                   ^^^^^^^^^^^^^
82 |         if os.name == 'nt' and msvcrt and msvcrt.kbhit():
83 |             return msvcrt.getch().decode('utf-8').lower()
   |
help: Convert to `X | None`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\overwatch.py:88:21
   |
86 | class Overwatch:
87 |     def __init__(self) -> None:
88 |         self.base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                     ^^^^^^^^^^^^^^^
89 |         self.root = os.path.dirname(self.base)
90 |         self.collector = StatsCollector(self.root, self.base)
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\overwatch.py:88:37
   |
86 | class Overwatch:
87 |     def __init__(self) -> None:
88 |         self.base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                                     ^^^^^^^^^^^^^^^
89 |         self.root = os.path.dirname(self.base)
90 |         self.collector = StatsCollector(self.root, self.base)
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\overwatch.py:88:53
   |
86 | class Overwatch:
87 |     def __init__(self) -> None:
88 |         self.base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
   |                                                     ^^^^^^^^^^^^^^^
89 |         self.root = os.path.dirname(self.base)
90 |         self.collector = StatsCollector(self.root, self.base)
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\overwatch.py:89:21
   |
87 |     def __init__(self) -> None:
88 |         self.base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
89 |         self.root = os.path.dirname(self.base)
   |                     ^^^^^^^^^^^^^^^
90 |         self.collector = StatsCollector(self.root, self.base)
91 |         self.renderer = OverwatchRenderer()
   |
help: Replace with `Path(...).parent`

ANN201 Missing return type annotation for public function `run`
  --> src\tools\overwatch.py:95:9
   |
93 |         self.pulse = 0
94 |
95 |     def run(self):
   |         ^^^
96 |         self.renderer.render_header()
97 |         # Initial scan
   |
help: Add return type annotation: `None`

W291 [*] Trailing whitespace
   --> src\tools\overwatch.py:103:41
    |
101 |             try:
102 |                 self._handle_input()
103 |                 if self.pulse % 20 == 0: 
    |                                         ^
104 |                     self._check_delta()
105 |                     pulse_logs = self._get_latest_pulses()
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\overwatch.py:106:41
    |
104 |                     self._check_delta()
105 |                     pulse_logs = self._get_latest_pulses()
106 |                 if self.pulse % 50 == 0: 
    |                                         ^
107 |                     threats = self._update_heatmap()
108 |                     self.renderer.render_heatmap(threats)
    |
help: Remove trailing whitespace

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:110:41
    |
108 |                     self.renderer.render_heatmap(threats)
109 |                     self.renderer.render_pulse_logs(pulse_logs)
110 |                 if self.pulse % 600 == 0: self._measure_latency()
    |                                         ^
111 |                 time.sleep(0.1)
112 |                 self.pulse += 1
    |

E702 Multiple statements on one line (semicolon)
   --> src\tools\overwatch.py:114:54
    |
112 |                 self.pulse += 1
113 |             except KeyboardInterrupt:
114 |                 HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
    |                                                      ^
115 |             except Exception as e:
116 |                 HUD.log("FAIL", f"Monitor Error: {str(e)[:40]}"); time.sleep(5)
    |

E702 Multiple statements on one line (semicolon)
   --> src\tools\overwatch.py:116:65
    |
114 |                 HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
115 |             except Exception as e:
116 |                 HUD.log("FAIL", f"Monitor Error: {str(e)[:40]}"); time.sleep(5)
    |                                                                 ^
117 |
118 |     def _handle_input(self):
    |

ANN202 Missing return type annotation for private function `_handle_input`
   --> src\tools\overwatch.py:118:9
    |
116 |                 HUD.log("FAIL", f"Monitor Error: {str(e)[:40]}"); time.sleep(5)
117 |
118 |     def _handle_input(self):
    |         ^^^^^^^^^^^^^
119 |         cmd = InputManager.poll()
120 |         if not cmd: return
    |
help: Add return type annotation: `None`

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:120:19
    |
118 |     def _handle_input(self):
119 |         cmd = InputManager.poll()
120 |         if not cmd: return
    |                   ^
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
    |

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:121:22
    |
119 |         cmd = InputManager.poll()
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
    |                      ^
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
    |

E702 Multiple statements on one line (semicolon)
   --> src\tools\overwatch.py:121:61
    |
119 |         cmd = InputManager.poll()
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
    |                                                             ^
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
    |

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:122:24
    |
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
    |                        ^
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
124 |         elif cmd == 'p':
    |

S605 Starting a process with a shell: seems safe, but may be changed in the future; consider rewriting without `shell`
   --> src\tools\overwatch.py:122:26
    |
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
    |                          ^^^^^^^^^
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
124 |         elif cmd == 'p':
    |

S607 Starting a process with a partial executable path
   --> src\tools\overwatch.py:122:36
    |
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
    |                                    ^^^^^
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
124 |         elif cmd == 'p':
    |

E702 Multiple statements on one line (semicolon)
   --> src\tools\overwatch.py:122:42
    |
120 |         if not cmd: return
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
    |                                          ^
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
124 |         elif cmd == 'p':
    |

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:123:24
    |
121 |         if cmd == 'q': HUD.log("INFO", "Overwatch Shutdown"); sys.exit(0)
122 |         elif cmd == 'c': os.system('cls'); self.renderer.render_header()
123 |         elif cmd == 'h': self.renderer.render_heatmap([0.1]*25)
    |                        ^
124 |         elif cmd == 'p':
125 |             rej_path = self.collector.rej_path
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\tools\overwatch.py:126:16
    |
124 |         elif cmd == 'p':
125 |             rej_path = self.collector.rej_path
126 |             if os.path.exists(rej_path):
    |                ^^^^^^^^^^^^^^
127 |                 with open(rej_path, 'w', encoding='utf-8') as f: f.write("# Rejection Ledger\n\n")
128 |                 HUD.log("WARN", "Rejection Ledger Purged")
    |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\overwatch.py:127:22
    |
125 |             rej_path = self.collector.rej_path
126 |             if os.path.exists(rej_path):
127 |                 with open(rej_path, 'w', encoding='utf-8') as f: f.write("# Rejection Ledger\n\n")
    |                      ^^^^
128 |                 HUD.log("WARN", "Rejection Ledger Purged")
    |
help: Replace with `Path.open()`

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:127:64
    |
125 |             rej_path = self.collector.rej_path
126 |             if os.path.exists(rej_path):
127 |                 with open(rej_path, 'w', encoding='utf-8') as f: f.write("# Rejection Ledger\n\n")
    |                                                                ^
128 |                 HUD.log("WARN", "Rejection Ledger Purged")
    |

ANN202 Missing return type annotation for private function `_check_delta`
   --> src\tools\overwatch.py:130:9
    |
128 |                 HUD.log("WARN", "Rejection Ledger Purged")
129 |
130 |     def _check_delta(self):
    |         ^^^^^^^^^^^^
131 |         curr = self.collector.collect()
132 |         if curr["cases"] > self.last_stats["cases"]:
    |
help: Add return type annotation: `None`

E501 Line too long (123 > 100)
   --> src\tools\overwatch.py:133:101
    |
131 |         curr = self.collector.collect()
132 |         if curr["cases"] > self.last_stats["cases"]:
133 |             HUD.log("PASS", f"Ingested {curr['cases'] - self.last_stats['cases']} new traces", f"(Total: {curr['cases']})")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
134 |         if curr["rejections"] > self.last_stats["rejections"]:
135 |             HUD.log("WARN", f"New Trace Rejected", f"(Total: {curr['rejections']})")
    |

F541 [*] f-string without any placeholders
   --> src\tools\overwatch.py:135:29
    |
133 |             HUD.log("PASS", f"Ingested {curr['cases'] - self.last_stats['cases']} new traces", f"(Total: {curr['cases']})")
134 |         if curr["rejections"] > self.last_stats["rejections"]:
135 |             HUD.log("WARN", f"New Trace Rejected", f"(Total: {curr['rejections']})")
    |                             ^^^^^^^^^^^^^^^^^^^^^
136 |         if curr["war_zones"] > self.last_stats["war_zones"]:
137 |             HUD.log("CRITICAL", "New War Zone Detected")
    |
help: Remove extraneous `f` prefix

ANN202 Missing return type annotation for private function `_measure_latency`
   --> src\tools\overwatch.py:140:9
    |
138 |         self.last_stats = curr
139 |
140 |     def _measure_latency(self):
    |         ^^^^^^^^^^^^^^^^
141 |         l_script = os.path.join(self.base, "scripts", "latency_check.py")
142 |         res = subprocess.run([sys.executable, l_script, "3"], capture_output=True, text=True)
    |
help: Add return type annotation: `None`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:141:20
    |
140 |     def _measure_latency(self):
141 |         l_script = os.path.join(self.base, "scripts", "latency_check.py")
    |                    ^^^^^^^^^^^^
142 |         res = subprocess.run([sys.executable, l_script, "3"], capture_output=True, text=True)
143 |         if res.returncode == 0:
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\overwatch.py:142:15
    |
140 |     def _measure_latency(self):
141 |         l_script = os.path.join(self.base, "scripts", "latency_check.py")
142 |         res = subprocess.run([sys.executable, l_script, "3"], capture_output=True, text=True)
    |               ^^^^^^^^^^^^^^
143 |         if res.returncode == 0:
144 |             try: self.renderer.update_latency(float(res.stdout.strip()))
    |

SIM105 Use `contextlib.suppress(ValueError, TypeError)` instead of `try`-`except`-`pass`
   --> src\tools\overwatch.py:144:13
    |
142 |           res = subprocess.run([sys.executable, l_script, "3"], capture_output=True, text=True)
143 |           if res.returncode == 0:
144 | /             try: self.renderer.update_latency(float(res.stdout.strip()))
145 | |             except (ValueError, TypeError): pass
    | |________________________________________________^
146 |
147 |       def _update_heatmap(self) -> List[float]:
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(ValueError, TypeError): ...`

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:144:16
    |
142 |         res = subprocess.run([sys.executable, l_script, "3"], capture_output=True, text=True)
143 |         if res.returncode == 0:
144 |             try: self.renderer.update_latency(float(res.stdout.strip()))
    |                ^
145 |             except (ValueError, TypeError): pass
    |

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:145:43
    |
143 |         if res.returncode == 0:
144 |             try: self.renderer.update_latency(float(res.stdout.strip()))
145 |             except (ValueError, TypeError): pass
    |                                           ^
146 |
147 |     def _update_heatmap(self) -> List[float]:
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\tools\overwatch.py:147:34
    |
145 |             except (ValueError, TypeError): pass
146 |
147 |     def _update_heatmap(self) -> List[float]:
    |                                  ^^^^
148 |         """[O.D.I.N.] Scan core scripts for vulnerabilities to populate matrix."""
149 |         from security_scan import SecurityScanner
    |
help: Replace with `list`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:150:23
    |
148 |         """[O.D.I.N.] Scan core scripts for vulnerabilities to populate matrix."""
149 |         from security_scan import SecurityScanner
150 |         scripts_dir = os.path.join(self.base, "scripts")
    |                       ^^^^^^^^^^^^
151 |         files = [f for f in os.listdir(scripts_dir) if f.endswith(".py")][:25]
    |

PTH208 Use `pathlib.Path.iterdir()` instead.
   --> src\tools\overwatch.py:151:29
    |
149 |         from security_scan import SecurityScanner
150 |         scripts_dir = os.path.join(self.base, "scripts")
151 |         files = [f for f in os.listdir(scripts_dir) if f.endswith(".py")][:25]
    |                             ^^^^^^^^^^
152 |         
153 |         matrix = [0.0] * 25
    |

W293 [*] Blank line contains whitespace
   --> src\tools\overwatch.py:152:1
    |
150 |         scripts_dir = os.path.join(self.base, "scripts")
151 |         files = [f for f in os.listdir(scripts_dir) if f.endswith(".py")][:25]
152 |         
    | ^^^^^^^^
153 |         matrix = [0.0] * 25
154 |         for i, f in enumerate(files):
    |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:155:39
    |
153 |         matrix = [0.0] * 25
154 |         for i, f in enumerate(files):
155 |             scanner = SecurityScanner(os.path.join(scripts_dir, f))
    |                                       ^^^^^^^^^^^^
156 |             scanner.scan()
157 |             matrix[i] = scanner.threat_score / 10.0 # Normalize 0-1
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> src\tools\overwatch.py:160:37
    |
158 |         return matrix
159 |
160 |     def _get_latest_pulses(self) -> List[str]:
    |                                     ^^^^
161 |         """[ALFRED] Extract most recent triggers from trace artifacts."""
162 |         trace_dir = os.path.join(self.base, "traces")
    |
help: Replace with `list`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:162:21
    |
160 |     def _get_latest_pulses(self) -> List[str]:
161 |         """[ALFRED] Extract most recent triggers from trace artifacts."""
162 |         trace_dir = os.path.join(self.base, "traces")
    |                     ^^^^^^^^^^^^
163 |         if not os.path.exists(trace_dir): return []
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\tools\overwatch.py:163:16
    |
161 | â€¦     """[ALFRED] Extract most recent triggers from trace artifacts."""
162 | â€¦     trace_dir = os.path.join(self.base, "traces")
163 | â€¦     if not os.path.exists(trace_dir): return []
    |              ^^^^^^^^^^^^^^
164 | â€¦     
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:163:41
    |
161 | â€¦     """[ALFRED] Extract most recent triggers from trace artifacts."""
162 | â€¦     trace_dir = os.path.join(self.base, "traces")
163 | â€¦     if not os.path.exists(trace_dir): return []
    |                                       ^
164 | â€¦     
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
    |

W293 [*] Blank line contains whitespace
   --> src\tools\overwatch.py:164:1
    |
162 | â€¦     trace_dir = os.path.join(self.base, "traces")
163 | â€¦     if not os.path.exists(trace_dir): return []
164 | â€¦     
    ^^^^^^^^
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
166 | â€¦     triggers = []
    |
help: Remove whitespace from blank line

PTH208 Use `pathlib.Path.iterdir()` instead.
   --> src\tools\overwatch.py:165:36
    |
163 | â€¦     if not os.path.exists(trace_dir): return []
164 | â€¦     
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
    |                                  ^^^^^^^^^^
166 | â€¦     triggers = []
167 | â€¦     for f in files[-10:]: # Look at last 10 files
    |

PTH204 `os.path.getmtime` should be replaced by `Path.stat().st_mtime`
   --> src\tools\overwatch.py:165:97
    |
163 | â€¦     if not os.path.exists(trace_dir): return []
164 | â€¦     
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
    |                                                                                               ^^^^^^^^^^^^^^^^
166 | â€¦     triggers = []
167 | â€¦     for f in files[-10:]: # Look at last 10 files
    |
help: Replace with `Path.stat(...).st_mtime`

E501 Line too long (141 > 100)
   --> src\tools\overwatch.py:165:101
    |
163 | â€¦
164 | â€¦
165 | â€¦) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dir, x)))
    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
166 | â€¦
167 | â€¦
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:165:114
    |
163 | â€¦     if not os.path.exists(trace_dir): return []
164 | â€¦     
165 | â€¦     files = sorted([f for f in os.listdir(trace_dir) if f.endswith(".json")], key=lambda x: os.path.getmtime(os.path.join(trace_dirâ€¦
    |                                                                                                                ^^^^^^^^^^^^
166 | â€¦     triggers = []
167 | â€¦     for f in files[-10:]: # Look at last 10 files
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\overwatch.py:169:22
    |
167 |         for f in files[-10:]: # Look at last 10 files
168 |             try:
169 |                 with open(os.path.join(trace_dir, f), 'r', encoding='utf-8') as tf:
    |                      ^^^^
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
    |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\overwatch.py:169:27
    |
167 |         for f in files[-10:]: # Look at last 10 files
168 |             try:
169 |                 with open(os.path.join(trace_dir, f), 'r', encoding='utf-8') as tf:
    |                           ^^^^^^^^^^^^
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
    |

UP015 [*] Unnecessary mode argument
   --> src\tools\overwatch.py:169:55
    |
167 |         for f in files[-10:]: # Look at last 10 files
168 |             try:
169 |                 with open(os.path.join(trace_dir, f), 'r', encoding='utf-8') as tf:
    |                                                       ^^^
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
    |
help: Remove mode argument

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:171:41
    |
169 |                 with open(os.path.join(trace_dir, f), 'r', encoding='utf-8') as tf:
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
    |                                         ^
172 |             except (json.JSONDecodeError, IOError, OSError): pass
173 |         return triggers
    |

UP024 [*] Replace aliased errors with `OSError`
   --> src\tools\overwatch.py:172:20
    |
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
172 |             except (json.JSONDecodeError, IOError, OSError): pass
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
173 |         return triggers
    |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
   --> src\tools\overwatch.py:172:60
    |
170 |                     data = json.load(tf)
171 |                     if "trigger" in data: triggers.append(data["trigger"])
172 |             except (json.JSONDecodeError, IOError, OSError): pass
    |                                                            ^
173 |         return triggers
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src\tools\overwatch.py:175:20
    |
173 |         return triggers
174 |
175 | def get_stats() -> Dict[str, int]:
    |                    ^^^^
176 |     """[ALFRED] Compatibility wrapper for the test suite."""
177 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |
help: Replace with `dict`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\overwatch.py:177:12
    |
175 | def get_stats() -> Dict[str, int]:
176 |     """[ALFRED] Compatibility wrapper for the test suite."""
177 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |            ^^^^^^^^^^^^^^^
178 |     root = os.path.dirname(base)
179 |     return StatsCollector(root, base).collect()
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\overwatch.py:177:28
    |
175 | def get_stats() -> Dict[str, int]:
176 |     """[ALFRED] Compatibility wrapper for the test suite."""
177 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |                            ^^^^^^^^^^^^^^^
178 |     root = os.path.dirname(base)
179 |     return StatsCollector(root, base).collect()
    |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> src\tools\overwatch.py:177:44
    |
175 | def get_stats() -> Dict[str, int]:
176 |     """[ALFRED] Compatibility wrapper for the test suite."""
177 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    |                                            ^^^^^^^^^^^^^^^
178 |     root = os.path.dirname(base)
179 |     return StatsCollector(root, base).collect()
    |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\overwatch.py:178:12
    |
176 |     """[ALFRED] Compatibility wrapper for the test suite."""
177 |     base = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
178 |     root = os.path.dirname(base)
    |            ^^^^^^^^^^^^^^^
179 |     return StatsCollector(root, base).collect()
    |
help: Replace with `Path(...).parent`

W292 [*] No newline at end of file
   --> src\tools\overwatch.py:182:22
    |
181 | if __name__ == "__main__":
182 |     Overwatch().run()
    |                      ^
    |
help: Add trailing newline

F401 [*] `os` imported but unused
  --> src\tools\perimeter_sweep.py:16:8
   |
14 | import json
15 | import logging
16 | import os
   |        ^^
17 | import subprocess
18 | import sys
   |
help: Remove unused import: `os`

E402 Module level import not at top of file
  --> src\tools\perimeter_sweep.py:30:1
   |
28 |     sys.path.append(str(project_root))
29 |
30 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 | # Configure Logging
   |

W293 [*] Blank line contains whitespace
  --> src\tools\perimeter_sweep.py:49:1
   |
47 |         self.purge = purge
48 |         self.report_path = project_root / ".agent" / "perimeter_report.json"
49 |         
   | ^^^^^^^^
50 |         # Enforce ALFRED persona for this tool
51 |         HUD.PERSONA = "ALFRED"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\perimeter_sweep.py:57:1
   |
55 |         HUD.persona_log("INFO", "Executing pip-audit for Python dependencies...")
56 |         report = {"status": "success", "vulnerabilities": 0, "details": []}
57 |         
   | ^^^^^^^^
58 |         try:
59 |             # We use --format=json to parse the output reliably
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\perimeter_sweep.py:65:1
   |
63 |             if req_file.exists():
64 |                  cmd.extend(["-r", str(req_file)])
65 |                  
   | ^^^^^^^^^^^^^^^^^
66 |             result = subprocess.run(cmd, capture_output=True, text=True)
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\perimeter_sweep.py:66:22
   |
64 |                  cmd.extend(["-r", str(req_file)])
65 |                  
66 |             result = subprocess.run(cmd, capture_output=True, text=True)
   |                      ^^^^^^^^^^^^^^
67 |             
68 |             if result.stdout:
   |

W293 [*] Blank line contains whitespace
  --> src\tools\perimeter_sweep.py:67:1
   |
66 |             result = subprocess.run(cmd, capture_output=True, text=True)
67 |             
   | ^^^^^^^^^^^^
68 |             if result.stdout:
69 |                 try:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\perimeter_sweep.py:87:1
   |
85 |                      report["status"] = "error"
86 |                      report["details"].append("JSON decoding failed for pip-audit")
87 |             
   | ^^^^^^^^^^^^
88 |             if result.returncode != 0 and report["vulnerabilities"] == 0:
89 |                  # pip-audit returns non-zero if vulnerabilities are found, 
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\tools\perimeter_sweep.py:89:76
   |
88 |             if result.returncode != 0 and report["vulnerabilities"] == 0:
89 |                  # pip-audit returns non-zero if vulnerabilities are found, 
   |                                                                            ^
90 |                  # but could also return non-zero for actual execution errors.
91 |                  pass
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:99:1
    |
 97 |             report["status"] = "error"
 98 |             report["details"].append(str(e))
 99 |             
    | ^^^^^^^^^^^^
100 |         return report
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:106:1
    |
104 |         HUD.persona_log("INFO", "Executing npm audit for Node.js dependencies...")
105 |         report = {"status": "success", "vulnerabilities": 0, "details": []}
106 |         
    | ^^^^^^^^
107 |         if not (self.target_dir / "package.json").exists():
108 |             report["status"] = "skipped"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:111:1
    |
109 |             report["details"].append("No package.json found.")
110 |             return report
111 |             
    | ^^^^^^^^^^^^
112 |         try:
113 |             cmd = ["npm", "audit", "--json"]
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\perimeter_sweep.py:115:22
    |
113 |             cmd = ["npm", "audit", "--json"]
114 |             # Note: Windows requires shell=True for npm, or using npm.cmd
115 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, shell=(sys.platform == "win32"))
    |                      ^^^^^^^^^^^^^^
116 |             
117 |             if result.stdout:
    |

E501 Line too long (131 > 100)
   --> src\tools\perimeter_sweep.py:115:101
    |
113 |             cmd = ["npm", "audit", "--json"]
114 |             # Note: Windows requires shell=True for npm, or using npm.cmd
115 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, shell=(sys.platform == "win32"))
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
116 |             
117 |             if result.stdout:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:116:1
    |
114 |             # Note: Windows requires shell=True for npm, or using npm.cmd
115 |             result = subprocess.run(cmd, cwd=str(self.target_dir), capture_output=True, text=True, shell=(sys.platform == "win32"))
116 |             
    | ^^^^^^^^^^^^
117 |             if result.stdout:
118 |                 try:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:121:1
    |
119 |                     data = json.loads(result.stdout)
120 |                     metadata = data.get("metadata", {}).get("vulnerabilities", {})
121 |                     
    | ^^^^^^^^^^^^^^^^^^^^
122 |                     total = sum(metadata.values()) if isinstance(metadata, dict) else 0
123 |                     report["vulnerabilities"] = total
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:124:1
    |
122 |                     total = sum(metadata.values()) if isinstance(metadata, dict) else 0
123 |                     report["vulnerabilities"] = total
124 |                     
    | ^^^^^^^^^^^^^^^^^^^^
125 |                     if total > 0:
126 |                         report["status"] = "vulnerable"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:137:1
    |
135 |                      report["status"] = "error"
136 |                      report["details"].append("JSON decoding failed for npm audit")
137 |                      
    | ^^^^^^^^^^^^^^^^^^^^^
138 |         except FileNotFoundError:
139 |             report["status"] = "missing_tool"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:144:1
    |
142 |             report["status"] = "error"
143 |             report["details"].append(str(e))
144 |             
    | ^^^^^^^^^^^^
145 |         return report
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:151:1
    |
149 |         HUD.persona_log("INFO", "Sweeping the manor for temporary files...")
150 |         report = {"status": "success", "files_found": 0, "purged": False, "details": []}
151 |         
    | ^^^^^^^^
152 |         targets = []
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:153:1
    |
152 |         targets = []
153 |         
    | ^^^^^^^^
154 |         # 1. Backups
155 |         for ext in ["*.bak", "*.old", "*.tmp"]:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:157:1
    |
155 |         for ext in ["*.bak", "*.old", "*.tmp"]:
156 |              targets.extend(self.target_dir.rglob(ext))
157 |              
    | ^^^^^^^^^^^^^
158 |         # 2. Orphans
159 |         agent_dir = self.target_dir / ".agent"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:166:1
    |
164 |                 # Or just flag all pids for the user to see. Let's flag them.
165 |                 targets.append(pid_file)
166 |                 
    | ^^^^^^^^^^^^^^^^
167 |         report["files_found"] = len(targets)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:168:1
    |
167 |         report["files_found"] = len(targets)
168 |         
    | ^^^^^^^^
169 |         for t in targets:
170 |             report["details"].append(str(t.relative_to(project_root)))
    |
help: Remove whitespace from blank line

SIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`
   --> src\tools\perimeter_sweep.py:172:17
    |
170 |               report["details"].append(str(t.relative_to(project_root)))
171 |               if self.purge:
172 | /                 try:
173 | |                     t.unlink()
174 | |                 except OSError:
175 | |                     pass
    | |________________________^
176 |                       
177 |           if self.purge and targets:
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:176:1
    |
174 |                 except OSError:
175 |                     pass
176 |                     
    | ^^^^^^^^^^^^^^^^^^^^
177 |         if self.purge and targets:
178 |             report["purged"] = True
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:179:1
    |
177 |         if self.purge and targets:
178 |             report["purged"] = True
179 |             
    | ^^^^^^^^^^^^
180 |         return report
    |
help: Remove whitespace from blank line

E501 Line too long (114 > 100)
   --> src\tools\perimeter_sweep.py:186:101
    |
184 |         HUD.box_top("[A] THE PERIMETER SWEEP")
185 |         HUD.box_row("SCAN AREA", str(self.target_dir), HUD.CYAN)
186 |         HUD.box_row("PURGE MODE", "ACTIVE" if self.purge else "DISABLED", HUD.YELLOW if self.purge else HUD.GREEN)
    |                                                                                                     ^^^^^^^^^^^^^^
187 |         HUD.box_separator()
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:188:1
    |
186 |         HUD.box_row("PURGE MODE", "ACTIVE" if self.purge else "DISABLED", HUD.YELLOW if self.purge else HUD.GREEN)
187 |         HUD.box_separator()
188 |         
    | ^^^^^^^^
189 |         results = {
190 |             "pip_audit": self._run_pip_audit(),
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:194:1
    |
192 |             "cleanup": self._manor_cleanup()
193 |         }
194 |         
    | ^^^^^^^^
195 |         self._write_report(results)
196 |         self._render_report(results)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:213:1
    |
211 |         HUD.box_row("PERIMETER SECURITY STATUS", "FINDINGS", HUD.CYAN)
212 |         HUD.box_separator()
213 |         
    | ^^^^^^^^
214 |         # PIP Audit
215 |         pip = results["pip_audit"]
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\tools\perimeter_sweep.py:218:43
    |
216 |         p_color = HUD.GREEN if pip["vulnerabilities"] == 0 else HUD.RED
217 |         p_text = "SECURE" if pip["vulnerabilities"] == 0 else f"{pip['vulnerabilities']} CVEs"
218 |         if pip["status"] == "missing_tool": p_text = "MISSING TOOL"
    |                                           ^
219 |         HUD.box_row("Python Dependencies", p_text, p_color)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:220:1
    |
218 |         if pip["status"] == "missing_tool": p_text = "MISSING TOOL"
219 |         HUD.box_row("Python Dependencies", p_text, p_color)
220 |         
    | ^^^^^^^^
221 |         if pip["vulnerabilities"] > 0:
222 |              for d in pip["details"]:
    |
help: Remove whitespace from blank line

E501 Line too long (108 > 100)
   --> src\tools\perimeter_sweep.py:223:101
    |
221 |         if pip["vulnerabilities"] > 0:
222 |              for d in pip["details"]:
223 |                  HUD.box_row(f"  {d['package']}@{d['version']}", f"CVE: {d['id']}", HUD.RED, dim_label=True)
    |                                                                                                     ^^^^^^^^
224 |         
225 |         # NPM Audit
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:224:1
    |
222 |              for d in pip["details"]:
223 |                  HUD.box_row(f"  {d['package']}@{d['version']}", f"CVE: {d['id']}", HUD.RED, dim_label=True)
224 |         
    | ^^^^^^^^
225 |         # NPM Audit
226 |         npm = results["npm_audit"]
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\tools\perimeter_sweep.py:230:47
    |
228 |             n_color = HUD.GREEN if npm["vulnerabilities"] == 0 else HUD.RED
229 |             n_text = "SECURE" if npm["vulnerabilities"] == 0 else f"{npm['vulnerabilities']} CVEs"
230 |             if npm["status"] == "missing_tool": n_text = "MISSING TOOL"
    |                                               ^
231 |             HUD.box_row("Node.js Dependencies", n_text, n_color)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:232:1
    |
230 |             if npm["status"] == "missing_tool": n_text = "MISSING TOOL"
231 |             HUD.box_row("Node.js Dependencies", n_text, n_color)
232 |             
    | ^^^^^^^^^^^^
233 |             if npm["vulnerabilities"] > 0:
234 |                  for d in npm["details"][:3]: # Cap output
    |
help: Remove whitespace from blank line

E501 Line too long (122 > 100)
   --> src\tools\perimeter_sweep.py:236:101
    |
234 |                  for d in npm["details"][:3]: # Cap output
235 |                      via = d['via'][0] if d.get('via') and isinstance(d['via'], list) else 'Unknown'
236 |                      HUD.box_row(f"  {d['package']}", f"Sev: {d.get('severity', 'N/A')} ({via})", HUD.RED, dim_label=True)
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
237 |                  if len(npm["details"]) > 3:
238 |                      HUD.box_row("  ...", f"+ {len(npm['details']) - 3} more", dim_label=True)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:239:1
    |
237 |                  if len(npm["details"]) > 3:
238 |                      HUD.box_row("  ...", f"+ {len(npm['details']) - 3} more", dim_label=True)
239 |                      
    | ^^^^^^^^^^^^^^^^^^^^^
240 |         # Cleanup
241 |         cln = results["cleanup"]
    |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
   --> src\tools\perimeter_sweep.py:244:25
    |
242 |         c_color = HUD.GREEN if cln["files_found"] == 0 else HUD.YELLOW
243 |         c_text = "IMMACULATE" if cln["files_found"] == 0 else f"{cln['files_found']} orphans"
244 |         if cln["purged"]: c_text += " (PURGED)"
    |                         ^
245 |         HUD.box_row("Manor Hygiene", c_text, c_color)
    |

W291 [*] Trailing whitespace
   --> src\tools\perimeter_sweep.py:248:44
    |
247 |         HUD.box_separator()
248 |         if (pip["vulnerabilities"] == 0 and 
    |                                            ^
249 |             (npm["status"] == "skipped" or npm["vulnerabilities"] == 0) and 
250 |             cln["files_found"] == 0):
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\perimeter_sweep.py:249:76
    |
247 |         HUD.box_separator()
248 |         if (pip["vulnerabilities"] == 0 and 
249 |             (npm["status"] == "skipped" or npm["vulnerabilities"] == 0) and 
    |                                                                            ^
250 |             cln["files_found"] == 0):
251 |             HUD.box_row("STATUS", "The perimeter is secure, sir.", HUD.GREEN)
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\perimeter_sweep.py:254:1
    |
252 |         else:
253 |             HUD.box_row("STATUS", "Anomalies detected in the perimeter.", HUD.YELLOW)
254 |             
    | ^^^^^^^^^^^^
255 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\tools\perimeter_sweep.py:258:5
    |
258 | def main():
    |     ^^^^
259 |     parser = argparse.ArgumentParser(description="The Perimeter Sweep - Security & Hygiene")
260 |     parser.add_argument("target", nargs="?", default=".", help="Target directory to scan")
    |
help: Add return type annotation: `int | None`

E501 Line too long (106 > 100)
   --> src\tools\perimeter_sweep.py:261:101
    |
259 |     parser = argparse.ArgumentParser(description="The Perimeter Sweep - Security & Hygiene")
260 |     parser.add_argument("target", nargs="?", default=".", help="Target directory to scan")
261 |     parser.add_argument("--purge", action="store_true", help="Automatically delete found temporary files")
    |                                                                                                     ^^^^^^
262 |     args = parser.parse_args()
    |

E501 Line too long (116 > 100)
  --> src\tools\security_scan.py:10:101
   |
 8 | except ImportError:
 9 |     class HUD:
10 |         RED, GREEN, YELLOW, RESET, BOLD, CYAN = "\033[31m", "\033[32m", "\033[33m", "\033[0m", "\033[1m", "\033[36m"
   |                                                                                                     ^^^^^^^^^^^^^^^^
11 |         @staticmethod
12 |         def box_top(t): print(f"--- {t} ---")
   |

ANN205 Missing return type annotation for staticmethod `box_top`
  --> src\tools\security_scan.py:12:13
   |
10 |         RED, GREEN, YELLOW, RESET, BOLD, CYAN = "\033[31m", "\033[32m", "\033[33m", "\033[0m", "\033[1m", "\033[36m"
11 |         @staticmethod
12 |         def box_top(t): print(f"--- {t} ---")
   |             ^^^^^^^
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `t`
  --> src\tools\security_scan.py:12:21
   |
10 |         RED, GREEN, YELLOW, RESET, BOLD, CYAN = "\033[31m", "\033[32m", "\033[33m", "\033[0m", "\033[1m", "\033[36m"
11 |         @staticmethod
12 |         def box_top(t): print(f"--- {t} ---")
   |                     ^
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |

ANN205 Missing return type annotation for staticmethod `box_row`
  --> src\tools\security_scan.py:14:13
   |
12 |         def box_top(t): print(f"--- {t} ---")
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |             ^^^^^^^
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |
help: Add return type annotation: `None`

E741 Ambiguous variable name: `l`
  --> src\tools\security_scan.py:14:21
   |
12 |         def box_top(t): print(f"--- {t} ---")
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |                     ^
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `l`
  --> src\tools\security_scan.py:14:21
   |
12 |         def box_top(t): print(f"--- {t} ---")
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |                     ^
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `v`
  --> src\tools\security_scan.py:14:24
   |
12 |         def box_top(t): print(f"--- {t} ---")
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |                        ^
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |

ANN001 Missing type annotation for function argument `c`
  --> src\tools\security_scan.py:14:27
   |
12 |         def box_top(t): print(f"--- {t} ---")
13 |         @staticmethod
14 |         def box_row(l, v, c): print(f"{l}: {v}")
   |                           ^
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |

ANN205 Missing return type annotation for staticmethod `box_bottom`
  --> src\tools\security_scan.py:16:13
   |
14 |         def box_row(l, v, c): print(f"{l}: {v}")
15 |         @staticmethod
16 |         def box_bottom(): print("------")
   |             ^^^^^^^^^^
17 |
18 | class SecurityScanner:
   |
help: Add return type annotation: `None`

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> src\tools\security_scan.py:19:20
   |
18 |   class SecurityScanner:
19 |       RISK_VECTORS = {
   |  ____________________^
20 | |         "PROMPT_INJECTION": [(r"\bignore previous instructions\b", 10), (r"\bsystem override\b", 10)],
21 | |         "DANGEROUS_CODE": [(r"\bos\.system\(", 10), (r"\bsubprocess\.call\(", 8), (r"\bshutil\.rmtree\(", 10), (r"\beval\(", 10), (r"\â€¦
22 | |     }
   | |_____^
23 |       MAX_FILE_SIZE_MB = 10
   |

E501 Line too long (102 > 100)
  --> src\tools\security_scan.py:20:101
   |
18 | class SecurityScanner:
19 |     RISK_VECTORS = {
20 |         "PROMPT_INJECTION": [(r"\bignore previous instructions\b", 10), (r"\bsystem override\b", 10)],
   |                                                                                                     ^^
21 |         "DANGEROUS_CODE": [(r"\bos\.system\(", 10), (r"\bsubprocess\.call\(", 8), (r"\bshutil\.rmtree\(", 10), (r"\beval\(", 10), (r"\â€¦
22 |     }
   |

E501 Line too long (148 > 100)
  --> src\tools\security_scan.py:21:101
   |
19 | â€¦
20 | â€¦ions\b", 10), (r"\bsystem override\b", 10)],
21 | â€¦ubprocess\.call\(", 8), (r"\bshutil\.rmtree\(", 10), (r"\beval\(", 10), (r"\bexec\(", 10)]
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 | â€¦
23 | â€¦
   |

ANN001 Missing type annotation for function argument `file_path`
  --> src\tools\security_scan.py:25:24
   |
23 |     MAX_FILE_SIZE_MB = 10
24 |
25 |     def __init__(self, file_path) -> None:
   |                        ^^^^^^^^^
26 |         self.path, self.content, self.threat_score, self.findings = file_path, "", 0, []
   |

ANN201 Missing return type annotation for public function `scan`
  --> src\tools\security_scan.py:28:9
   |
26 |         self.path, self.content, self.threat_score, self.findings = file_path, "", 0, []
27 |
28 |     def scan(self):
   |         ^^^^
29 |         """[ALFRED] Secure multi-layer scan with DoS and AST heuristics."""
30 |         if not os.path.exists(self.path): return False, ["File not found"]
   |
help: Add return type annotation

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\security_scan.py:30:16
   |
28 |     def scan(self):
29 |         """[ALFRED] Secure multi-layer scan with DoS and AST heuristics."""
30 |         if not os.path.exists(self.path): return False, ["File not found"]
   |                ^^^^^^^^^^^^^^
31 |         try:
32 |             if os.path.getsize(self.path) / 10**6 > self.MAX_FILE_SIZE_MB:
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:30:41
   |
28 |     def scan(self):
29 |         """[ALFRED] Secure multi-layer scan with DoS and AST heuristics."""
30 |         if not os.path.exists(self.path): return False, ["File not found"]
   |                                         ^
31 |         try:
32 |             if os.path.getsize(self.path) / 10**6 > self.MAX_FILE_SIZE_MB:
   |

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\tools\security_scan.py:32:16
   |
30 |         if not os.path.exists(self.path): return False, ["File not found"]
31 |         try:
32 |             if os.path.getsize(self.path) / 10**6 > self.MAX_FILE_SIZE_MB:
   |                ^^^^^^^^^^^^^^^
33 |                 self.threat_score = 20
34 |                 self.findings.append("[DoS] File too large")
   |
help: Replace with `Path(...).stat().st_size`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\security_scan.py:36:18
   |
34 |                 self.findings.append("[DoS] File too large")
35 |                 return False, self.findings
36 |             with open(self.path, 'r', encoding='utf-8') as f: self.content = f.read()
   |                  ^^^^
37 |         except (IOError, OSError, PermissionError): return False, ["Read error"]
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\security_scan.py:36:34
   |
34 |                 self.findings.append("[DoS] File too large")
35 |                 return False, self.findings
36 |             with open(self.path, 'r', encoding='utf-8') as f: self.content = f.read()
   |                                  ^^^
37 |         except (IOError, OSError, PermissionError): return False, ["Read error"]
   |
help: Remove mode argument

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:36:61
   |
34 |                 self.findings.append("[DoS] File too large")
35 |                 return False, self.findings
36 |             with open(self.path, 'r', encoding='utf-8') as f: self.content = f.read()
   |                                                             ^
37 |         except (IOError, OSError, PermissionError): return False, ["Read error"]
   |

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\security_scan.py:37:16
   |
35 |                 return False, self.findings
36 |             with open(self.path, 'r', encoding='utf-8') as f: self.content = f.read()
37 |         except (IOError, OSError, PermissionError): return False, ["Read error"]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |
39 |         self._regex_scan()
   |
help: Replace with builtin `OSError`

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:37:51
   |
35 |                 return False, self.findings
36 |             with open(self.path, 'r', encoding='utf-8') as f: self.content = f.read()
37 |         except (IOError, OSError, PermissionError): return False, ["Read error"]
   |                                                   ^
38 |
39 |         self._regex_scan()
   |

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:40:37
   |
39 |         self._regex_scan()
40 |         if self.path.endswith(".py"): self._analyze_ast()
   |                                     ^
41 |         elif self.path.endswith((".js", ".ts")): self._analyze_web_script()
42 |         return self.threat_score < 5, self.findings
   |

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:41:48
   |
39 |         self._regex_scan()
40 |         if self.path.endswith(".py"): self._analyze_ast()
41 |         elif self.path.endswith((".js", ".ts")): self._analyze_web_script()
   |                                                ^
42 |         return self.threat_score < 5, self.findings
   |

ANN202 Missing return type annotation for private function `_analyze_web_script`
  --> src\tools\security_scan.py:44:9
   |
42 |         return self.threat_score < 5, self.findings
43 |
44 |     def _analyze_web_script(self):
   |         ^^^^^^^^^^^^^^^^^^^
45 |         """[ALFRED] Detect front-end specific risk vectors."""
46 |         patterns = [
   |
help: Add return type annotation: `None`

ANN202 Missing return type annotation for private function `_regex_scan`
  --> src\tools\security_scan.py:58:9
   |
56 |                 self.findings.append(f"[{cat}] Detected '{pat}'")
57 |
58 |     def _regex_scan(self):
   |         ^^^^^^^^^^^
59 |         is_internal = "scripts" in self.path and ".agent" in self.path
60 |         for cat, patterns in self.RISK_VECTORS.items():
   |
help: Add return type annotation: `None`

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:63:79
   |
61 |             for pat, weight in patterns:
62 |                 if re.search(pat, self.content, re.IGNORECASE):
63 |                     if is_internal and ("rmtree" in pat or "os.system" in pat): continue
   |                                                                               ^
64 |                     self.threat_score += weight
65 |                     self.findings.append(f"[{cat}] Detected '{pat}'")
   |

ANN202 Missing return type annotation for private function `_analyze_ast`
  --> src\tools\security_scan.py:67:9
   |
65 |                     self.findings.append(f"[{cat}] Detected '{pat}'")
66 |
67 |     def _analyze_ast(self):
   |         ^^^^^^^^^^^^
68 |         try:
69 |             tree = ast.parse(self.content)
   |
help: Add return type annotation: `None`

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:71:66
   |
69 |             tree = ast.parse(self.content)
70 |             for node in ast.walk(tree):
71 |                 if isinstance(node, (ast.Import, ast.ImportFrom)): self._scan_imports(node)
   |                                                                  ^
72 |                 elif isinstance(node, ast.Constant): self._scan_constants(node)
73 |         except SyntaxError as e:
   |

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:72:52
   |
70 |             for node in ast.walk(tree):
71 |                 if isinstance(node, (ast.Import, ast.ImportFrom)): self._scan_imports(node)
72 |                 elif isinstance(node, ast.Constant): self._scan_constants(node)
   |                                                    ^
73 |         except SyntaxError as e:
74 |             self.threat_score += 15
   |

RUF010 [*] Use explicit conversion flag
  --> src\tools\security_scan.py:75:57
   |
73 |         except SyntaxError as e:
74 |             self.threat_score += 15
75 |             self.findings.append(f"[MALFORMED] Syntax: {str(e)}")
   |                                                         ^^^^^^
76 |         except (SyntaxError, ValueError): pass
   |
help: Replace with conversion flag

B025 try-except block with duplicate exception `SyntaxError`
  --> src\tools\security_scan.py:76:17
   |
74 |             self.threat_score += 15
75 |             self.findings.append(f"[MALFORMED] Syntax: {str(e)}")
76 |         except (SyntaxError, ValueError): pass
   |                 ^^^^^^^^^^^
77 |
78 |     def _scan_imports(self, node):
   |

E701 Multiple statements on one line (colon)
  --> src\tools\security_scan.py:76:41
   |
74 |             self.threat_score += 15
75 |             self.findings.append(f"[MALFORMED] Syntax: {str(e)}")
76 |         except (SyntaxError, ValueError): pass
   |                                         ^
77 |
78 |     def _scan_imports(self, node):
   |

ANN202 Missing return type annotation for private function `_scan_imports`
  --> src\tools\security_scan.py:78:9
   |
76 |         except (SyntaxError, ValueError): pass
77 |
78 |     def _scan_imports(self, node):
   |         ^^^^^^^^^^^^^
79 |         net, dang = {"requests", "urllib", "socket", "http"}, {"ctypes", "pickle", "base64"}
80 |         names = [n.name for n in node.names] if isinstance(node, ast.Import) else [node.module]
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `node`
  --> src\tools\security_scan.py:78:29
   |
76 |         except (SyntaxError, ValueError): pass
77 |
78 |     def _scan_imports(self, node):
   |                             ^^^^
79 |         net, dang = {"requests", "urllib", "socket", "http"}, {"ctypes", "pickle", "base64"}
80 |         names = [n.name for n in node.names] if isinstance(node, ast.Import) else [node.module]
   |

ANN202 Missing return type annotation for private function `_scan_constants`
  --> src\tools\security_scan.py:89:9
   |
87 |                 self.findings.append(f"[DANGEROUS] '{name}' import")
88 |
89 |     def _scan_constants(self, node):
   |         ^^^^^^^^^^^^^^^
90 |         if isinstance(node.value, str):
91 |             if len(node.value) > 200 and re.match(r'^[a-zA-Z0-9+/=]+$', node.value):
   |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `node`
  --> src\tools\security_scan.py:89:31
   |
87 |                 self.findings.append(f"[DANGEROUS] '{name}' import")
88 |
89 |     def _scan_constants(self, node):
   |                               ^^^^
90 |         if isinstance(node.value, str):
91 |             if len(node.value) > 200 and re.match(r'^[a-zA-Z0-9+/=]+$', node.value):
   |

ANN201 Missing return type annotation for public function `report`
   --> src\tools\security_scan.py:98:9
    |
 96 |                 self.findings.append("[OBFUSCATION] High hex density")
 97 |
 98 |     def report(self):
    |         ^^^^^^
 99 |         HUD.box_top("ðŸ›¡ï¸  HEIMDALL SECURITY SCAN  ðŸ›¡ï¸")
100 |         HUD.box_row("TARGET", os.path.basename(self.path), HUD.CYAN)
    |
help: Add return type annotation

PTH119 `os.path.basename()` should be replaced by `Path.name`
   --> src\tools\security_scan.py:100:31
    |
 98 |     def report(self):
 99 |         HUD.box_top("ðŸ›¡ï¸  HEIMDALL SECURITY SCAN  ðŸ›¡ï¸")
100 |         HUD.box_row("TARGET", os.path.basename(self.path), HUD.CYAN)
    |                               ^^^^^^^^^^^^^^^^
101 |         c = HUD.RED if self.threat_score >= 10 else (HUD.YELLOW if self.threat_score > 0 else HUD.GREEN)
102 |         HUD.box_row("THREAT LEVEL", f"{self.threat_score}/10", c)
    |
help: Replace with `Path(...).name`

E501 Line too long (104 > 100)
   --> src\tools\security_scan.py:101:101
    |
 99 |         HUD.box_top("ðŸ›¡ï¸  HEIMDALL SECURITY SCAN  ðŸ›¡ï¸")
100 |         HUD.box_row("TARGET", os.path.basename(self.path), HUD.CYAN)
101 |         c = HUD.RED if self.threat_score >= 10 else (HUD.YELLOW if self.threat_score > 0 else HUD.GREEN)
    |                                                                                                     ^^^^
102 |         HUD.box_row("THREAT LEVEL", f"{self.threat_score}/10", c)
103 |         for f in self.findings: print(f"   - {HUD.RED}{f}{HUD.RESET}")
    |

E701 Multiple statements on one line (colon)
   --> src\tools\security_scan.py:103:31
    |
101 |         c = HUD.RED if self.threat_score >= 10 else (HUD.YELLOW if self.threat_score > 0 else HUD.GREEN)
102 |         HUD.box_row("THREAT LEVEL", f"{self.threat_score}/10", c)
103 |         for f in self.findings: print(f"   - {HUD.RED}{f}{HUD.RESET}")
    |                               ^
104 |         HUD.box_bottom()
105 |         return self.threat_score
    |

E701 Multiple statements on one line (colon)
   --> src\tools\security_scan.py:108:25
    |
107 | if __name__ == "__main__":
108 |     if len(sys.argv) < 2: sys.exit(1)
    |                         ^
109 |     s = SecurityScanner(sys.argv[1])
110 |     s.scan(); s.report()
    |

E702 Multiple statements on one line (semicolon)
   --> src\tools\security_scan.py:110:13
    |
108 |     if len(sys.argv) < 2: sys.exit(1)
109 |     s = SecurityScanner(sys.argv[1])
110 |     s.scan(); s.report()
    |             ^
111 |     sys.exit(2 if s.threat_score >= 10 else (1 if s.threat_score > 0 else 0))
    |

W292 [*] No newline at end of file
   --> src\tools\security_scan.py:111:78
    |
109 |     s = SecurityScanner(sys.argv[1])
110 |     s.scan(); s.report()
111 |     sys.exit(2 if s.threat_score >= 10 else (1 if s.threat_score > 0 else 0))
    |                                                                              ^
    |
help: Add trailing newline

F401 [*] `json` imported but unused
  --> src\tools\sentinel_perf.py:9:8
   |
 7 | """
 8 |
 9 | import json
   |        ^^^^
10 | import os
11 | import sys
   |
help: Remove unused import: `json`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:15:13
   |
14 | # Resolve shared UI and engine from src/core/
15 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |             ^^^^^^^^^^^^
16 | sys.path.insert(0, _core_dir)
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\sentinel_perf.py:15:26
   |
14 | # Resolve shared UI and engine from src/core/
15 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                          ^^^^^^^^^^^^^^^
16 | sys.path.insert(0, _core_dir)
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\sentinel_perf.py:15:42
   |
14 | # Resolve shared UI and engine from src/core/
15 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                          ^^^^^^^^^^^^^^^
16 | sys.path.insert(0, _core_dir)
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\sentinel_perf.py:15:58
   |
14 | # Resolve shared UI and engine from src/core/
15 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
   |                                                          ^^^^^^^^^^^^^^^
16 | sys.path.insert(0, _core_dir)
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:17:20
   |
15 | _core_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "core")
16 | sys.path.insert(0, _core_dir)
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
   |                    ^^^^^^^^^^^^
18 |
19 | from ui import HUD
   |

E402 Module level import not at top of file
  --> src\tools\sentinel_perf.py:19:1
   |
17 | sys.path.insert(0, os.path.join(_core_dir, "engine"))
18 |
19 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
20 |
21 | try:
   |

SIM105 Use `contextlib.suppress(ImportError)` instead of `try`-`except`-`pass`
  --> src\tools\sentinel_perf.py:21:1
   |
19 |   from ui import HUD
20 |
21 | / try:
22 | |     from vector import SovereignVector
23 | | except ImportError:
24 | |     pass
   | |________^
25 |
26 |   class SentinelPerf:
   |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(ImportError): ...`

W293 [*] Blank line contains whitespace
  --> src\tools\sentinel_perf.py:31:1
   |
29 |     Identifies bottlenecks in tokenization, search, and vector synthesis.
30 |     """
31 |     
   | ^^^^
32 |     def __init__(self, project_root: str) -> None:
33 |         self.root = project_root
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:34:21
   |
32 |     def __init__(self, project_root: str) -> None:
33 |         self.root = project_root
34 |         self.base = os.path.join(project_root, ".agent")
   |                     ^^^^^^^^^^^^
35 |         def _res(fname):
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
   |

ANN202 Missing return type annotation for private function `_res`
  --> src\tools\sentinel_perf.py:35:13
   |
33 |         self.root = project_root
34 |         self.base = os.path.join(project_root, ".agent")
35 |         def _res(fname):
   |             ^^^^
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
37 |             md = os.path.join(project_root, fname)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `fname`
  --> src\tools\sentinel_perf.py:35:18
   |
33 |         self.root = project_root
34 |         self.base = os.path.join(project_root, ".agent")
35 |         def _res(fname):
   |                  ^^^^^
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
37 |             md = os.path.join(project_root, fname)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:36:19
   |
34 |         self.base = os.path.join(project_root, ".agent")
35 |         def _res(fname):
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
   |                   ^^^^^^^^^^^^
37 |             md = os.path.join(project_root, fname)
38 |             return qmd if os.path.exists(qmd) else md
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:37:18
   |
35 |         def _res(fname):
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
37 |             md = os.path.join(project_root, fname)
   |                  ^^^^^^^^^^^^
38 |             return qmd if os.path.exists(qmd) else md
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\sentinel_perf.py:38:27
   |
36 |             qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
37 |             md = os.path.join(project_root, fname)
38 |             return qmd if os.path.exists(qmd) else md
   |                           ^^^^^^^^^^^^^^
39 |
40 |         self.engine = SovereignVector(
   |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:42:30
   |
40 |         self.engine = SovereignVector(
41 |             thesaurus_path=_res("thesaurus.md"),
42 |             corrections_path=os.path.join(self.base, "corrections.json"),
   |                              ^^^^^^^^^^^^
43 |             stopwords_path=os.path.join(self.base, "scripts", "stopwords.json")
44 |         )
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\sentinel_perf.py:43:28
   |
41 |             thesaurus_path=_res("thesaurus.md"),
42 |             corrections_path=os.path.join(self.base, "corrections.json"),
43 |             stopwords_path=os.path.join(self.base, "scripts", "stopwords.json")
   |                            ^^^^^^^^^^^^
44 |         )
45 |         self.engine.load_core_skills()
   |

ANN201 Missing return type annotation for public function `run_suite`
  --> src\tools\sentinel_perf.py:64:9
   |
62 |         return (end - start) / iterations * 1000
63 |
64 |     def run_suite(self):
   |         ^^^^^^^^^
65 |         HUD.box_top("SENTINEL PERF: BENCHMARK")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\sentinel_perf.py:66:1
   |
64 |     def run_suite(self):
65 |         HUD.box_top("SENTINEL PERF: BENCHMARK")
66 |         
   | ^^^^^^^^
67 |         # Test 1: Search Latency (High Level)
68 |         q = "check the login bug in the system"
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\sentinel_perf.py:71:1
   |
69 |         lat = self.profile_search(q)
70 |         HUD.box_row("SEARCH", f"{lat:.3f}ms", HUD.GREEN if lat < 1.0 else HUD.YELLOW)
71 |         
   | ^^^^^^^^
72 |         # Test 2: Tokenization (Low Level)
73 |         t = "The quick brown fox jumps over the lazy dog" * 10
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\sentinel_perf.py:76:1
   |
74 |         t_lat = self.profile_tokenization(t)
75 |         HUD.box_row("TOKENIZE", f"{t_lat:.4f}ms", HUD.GREEN if t_lat < 0.1 else HUD.YELLOW)
76 |         
   | ^^^^^^^^
77 |         # Test 3: Synthesis overhead
78 |         HUD.box_row("VIRTUAL", f"Rank A Performance", HUD.CYAN)
   |
help: Remove whitespace from blank line

F541 [*] f-string without any placeholders
  --> src\tools\sentinel_perf.py:78:32
   |
77 |         # Test 3: Synthesis overhead
78 |         HUD.box_row("VIRTUAL", f"Rank A Performance", HUD.CYAN)
   |                                ^^^^^^^^^^^^^^^^^^^^^
79 |         HUD.box_bottom()
   |
help: Remove extraneous `f` prefix

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\sentinel_perf.py:82:18
   |
81 | if __name__ == "__main__":
82 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                  ^^^^^^^^^^^^^^^
83 |     root = os.path.dirname(os.path.dirname(script_dir))
84 |     SentinelPerf(root).run_suite()
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\sentinel_perf.py:82:34
   |
81 | if __name__ == "__main__":
82 |     script_dir = os.path.dirname(os.path.abspath(__file__))
   |                                  ^^^^^^^^^^^^^^^
83 |     root = os.path.dirname(os.path.dirname(script_dir))
84 |     SentinelPerf(root).run_suite()
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\sentinel_perf.py:83:12
   |
81 | if __name__ == "__main__":
82 |     script_dir = os.path.dirname(os.path.abspath(__file__))
83 |     root = os.path.dirname(os.path.dirname(script_dir))
   |            ^^^^^^^^^^^^^^^
84 |     SentinelPerf(root).run_suite()
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\sentinel_perf.py:83:28
   |
81 | if __name__ == "__main__":
82 |     script_dir = os.path.dirname(os.path.abspath(__file__))
83 |     root = os.path.dirname(os.path.dirname(script_dir))
   |                            ^^^^^^^^^^^^^^^
84 |     SentinelPerf(root).run_suite()
   |
help: Replace with `Path(...).parent`

W292 [*] No newline at end of file
  --> src\tools\sentinel_perf.py:84:35
   |
82 |     script_dir = os.path.dirname(os.path.abspath(__file__))
83 |     root = os.path.dirname(os.path.dirname(script_dir))
84 |     SentinelPerf(root).run_suite()
   |                                   ^
   |
help: Add trailing newline

F401 [*] `re` imported but unused
 --> src\tools\trace_viz.py:6:8
  |
4 | import math
5 | import os
6 | import re
  |        ^^
7 | import sys
8 | from collections import defaultdict
  |
help: Remove unused import: `re`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\trace_viz.py:11:15
   |
10 | # Add core directories to path for shared imports
11 | current_dir = os.path.dirname(os.path.abspath(__file__))
   |               ^^^^^^^^^^^^^^^
12 | _core_dir = os.path.join(os.path.dirname(current_dir), "core")
13 | _engine_dir = os.path.join(_core_dir, "engine")
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\trace_viz.py:11:31
   |
10 | # Add core directories to path for shared imports
11 | current_dir = os.path.dirname(os.path.abspath(__file__))
   |                               ^^^^^^^^^^^^^^^
12 | _core_dir = os.path.join(os.path.dirname(current_dir), "core")
13 | _engine_dir = os.path.join(_core_dir, "engine")
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:12:13
   |
10 | # Add core directories to path for shared imports
11 | current_dir = os.path.dirname(os.path.abspath(__file__))
12 | _core_dir = os.path.join(os.path.dirname(current_dir), "core")
   |             ^^^^^^^^^^^^
13 | _engine_dir = os.path.join(_core_dir, "engine")
14 | sys.path.insert(0, _core_dir)
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\trace_viz.py:12:26
   |
10 | # Add core directories to path for shared imports
11 | current_dir = os.path.dirname(os.path.abspath(__file__))
12 | _core_dir = os.path.join(os.path.dirname(current_dir), "core")
   |                          ^^^^^^^^^^^^^^^
13 | _engine_dir = os.path.join(_core_dir, "engine")
14 | sys.path.insert(0, _core_dir)
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:13:15
   |
11 | current_dir = os.path.dirname(os.path.abspath(__file__))
12 | _core_dir = os.path.join(os.path.dirname(current_dir), "core")
13 | _engine_dir = os.path.join(_core_dir, "engine")
   |               ^^^^^^^^^^^^
14 | sys.path.insert(0, _core_dir)
15 | sys.path.insert(0, _engine_dir)
   |

E402 Module level import not at top of file
  --> src\tools\trace_viz.py:17:1
   |
15 | sys.path.insert(0, _engine_dir)
16 |
17 | from vector import SovereignVector
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 | from ui import HUD
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\trace_viz.py:17:1
   |
15 |   sys.path.insert(0, _engine_dir)
16 |
17 | / from vector import SovereignVector
18 | | from ui import HUD
   | |__________________^
19 |
20 |   # --- CONFIGURATION (SYMMETRY MANDATE) ---
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\tools\trace_viz.py:18:1
   |
17 | from vector import SovereignVector
18 | from ui import HUD
   | ^^^^^^^^^^^^^^^^^^
19 |
20 | # --- CONFIGURATION (SYMMETRY MANDATE) ---
   |

ANN201 Missing return type annotation for public function `load_json`
  --> src\tools\trace_viz.py:25:5
   |
23 | # --- UTILITIES ---
24 |
25 | def load_json(path, max_size_mb: int = 10):
   |     ^^^^^^^^^
26 |     """[ALFRED] Secure JSON loader with size-gating for trace artifacts."""
27 |     if not os.path.exists(path): return {}
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `path`
  --> src\tools\trace_viz.py:25:15
   |
23 | # --- UTILITIES ---
24 |
25 | def load_json(path, max_size_mb: int = 10):
   |               ^^^^
26 |     """[ALFRED] Secure JSON loader with size-gating for trace artifacts."""
27 |     if not os.path.exists(path): return {}
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\trace_viz.py:27:12
   |
25 | def load_json(path, max_size_mb: int = 10):
26 |     """[ALFRED] Secure JSON loader with size-gating for trace artifacts."""
27 |     if not os.path.exists(path): return {}
   |            ^^^^^^^^^^^^^^
28 |     try:
29 |         # [ALFRED] DoS Protection: Prevent loading massive artifacts
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\trace_viz.py:27:32
   |
25 | def load_json(path, max_size_mb: int = 10):
26 |     """[ALFRED] Secure JSON loader with size-gating for trace artifacts."""
27 |     if not os.path.exists(path): return {}
   |                                ^
28 |     try:
29 |         # [ALFRED] DoS Protection: Prevent loading massive artifacts
   |

PTH202 `os.path.getsize` should be replaced by `Path.stat().st_size`
  --> src\tools\trace_viz.py:30:21
   |
28 |     try:
29 |         # [ALFRED] DoS Protection: Prevent loading massive artifacts
30 |         file_size = os.path.getsize(path)
   |                     ^^^^^^^^^^^^^^^
31 |         if file_size > max_size_mb * 1024 * 1024:
32 |             HUD.log("WARN", "Trace Integrity", f"Artifact too large: {os.path.basename(path)}")
   |
help: Replace with `Path(...).stat().st_size`

PTH119 `os.path.basename()` should be replaced by `Path.name`
  --> src\tools\trace_viz.py:32:71
   |
30 |         file_size = os.path.getsize(path)
31 |         if file_size > max_size_mb * 1024 * 1024:
32 |             HUD.log("WARN", "Trace Integrity", f"Artifact too large: {os.path.basename(path)}")
   |                                                                       ^^^^^^^^^^^^^^^^
33 |             return {}
   |
help: Replace with `Path(...).name`

W293 [*] Blank line contains whitespace
  --> src\tools\trace_viz.py:34:1
   |
32 |             HUD.log("WARN", "Trace Integrity", f"Artifact too large: {os.path.basename(path)}")
33 |             return {}
34 |             
   | ^^^^^^^^^^^^
35 |         with open(path, 'r', encoding='utf-8') as f: 
36 |             return json.load(f)
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\trace_viz.py:35:14
   |
33 |             return {}
34 |             
35 |         with open(path, 'r', encoding='utf-8') as f: 
   |              ^^^^
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\trace_viz.py:35:25
   |
33 |             return {}
34 |             
35 |         with open(path, 'r', encoding='utf-8') as f: 
   |                         ^^^
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
   |
help: Remove mode argument

W291 [*] Trailing whitespace
  --> src\tools\trace_viz.py:35:53
   |
33 |             return {}
34 |             
35 |         with open(path, 'r', encoding='utf-8') as f: 
   |                                                     ^
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
   |
help: Remove trailing whitespace

UP024 [*] Replace aliased errors with `OSError`
  --> src\tools\trace_viz.py:37:12
   |
35 |         with open(path, 'r', encoding='utf-8') as f: 
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         HUD.log("FAIL", "Replay Error", f"{os.path.basename(path)} ({str(e)})")
39 |         return {}
   |
help: Replace with builtin `OSError`

PTH119 `os.path.basename()` should be replaced by `Path.name`
  --> src\tools\trace_viz.py:38:44
   |
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
38 |         HUD.log("FAIL", "Replay Error", f"{os.path.basename(path)} ({str(e)})")
   |                                            ^^^^^^^^^^^^^^^^
39 |         return {}
   |
help: Replace with `Path(...).name`

RUF010 [*] Use explicit conversion flag
  --> src\tools\trace_viz.py:38:70
   |
36 |             return json.load(f)
37 |     except (json.JSONDecodeError, IOError, PermissionError) as e:
38 |         HUD.log("FAIL", "Replay Error", f"{os.path.basename(path)} ({str(e)})")
   |                                                                      ^^^^^^
39 |         return {}
   |
help: Replace with conversion flag

ANN201 Missing return type annotation for public function `get_engine`
  --> src\tools\trace_viz.py:41:5
   |
39 |         return {}
40 |
41 | def get_engine():
   |     ^^^^^^^^^^
42 |     # Setup Paths
43 |     base_path = os.path.dirname(current_dir) # .agent
   |
help: Add return type annotation

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\trace_viz.py:43:17
   |
41 | def get_engine():
42 |     # Setup Paths
43 |     base_path = os.path.dirname(current_dir) # .agent
   |                 ^^^^^^^^^^^^^^^
44 |     project_root = os.path.dirname(base_path) # Project Root
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\trace_viz.py:44:20
   |
42 |     # Setup Paths
43 |     base_path = os.path.dirname(current_dir) # .agent
44 |     project_root = os.path.dirname(base_path) # Project Root
   |                    ^^^^^^^^^^^^^^^
45 |     
46 |     # Load Config for Framework Root
   |
help: Replace with `Path(...).parent`

W293 [*] Blank line contains whitespace
  --> src\tools\trace_viz.py:45:1
   |
43 |     base_path = os.path.dirname(current_dir) # .agent
44 |     project_root = os.path.dirname(base_path) # Project Root
45 |     
   | ^^^^
46 |     # Load Config for Framework Root
47 |     config = load_json(os.path.join(base_path, "config.json"))
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:47:24
   |
46 |     # Load Config for Framework Root
47 |     config = load_json(os.path.join(base_path, "config.json"))
   |                        ^^^^^^^^^^^^
48 |
49 |     # [ALFRED] Staged Symbiosis: Support .qmd or .md
   |

ANN202 Missing return type annotation for private function `_res`
  --> src\tools\trace_viz.py:50:9
   |
49 |     # [ALFRED] Staged Symbiosis: Support .qmd or .md
50 |     def _res(fname):
   |         ^^^^
51 |         qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
52 |         md = os.path.join(project_root, fname)
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `fname`
  --> src\tools\trace_viz.py:50:14
   |
49 |     # [ALFRED] Staged Symbiosis: Support .qmd or .md
50 |     def _res(fname):
   |              ^^^^^
51 |         qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
52 |         md = os.path.join(project_root, fname)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:51:15
   |
49 |     # [ALFRED] Staged Symbiosis: Support .qmd or .md
50 |     def _res(fname):
51 |         qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
   |               ^^^^^^^^^^^^
52 |         md = os.path.join(project_root, fname)
53 |         return qmd if os.path.exists(qmd) else md
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:52:14
   |
50 |     def _res(fname):
51 |         qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
52 |         md = os.path.join(project_root, fname)
   |              ^^^^^^^^^^^^
53 |         return qmd if os.path.exists(qmd) else md
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\trace_viz.py:53:23
   |
51 |         qmd = os.path.join(project_root, fname.replace('.md', '.qmd'))
52 |         md = os.path.join(project_root, fname)
53 |         return qmd if os.path.exists(qmd) else md
   |                       ^^^^^^^^^^^^^^
54 |
55 |     engine = SovereignVector(
   |
help: Replace with `Path(...).exists()`

W291 [*] Trailing whitespace
  --> src\tools\trace_viz.py:56:46
   |
55 |     engine = SovereignVector(
56 |         thesaurus_path=_res("thesaurus.qmd"), 
   |                                              ^
57 |         corrections_path=os.path.join(base_path, "corrections.json"),
58 |         stopwords_path=os.path.join(base_path, "scripts", "stopwords.json")
   |
help: Remove trailing whitespace

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:57:26
   |
55 |     engine = SovereignVector(
56 |         thesaurus_path=_res("thesaurus.qmd"), 
57 |         corrections_path=os.path.join(base_path, "corrections.json"),
   |                          ^^^^^^^^^^^^
58 |         stopwords_path=os.path.join(base_path, "scripts", "stopwords.json")
59 |     )
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:58:24
   |
56 |         thesaurus_path=_res("thesaurus.qmd"), 
57 |         corrections_path=os.path.join(base_path, "corrections.json"),
58 |         stopwords_path=os.path.join(base_path, "scripts", "stopwords.json")
   |                        ^^^^^^^^^^^^
59 |     )
   |

W293 [*] Blank line contains whitespace
  --> src\tools\trace_viz.py:66:1
   |
64 |     else:
65 |         engine.add_skill("/lets-go", "start resume begin")
66 |     
   | ^^^^
67 |     engine.load_skills_from_dir(os.path.join(base_path, "skills"))
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:67:33
   |
65 |         engine.add_skill("/lets-go", "start resume begin")
66 |     
67 |     engine.load_skills_from_dir(os.path.join(base_path, "skills"))
   |                                 ^^^^^^^^^^^^
68 |     
69 |     # Global Skills
   |

W293 [*] Blank line contains whitespace
  --> src\tools\trace_viz.py:68:1
   |
67 |     engine.load_skills_from_dir(os.path.join(base_path, "skills"))
68 |     
   | ^^^^
69 |     # Global Skills
70 |     framework_root = config.get("FrameworkRoot")
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\trace_viz.py:72:23
   |
70 |     framework_root = config.get("FrameworkRoot")
71 |     if framework_root:
72 |         global_path = os.path.join(framework_root, "skills_db")
   |                       ^^^^^^^^^^^^
73 |         if os.path.exists(global_path):
74 |             engine.load_skills_from_dir(global_path, prefix="GLOBAL:")
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\trace_viz.py:73:12
   |
71 |     if framework_root:
72 |         global_path = os.path.join(framework_root, "skills_db")
73 |         if os.path.exists(global_path):
   |            ^^^^^^^^^^^^^^
74 |             engine.load_skills_from_dir(global_path, prefix="GLOBAL:")
   |
help: Replace with `Path(...).exists()`

W293 [*] Blank line contains whitespace
  --> src\tools\trace_viz.py:75:1
   |
73 |         if os.path.exists(global_path):
74 |             engine.load_skills_from_dir(global_path, prefix="GLOBAL:")
75 |     
   | ^^^^
76 |     engine.build_index()
77 |     return engine
   |
help: Remove whitespace from blank line

E402 Module level import not at top of file
  --> src\tools\trace_viz.py:80:1
   |
80 | from typing import Any
   | ^^^^^^^^^^^^^^^^^^^^^^
   |

W293 Blank line contains whitespace
  --> src\tools\trace_viz.py:92:1
   |
90 |         """
91 |         Initializes the renderer with a target persona theme.
92 |         
   | ^^^^^^^^
93 |         Args:
94 |             target_persona: The name of the persona to use for styling (e.g., 'ALFRED', 'O.D.I.N.').
   |
help: Remove whitespace from blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> src\tools\trace_viz.py:108:42
    |
106 |         HUD.box_top(title)
107 |
108 |     def box_row(self, label: str, value: Any, value_color: str = None, dim_label: bool = False) -> None:
    |                                          ^^^
109 |         """Renders a labeled data row in the current theme."""
110 |         HUD.PERSONA = self.target_persona
    |

RUF013 PEP 484 prohibits implicit `Optional`
   --> src\tools\trace_viz.py:108:60
    |
106 |         HUD.box_top(title)
107 |
108 |     def box_row(self, label: str, value: Any, value_color: str = None, dim_label: bool = False) -> None:
    |                                                            ^^^
109 |         """Renders a labeled data row in the current theme."""
110 |         HUD.PERSONA = self.target_persona
    |
help: Convert to `T | None`

E501 Line too long (104 > 100)
   --> src\tools\trace_viz.py:108:101
    |
106 |         HUD.box_top(title)
107 |
108 |     def box_row(self, label: str, value: Any, value_color: str = None, dim_label: bool = False) -> None:
    |                                                                                                     ^^^^
109 |         """Renders a labeled data row in the current theme."""
110 |         HUD.PERSONA = self.target_persona
    |

ANN201 Missing return type annotation for public function `box_separator`
   --> src\tools\trace_viz.py:113:9
    |
111 |         HUD.box_row(label, value, value_color, dim_label)
112 |
113 |     def box_separator(self):
    |         ^^^^^^^^^^^^^
114 |         """Renders a horizontal separator line within the log box."""
115 |         HUD.PERSONA = self.target_persona
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `box_bottom`
   --> src\tools\trace_viz.py:118:9
    |
116 |         HUD.box_separator()
117 |
118 |     def box_bottom(self):
    |         ^^^^^^^^^^
119 |         """Closes the current log box and restores character context."""
120 |         HUD.PERSONA = self.target_persona
    |
help: Add return type annotation: `None`

ANN201 Missing return type annotation for public function `render_neural_path`
   --> src\tools\trace_viz.py:124:9
    |
122 |         HUD.PERSONA = self.original_persona
123 |
124 |     def render_neural_path(self, traces: list[dict]):
    |         ^^^^^^^^^^^^^^^^^^
125 |         """[ALFRED] Render a chronological flowchart of triggered intents."""
126 |         self.box_top("NEURAL PATH (THE CAUSAL CHAIN)")
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:127:1
    |
125 |         """[ALFRED] Render a chronological flowchart of triggered intents."""
126 |         self.box_top("NEURAL PATH (THE CAUSAL CHAIN)")
127 |         
    | ^^^^^^^^
128 |         path = []
129 |         for t in traces:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:133:1
    |
131 |             if not path or path[-1] != trigger:
132 |                 path.append(trigger)
133 |         
    | ^^^^^^^^
134 |         if not path:
135 |             self.box_row("PATH", "Empty Signal", HUD.YELLOW)
    |
help: Remove whitespace from blank line

E501 Line too long (114 > 100)
   --> src\tools\trace_viz.py:144:101
    |
142 |                     inner_width = getattr(HUD, "_last_width", 60)
143 |                     pad = " " * (inner_width - 2 - 20 - 5 - 1)
144 |                     print(f"{HUD.DIM}â”‚{HUD.RESET} {' '*20} {HUD.DIM}{arrow}{HUD.RESET}{pad}{HUD.DIM}â”‚{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^
145 |                     
146 |         self.box_bottom()
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:145:1
    |
143 |                     pad = " " * (inner_width - 2 - 20 - 5 - 1)
144 |                     print(f"{HUD.DIM}â”‚{HUD.RESET} {' '*20} {HUD.DIM}{arrow}{HUD.RESET}{pad}{HUD.DIM}â”‚{HUD.RESET}")
145 |                     
    | ^^^^^^^^^^^^^^^^^^^^
146 |         self.box_bottom()
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `render_analysis`
   --> src\tools\trace_viz.py:148:9
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |         ^^^^^^^^^^^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `query`
   --> src\tools\trace_viz.py:148:31
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |                               ^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |

ANN001 Missing type annotation for function argument `trigger`
   --> src\tools\trace_viz.py:148:38
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |                                      ^^^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |

ANN001 Missing type annotation for function argument `score`
   --> src\tools\trace_viz.py:148:47
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |                                               ^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |

ANN001 Missing type annotation for function argument `is_global`
   --> src\tools\trace_viz.py:148:54
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |                                                      ^^^^^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |

ANN001 Missing type annotation for function argument `engine_instance`
   --> src\tools\trace_viz.py:148:65
    |
146 |         self.box_bottom()
147 |
148 |     def render_analysis(self, query, trigger, score, is_global, engine_instance=None):
    |                                                                 ^^^^^^^^^^^^^^^
149 |         # Set Persona Context
150 |         HUD.PERSONA = self.target_persona
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:152:1
    |
150 |         HUD.PERSONA = self.target_persona
151 |         theme = HUD.get_theme()
152 |         
    | ^^^^^^^^
153 |         # Header
154 |         print("\n")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:155:1
    |
153 |         # Header
154 |         print("\n")
155 |         
    | ^^^^^^^^
156 |         # Scanline Effect (Simulated)
157 |         if self.target_persona in ["O.D.I.N.", "GOD"]:
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:163:1
    |
162 |         self.box_top(theme["war_title"])
163 |         
    | ^^^^^^^^
164 |         self.box_row("Query", query, dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:165:1
    |
164 |         self.box_row("Query", query, dim_label=True)
165 |         
    | ^^^^^^^^
166 |         # Score Color Logic (Relative to Theme)
167 |         match_color = HUD.GREEN if score > 0.8 else HUD.YELLOW
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:174:1
    |
172 |         self.box_row(theme["trace_label"], f"{global_tag}{trigger}", match_color, dim_label=True)
173 |         self.box_row("Confidence", f"{score:.4f}", match_color, dim_label=True)
174 |         
    | ^^^^^^^^
175 |         self.box_separator()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:182:1
    |
180 |             skill_text = engine_instance.skills.get(trigger, "")
181 |             s_tokens = engine_instance.tokenize(skill_text)
182 |             
    | ^^^^^^^^^^^^
183 |             overlaps = []
184 |             for qt, qw in q_tokens.items():
    |
help: Remove whitespace from blank line

E501 Line too long (126 > 100)
   --> src\tools\trace_viz.py:191:101
    |
189 |             overlaps.sort(key=lambda x: x[3], reverse=True)
190 |
191 |             print(f"{theme['dim']}â”‚{HUD.RESET} {theme['main']}{'TOKEN':<15} {'WEIGHT':<10} {'IDF':<10} {'SIGNAL'}{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
192 |             
193 |             for token, weight, count, idf in overlaps[:5]:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:192:1
    |
191 |             print(f"{theme['dim']}â”‚{HUD.RESET} {theme['main']}{'TOKEN':<15} {'WEIGHT':<10} {'IDF':<10} {'SIGNAL'}{HUD.RESET}")
192 |             
    | ^^^^^^^^^^^^
193 |             for token, weight, count, idf in overlaps[:5]:
194 |                 signal_strength = weight * idf * math.log(1 + count)
    |
help: Remove whitespace from blank line

E501 Line too long (152 > 100)
   --> src\tools\trace_viz.py:196:101
    |
194 | â€¦+ count)
195 | â€¦
196 | â€¦5} {weight:<10.2f} {idf:<10.2f} {theme['main']}{'â–ˆ' * int(signal_strength * 2)}{HUD.RESET}")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 | â€¦
198 | â€¦D.YELLOW)
    |

ANN201 Missing return type annotation for public function `mode_live`
   --> src\tools\trace_viz.py:205:5
    |
203 | # --- MODES ---
204 |
205 | def mode_live(query):
    |     ^^^^^^^^^
206 |     engine = get_engine()
207 |     results = engine.search(query)
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `query`
   --> src\tools\trace_viz.py:205:15
    |
203 | # --- MODES ---
204 |
205 | def mode_live(query):
    |               ^^^^^
206 |     engine = get_engine()
207 |     results = engine.search(query)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:209:1
    |
207 |     results = engine.search(query)
208 |     top_match = results[0] if results else None
209 |     
    | ^^^^
210 |     # Live always uses CURRENT Identity
211 |     # Live always uses CURRENT Identity
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:214:1
    |
212 |     p = HUD.PERSONA
213 |     renderer = TraceRenderer(p)
214 |     
    | ^^^^
215 |     trigger = top_match['trigger'] if top_match else "NONE"
216 |     score = top_match['score'] if top_match else 0.0
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:218:1
    |
216 |     score = top_match['score'] if top_match else 0.0
217 |     is_global = top_match.get('is_global', False)
218 |     
    | ^^^^
219 |     renderer.render_analysis(query, trigger, score, is_global, engine)
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `mode_file`
   --> src\tools\trace_viz.py:221:5
    |
219 |     renderer.render_analysis(query, trigger, score, is_global, engine)
220 |
221 | def mode_file(file_path):
    |     ^^^^^^^^^
222 |     data = load_json(file_path)
223 |     if not data:
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `file_path`
   --> src\tools\trace_viz.py:221:15
    |
219 |     renderer.render_analysis(query, trigger, score, is_global, engine)
220 |
221 | def mode_file(file_path):
    |               ^^^^^^^^^
222 |     data = load_json(file_path)
223 |     if not data:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:231:1
    |
229 |     stored_persona = data.get("persona", "ALFRED").upper()
230 |     renderer = TraceRenderer(stored_persona)
231 |     
    | ^^^^
232 |     # Get Theme for message (temp switch)
233 |     original = HUD.PERSONA
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:237:1
    |
235 |     theme = HUD.get_theme()
236 |     HUD.PERSONA = original # Restore
237 |     
    | ^^^^
238 |     print(f"{theme['dim']}>> REPLAYING ARTIFACT: {file_path} [{stored_persona}]{HUD.RESET}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:239:1
    |
238 |     print(f"{theme['dim']}>> REPLAYING ARTIFACT: {file_path} [{stored_persona}]{HUD.RESET}")
239 |     
    | ^^^^
240 |     engine = get_engine() # For token analysis
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:241:1
    |
240 |     engine = get_engine() # For token analysis
241 |     
    | ^^^^
242 |     renderer.render_analysis(
243 |         data.get("query"),
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `mode_war_room`
   --> src\tools\trace_viz.py:250:5
    |
248 |     )
249 |
250 | def mode_war_room():
    |     ^^^^^^^^^^^^^
251 |     # War Room is O.D.I.N.'S DOMAIN
252 |     renderer = TraceRenderer("O.D.I.N.")
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:255:1
    |
253 |     HUD.PERSONA = "O.D.I.N." # Enforce globally for direct log calls
254 |     theme = HUD.get_theme()
255 |     
    | ^^^^
256 |     print("\n")
257 |     renderer.box_top("âš”ï¸  THE WAR ROOM  âš”ï¸")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:258:1
    |
256 |     print("\n")
257 |     renderer.box_top("âš”ï¸  THE WAR ROOM  âš”ï¸")
258 |     
    | ^^^^
259 |     base_path = os.path.dirname(current_dir)
260 |     traces_dir = os.path.join(base_path, "traces")
    |
help: Remove whitespace from blank line

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\trace_viz.py:259:17
    |
257 |     renderer.box_top("âš”ï¸  THE WAR ROOM  âš”ï¸")
258 |     
259 |     base_path = os.path.dirname(current_dir)
    |                 ^^^^^^^^^^^^^^^
260 |     traces_dir = os.path.join(base_path, "traces")
261 |     trace_files = glob.glob(os.path.join(traces_dir, "*.json"))
    |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\trace_viz.py:260:18
    |
259 |     base_path = os.path.dirname(current_dir)
260 |     traces_dir = os.path.join(base_path, "traces")
    |                  ^^^^^^^^^^^^
261 |     trace_files = glob.glob(os.path.join(traces_dir, "*.json"))
    |

PTH207 Replace `glob` with `Path.glob` or `Path.rglob`
   --> src\tools\trace_viz.py:261:19
    |
259 |     base_path = os.path.dirname(current_dir)
260 |     traces_dir = os.path.join(base_path, "traces")
261 |     trace_files = glob.glob(os.path.join(traces_dir, "*.json"))
    |                   ^^^^^^^^^
262 |     
263 |     query_map = defaultdict(list)
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\trace_viz.py:261:29
    |
259 |     base_path = os.path.dirname(current_dir)
260 |     traces_dir = os.path.join(base_path, "traces")
261 |     trace_files = glob.glob(os.path.join(traces_dir, "*.json"))
    |                             ^^^^^^^^^^^^
262 |     
263 |     query_map = defaultdict(list)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:262:1
    |
260 |     traces_dir = os.path.join(base_path, "traces")
261 |     trace_files = glob.glob(os.path.join(traces_dir, "*.json"))
262 |     
    | ^^^^
263 |     query_map = defaultdict(list)
264 |     for tf in trace_files:
    |
help: Remove whitespace from blank line

PTH119 `os.path.basename()` should be replaced by `Path.name`
   --> src\tools\trace_viz.py:268:35
    |
266 |         q = t_data.get("query")
267 |         if q:
268 |             t_data['_filename'] = os.path.basename(tf)
    |                                   ^^^^^^^^^^^^^^^^
269 |             query_map[q].append(t_data)
    |
help: Replace with `Path(...).name`

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:270:1
    |
268 |             t_data['_filename'] = os.path.basename(tf)
269 |             query_map[q].append(t_data)
270 |             
    | ^^^^^^^^^^^^
271 |     conflicts = []
272 |     print(f"{theme['dim']}>> SCANNING {len(trace_files)} SECTORS...{HUD.RESET}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:273:1
    |
271 |     conflicts = []
272 |     print(f"{theme['dim']}>> SCANNING {len(trace_files)} SECTORS...{HUD.RESET}")
273 |     
    | ^^^^
274 |     for query, traces in query_map.items():
275 |         matches = set()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:280:1
    |
278 |             matches.add(t.get("match"))
279 |             personas_involved.add(t.get("persona", "ALFRED"))
280 |             
    | ^^^^^^^^^^^^
281 |         if len(matches) > 1 and len(personas_involved) > 1:
282 |             conflicts.append({
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:287:1
    |
285 |                 "outcomes": list(matches)
286 |             })
287 |             
    | ^^^^^^^^^^^^
288 |     if not conflicts:
289 |         renderer.box_row("STATUS", "PACIFIED", HUD.GREEN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:293:1
    |
291 |         renderer.box_row("STATUS", f"{len(conflicts)} ACTIVE CONFLICTS", HUD.RED)
292 |         renderer.box_separator()
293 |         
    | ^^^^^^^^
294 |         print(f"{theme['dim']}â”‚{HUD.RESET} {theme['main']}{'QUERY':<25} {'FACTIONS':<20} {'CONFLICTING OUTCOMES'}{HUD.RESET}")
    |
help: Remove whitespace from blank line

E501 Line too long (126 > 100)
   --> src\tools\trace_viz.py:294:101
    |
292 |         renderer.box_separator()
293 |         
294 |         print(f"{theme['dim']}â”‚{HUD.RESET} {theme['main']}{'QUERY':<25} {'FACTIONS':<20} {'CONFLICTING OUTCOMES'}{HUD.RESET}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
295 |         
296 |         for c in conflicts:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:295:1
    |
294 |         print(f"{theme['dim']}â”‚{HUD.RESET} {theme['main']}{'QUERY':<25} {'FACTIONS':<20} {'CONFLICTING OUTCOMES'}{HUD.RESET}")
295 |         
    | ^^^^^^^^
296 |         for c in conflicts:
297 |             q_short = (c['query'][:22] + '..') if len(c['query']) > 22 else c['query']
    |
help: Remove whitespace from blank line

E501 Line too long (101 > 100)
   --> src\tools\trace_viz.py:309:101
    |
307 |     parser.add_argument("query", nargs="?", help="The natural language query to visualize")
308 |     parser.add_argument("--file", "-f", help="Path to a JSON trace file to replay")
309 |     parser.add_argument("--war-room", "-w", action="store_true", help="Enter Conflict Analysis Mode")
    |                                                                                                     ^
310 |     
311 |     args = parser.parse_args()
    |

W293 [*] Blank line contains whitespace
   --> src\tools\trace_viz.py:310:1
    |
308 |     parser.add_argument("--file", "-f", help="Path to a JSON trace file to replay")
309 |     parser.add_argument("--war-room", "-w", action="store_true", help="Enter Conflict Analysis Mode")
310 |     
    | ^^^^
311 |     args = parser.parse_args()
    |
help: Remove whitespace from blank line

W292 [*] No newline at end of file
   --> src\tools\trace_viz.py:321:28
    |
319 |         mode_live(args.query)
320 |     else:
321 |         parser.print_help()
    |                            ^
    |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\tools\tune_weights.py:1:1
  |
1 | / import json
2 | | import os
3 | | import sys
4 | | from collections import defaultdict
5 | |
6 | | from src.core.ui import HUD
7 | | from src.core.engine.vector import SovereignVector
  | |__________________________________________________^
  |
help: Organize imports

ANN201 Missing return type annotation for public function `analyze_failure`
  --> src\tools\tune_weights.py:17:9
   |
15 |         self.analysis = defaultdict(list)
16 |
17 |     def analyze_failure(self, query: str, expected: str, actual: dict):
   |         ^^^^^^^^^^^^^^^
18 |         """Diagnose a single test failure and propose weight shifts."""
19 |         q_tokens = self.engine.tokenize(query)
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:22:1
   |
20 |         target_tokens = set(self.engine.tokenize(self.engine.skills.get(expected, "")))
21 |         rival_tokens = set(self.engine.tokenize(self.engine.skills.get(actual['trigger'], "")))
22 |         
   | ^^^^^^^^
23 |         for t in q_tokens:
24 |             if t in rival_tokens and t not in target_tokens:
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `report`
  --> src\tools\tune_weights.py:32:9
   |
30 |                 self.analysis[t].append(f"Up: Unique to {expected}")
31 |
32 |     def report(self):
   |         ^^^^^^
33 |         """Display the proposed optimization plan."""
34 |         if not self.updates:
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:40:1
   |
38 |         for t, w in self.updates.items():
39 |             HUD.log("Optimizing", f"{t} -> {w:.1f}", f"({len(self.analysis[t])} signals)")
40 |         
   | ^^^^^^^^
41 |         print(f"\n{HUD.YELLOW}{HUD.BOLD}>> [Î©] DECREE: THESAURUS OPTIMIZATION REQUIRED{HUD.RESET}")
42 |         for t, w in self.updates.items(): print(f"- {t}: {t}:{w:.2f}")
   |
help: Remove whitespace from blank line

E701 Multiple statements on one line (colon)
  --> src\tools\tune_weights.py:42:41
   |
41 |         print(f"\n{HUD.YELLOW}{HUD.BOLD}>> [Î©] DECREE: THESAURUS OPTIMIZATION REQUIRED{HUD.RESET}")
42 |         for t, w in self.updates.items(): print(f"- {t}: {t}:{w:.2f}")
   |                                         ^
43 |
44 |     def apply_updates(self, thesaurus_path: str):
   |

ANN201 Missing return type annotation for public function `apply_updates`
  --> src\tools\tune_weights.py:44:9
   |
42 |         for t, w in self.updates.items(): print(f"- {t}: {t}:{w:.2f}")
43 |
44 |     def apply_updates(self, thesaurus_path: str):
   |         ^^^^^^^^^^^^^
45 |         """Persist the learned weights back to the thesaurus file."""
46 |         if not self.updates or not os.path.exists(thesaurus_path):
   |
help: Add return type annotation: `None`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\tune_weights.py:46:36
   |
44 |     def apply_updates(self, thesaurus_path: str):
45 |         """Persist the learned weights back to the thesaurus file."""
46 |         if not self.updates or not os.path.exists(thesaurus_path):
   |                                    ^^^^^^^^^^^^^^
47 |             return
   |
help: Replace with `Path(...).exists()`

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:50:1
   |
49 |         HUD.log("INFO", f"Writing {len(self.updates)} weight updates to {thesaurus_path}...")
50 |         
   | ^^^^^^^^
51 |         try:
52 |             with open(thesaurus_path, 'r', encoding='utf-8') as f:
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\tune_weights.py:52:18
   |
51 |         try:
52 |             with open(thesaurus_path, 'r', encoding='utf-8') as f:
   |                  ^^^^
53 |                 lines = f.readlines()
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\tune_weights.py:52:39
   |
51 |         try:
52 |             with open(thesaurus_path, 'r', encoding='utf-8') as f:
   |                                       ^^^
53 |                 lines = f.readlines()
   |
help: Remove mode argument

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:54:1
   |
52 |             with open(thesaurus_path, 'r', encoding='utf-8') as f:
53 |                 lines = f.readlines()
54 |             
   | ^^^^^^^^^^^^
55 |             new_lines = []
56 |             updated_tokens = set()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:62:1
   |
60 |             # or adding it if missing?
61 |             # For simplicity in this architectural fix, we update existing entries.
62 |             
   | ^^^^^^^^^^^^
63 |             for line in lines:
64 |                 if not line.strip().startswith("- "):
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:67:1
   |
65 |                     new_lines.append(line)
66 |                     continue
67 |                 
   | ^^^^^^^^^^^^^^^^
68 |                 # Parse key
69 |                 parts = line.split(":", 1)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:73:1
   |
71 |                     new_lines.append(line)
72 |                     continue
73 |                     
   | ^^^^^^^^^^^^^^^^^^^^
74 |                 key = parts[0].strip("- ").strip().lower()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:75:1
   |
74 |                 key = parts[0].strip("- ").strip().lower()
75 |                 
   | ^^^^^^^^^^^^^^^^
76 |                 if key in self.updates:
77 |                     # Reconstruct the line with new weight for the self-referential synonym
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:84:1
   |
82 |                     new_syns = []
83 |                     found_self = False
84 |                     
   | ^^^^^^^^^^^^^^^^^^^^
85 |                     target_weight = self.updates[key]
   |
help: Remove whitespace from blank line

RUF059 Unpacked variable `s_w` is never used
  --> src\tools\tune_weights.py:89:36
   |
87 |                     for s in syns:
88 |                         if ":" in s:
89 |                             s_key, s_w = s.split(":")[:2]
   |                                    ^^^
90 |                             if s_key.strip().lower() == key:
91 |                                 new_syns.append(f"{s_key}:{target_weight:.2f}")
   |
help: Prefix it with an underscore or any other dummy variable pattern

W293 [*] Blank line contains whitespace
  --> src\tools\tune_weights.py:97:1
   |
95 |                         else:
96 |                             new_syns.append(s)
97 |                     
   | ^^^^^^^^^^^^^^^^^^^^
98 |                     if not found_self:
99 |                         new_syns.insert(0, f"{key}:{target_weight:.2f}")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\tune_weights.py:100:1
    |
 98 |                     if not found_self:
 99 |                         new_syns.insert(0, f"{key}:{target_weight:.2f}")
100 |                         
    | ^^^^^^^^^^^^^^^^^^^^^^^^
101 |                     new_lines.append(f"- {key}: {', '.join(new_syns)}\n")
102 |                     updated_tokens.add(key)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\tune_weights.py:105:1
    |
103 |                 else:
104 |                     new_lines.append(line)
105 |             
    | ^^^^^^^^^^^^
106 |             # Append new keys if needed (optional, but good for learning loop)
107 |             for t, w in self.updates.items():
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\tune_weights.py:111:18
    |
109 |                     new_lines.append(f"- {t}: {t}:{w:.2f}\n")
110 |
111 |             with open(thesaurus_path, 'w', encoding='utf-8') as f:
    |                  ^^^^
112 |                 f.writelines(new_lines)
    |
help: Replace with `Path.open()`

W293 [*] Blank line contains whitespace
   --> src\tools\tune_weights.py:113:1
    |
111 |             with open(thesaurus_path, 'w', encoding='utf-8') as f:
112 |                 f.writelines(new_lines)
113 |                 
    | ^^^^^^^^^^^^^^^^
114 |             HUD.log("SUCCESS", "Neural weights persisted.")
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `tune_weights`
   --> src\tools\tune_weights.py:119:5
    |
117 |             HUD.log("ERROR", f"Failed to persist weights: {e}")
118 |
119 | def tune_weights(project_root: str):
    |     ^^^^^^^^^^^^
120 |     """[ALFRED] Refactored tuning loop with encapsulated MetaLearner."""
121 |     HUD.box_top("SOVEREIGN CYCLE: WEIGHT TUNING")
    |
help: Add return type annotation: `None`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:122:15
    |
120 |     """[ALFRED] Refactored tuning loop with encapsulated MetaLearner."""
121 |     HUD.box_top("SOVEREIGN CYCLE: WEIGHT TUNING")
122 |     db_path = os.path.join(project_root, "fishtest_data.json")
    |               ^^^^^^^^^^^^
123 |     if not os.path.exists(db_path): return
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\tools\tune_weights.py:123:12
    |
121 |     HUD.box_top("SOVEREIGN CYCLE: WEIGHT TUNING")
122 |     db_path = os.path.join(project_root, "fishtest_data.json")
123 |     if not os.path.exists(db_path): return
    |            ^^^^^^^^^^^^^^
124 |
125 |     def _res(fname):
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\tools\tune_weights.py:123:35
    |
121 |     HUD.box_top("SOVEREIGN CYCLE: WEIGHT TUNING")
122 |     db_path = os.path.join(project_root, "fishtest_data.json")
123 |     if not os.path.exists(db_path): return
    |                                   ^
124 |
125 |     def _res(fname):
    |

ANN202 Missing return type annotation for private function `_res`
   --> src\tools\tune_weights.py:125:9
    |
123 |     if not os.path.exists(db_path): return
124 |
125 |     def _res(fname):
    |         ^^^^
126 |         candidates = [
127 |             os.path.join(project_root, fname.replace('.md', '.qmd')),
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `fname`
   --> src\tools\tune_weights.py:125:14
    |
123 |     if not os.path.exists(db_path): return
124 |
125 |     def _res(fname):
    |              ^^^^^
126 |         candidates = [
127 |             os.path.join(project_root, fname.replace('.md', '.qmd')),
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:127:13
    |
125 |     def _res(fname):
126 |         candidates = [
127 |             os.path.join(project_root, fname.replace('.md', '.qmd')),
    |             ^^^^^^^^^^^^
128 |             os.path.join(project_root, fname),
129 |             os.path.join(project_root, "src", "data", fname.replace('.md', '.qmd')),
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:128:13
    |
126 |         candidates = [
127 |             os.path.join(project_root, fname.replace('.md', '.qmd')),
128 |             os.path.join(project_root, fname),
    |             ^^^^^^^^^^^^
129 |             os.path.join(project_root, "src", "data", fname.replace('.md', '.qmd')),
130 |             os.path.join(project_root, "src", "data", fname)
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:129:13
    |
127 |             os.path.join(project_root, fname.replace('.md', '.qmd')),
128 |             os.path.join(project_root, fname),
129 |             os.path.join(project_root, "src", "data", fname.replace('.md', '.qmd')),
    |             ^^^^^^^^^^^^
130 |             os.path.join(project_root, "src", "data", fname)
131 |         ]
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:130:13
    |
128 |             os.path.join(project_root, fname),
129 |             os.path.join(project_root, "src", "data", fname.replace('.md', '.qmd')),
130 |             os.path.join(project_root, "src", "data", fname)
    |             ^^^^^^^^^^^^
131 |         ]
132 |         for c in candidates:
    |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
   --> src\tools\tune_weights.py:133:16
    |
131 |         ]
132 |         for c in candidates:
133 |             if os.path.exists(c): return c
    |                ^^^^^^^^^^^^^^
134 |         return candidates[1] # Default to root md if nothing found
    |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
   --> src\tools\tune_weights.py:133:33
    |
131 |         ]
132 |         for c in candidates:
133 |             if os.path.exists(c): return c
    |                                 ^
134 |         return candidates[1] # Default to root md if nothing found
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> src\tools\tune_weights.py:138:33
    |
136 |     engine = SovereignVector(_res("thesaurus.qmd"))
137 |     engine.load_core_skills()
138 |     engine.load_skills_from_dir(os.path.join(os.path.dirname(os.path.dirname(__file__)), "skills"))
    |                                 ^^^^^^^^^^^^
139 |     engine.build_index()
    |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\tune_weights.py:138:46
    |
136 |     engine = SovereignVector(_res("thesaurus.qmd"))
137 |     engine.load_core_skills()
138 |     engine.load_skills_from_dir(os.path.join(os.path.dirname(os.path.dirname(__file__)), "skills"))
    |                                              ^^^^^^^^^^^^^^^
139 |     engine.build_index()
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\tune_weights.py:138:62
    |
136 |     engine = SovereignVector(_res("thesaurus.qmd"))
137 |     engine.load_core_skills()
138 |     engine.load_skills_from_dir(os.path.join(os.path.dirname(os.path.dirname(__file__)), "skills"))
    |                                                              ^^^^^^^^^^^^^^^
139 |     engine.build_index()
    |
help: Replace with `Path(...).parent`

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\tune_weights.py:141:10
    |
139 |     engine.build_index()
140 |
141 |     with open(db_path, 'r', encoding='utf-8') as f: data = json.load(f)
    |          ^^^^
142 |     learner = MetaLearner(engine)
    |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
   --> src\tools\tune_weights.py:141:24
    |
139 |     engine.build_index()
140 |
141 |     with open(db_path, 'r', encoding='utf-8') as f: data = json.load(f)
    |                        ^^^
142 |     learner = MetaLearner(engine)
    |
help: Remove mode argument

E701 Multiple statements on one line (colon)
   --> src\tools\tune_weights.py:141:51
    |
139 |     engine.build_index()
140 |
141 |     with open(db_path, 'r', encoding='utf-8') as f: data = json.load(f)
    |                                                   ^
142 |     learner = MetaLearner(engine)
    |

W293 [*] Blank line contains whitespace
   --> src\tools\tune_weights.py:143:1
    |
141 |     with open(db_path, 'r', encoding='utf-8') as f: data = json.load(f)
142 |     learner = MetaLearner(engine)
143 |     
    | ^^^^
144 |     for case in data.get('test_cases', []):
145 |         res = engine.search(case['query'])
    |
help: Remove whitespace from blank line

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\tools\tune_weights.py:147:9
    |
145 |           res = engine.search(case['query'])
146 |           top = res[0] if res else None
147 | /         if not top or top['trigger'] != case['expected'] or top['score'] < 0.85:
148 | |             if top: learner.analyze_failure(case['query'], case['expected'], top)
    | |___________________^
149 |
150 |       learner.report()
    |
help: Combine `if` statements using `and`

E701 Multiple statements on one line (colon)
   --> src\tools\tune_weights.py:148:19
    |
146 |         top = res[0] if res else None
147 |         if not top or top['trigger'] != case['expected'] or top['score'] < 0.85:
148 |             if top: learner.analyze_failure(case['query'], case['expected'], top)
    |                   ^
149 |
150 |     learner.report()
    |

W293 [*] Blank line contains whitespace
   --> src\tools\tune_weights.py:151:1
    |
150 |     learner.report()
151 |     
    | ^^^^
152 |     # Close the loop
153 |     if learner.updates:
    |
help: Remove whitespace from blank line

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\tune_weights.py:158:48
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    |                                                ^^^^^^^^^^^^^^^
159 |     tune_weights(rt)
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\tune_weights.py:158:64
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    |                                                                ^^^^^^^^^^^^^^^
159 |     tune_weights(rt)
    |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> src\tools\tune_weights.py:158:80
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    |                                                                                ^^^^^^^^^^^^^^^
159 |     tune_weights(rt)
    |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
   --> src\tools\tune_weights.py:158:96
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    |                                                                                                ^^^^^^^^^^^^^^^
159 |     tune_weights(rt)
    |
help: Replace with `Path(...).resolve()`

E501 Line too long (123 > 100)
   --> src\tools\tune_weights.py:158:101
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
159 |     tune_weights(rt)
    |

W292 [*] No newline at end of file
   --> src\tools\tune_weights.py:159:21
    |
157 | if __name__ == "__main__":
158 |     rt = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
159 |     tune_weights(rt)
    |                     ^
    |
help: Add trailing newline

I001 [*] Import block is un-sorted or un-formatted
 --> src\tools\update_gemini_manifest.py:1:1
  |
1 | import sys
  | ^^^^^^^^^^
2 | try:
3 |     # Force safe encoding for Windows subprocess readers - MUST BE CP1252 compatible
  |
help: Organize imports

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\tools\update_gemini_manifest.py:8:1
   |
 6 |       if sys.stderr and hasattr(sys.stderr, 'reconfigure'):
 7 |           sys.stderr.reconfigure(encoding='cp1252', errors='replace')
 8 | / except Exception:
 9 | |     pass
   | |________^
10 |
11 |   import json
   |

ANN201 Missing return type annotation for public function `get_git_summary`
  --> src\tools\update_gemini_manifest.py:17:5
   |
17 | def get_git_summary():
   |     ^^^^^^^^^^^^^^^
18 |     try:
19 |         # Force UTF-8 decoding for git log to handle emojis in commits
   |
help: Add return type annotation

S607 Starting a process with a partial executable path
  --> src\tools\update_gemini_manifest.py:21:13
   |
19 |         # Force UTF-8 decoding for git log to handle emojis in commits
20 |         res = subprocess.run(
21 |             ["git", "log", "-n", "5", "--oneline"], 
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |             capture_output=True, 
23 |             encoding='utf-8', 
   |

W291 [*] Trailing whitespace
  --> src\tools\update_gemini_manifest.py:21:52
   |
19 |         # Force UTF-8 decoding for git log to handle emojis in commits
20 |         res = subprocess.run(
21 |             ["git", "log", "-n", "5", "--oneline"], 
   |                                                    ^
22 |             capture_output=True, 
23 |             encoding='utf-8', 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\update_gemini_manifest.py:22:33
   |
20 |         res = subprocess.run(
21 |             ["git", "log", "-n", "5", "--oneline"], 
22 |             capture_output=True, 
   |                                 ^
23 |             encoding='utf-8', 
24 |             errors='replace', 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\update_gemini_manifest.py:23:30
   |
21 |             ["git", "log", "-n", "5", "--oneline"], 
22 |             capture_output=True, 
23 |             encoding='utf-8', 
   |                              ^
24 |             errors='replace', 
25 |             text=True
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\update_gemini_manifest.py:24:30
   |
22 |             capture_output=True, 
23 |             encoding='utf-8', 
24 |             errors='replace', 
   |                              ^
25 |             text=True
26 |         )
   |
help: Remove trailing whitespace

ANN201 Missing return type annotation for public function `get_task_status`
  --> src\tools\update_gemini_manifest.py:33:5
   |
31 |         return "Git history unavailable."
32 |
33 | def get_task_status():
   |     ^^^^^^^^^^^^^^^
34 |     tpath = "tasks.qmd"
35 |     if not os.path.exists(tpath): return "tasks.qmd not found."
   |
help: Add return type annotation

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\update_gemini_manifest.py:35:12
   |
33 | def get_task_status():
34 |     tpath = "tasks.qmd"
35 |     if not os.path.exists(tpath): return "tasks.qmd not found."
   |            ^^^^^^^^^^^^^^
36 |     try:
37 |         with open(tpath, "r", encoding="utf-8", errors='replace') as f:
   |
help: Replace with `Path(...).exists()`

E701 Multiple statements on one line (colon)
  --> src\tools\update_gemini_manifest.py:35:33
   |
33 | def get_task_status():
34 |     tpath = "tasks.qmd"
35 |     if not os.path.exists(tpath): return "tasks.qmd not found."
   |                                 ^
36 |     try:
37 |         with open(tpath, "r", encoding="utf-8", errors='replace') as f:
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\update_gemini_manifest.py:37:14
   |
35 |     if not os.path.exists(tpath): return "tasks.qmd not found."
36 |     try:
37 |         with open(tpath, "r", encoding="utf-8", errors='replace') as f:
   |              ^^^^
38 |             lines = f.readlines()
39 |             for i, line in enumerate(lines):
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\update_gemini_manifest.py:37:26
   |
35 |     if not os.path.exists(tpath): return "tasks.qmd not found."
36 |     try:
37 |         with open(tpath, "r", encoding="utf-8", errors='replace') as f:
   |                          ^^^
38 |             lines = f.readlines()
39 |             for i, line in enumerate(lines):
   |
help: Remove mode argument

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> src\tools\update_gemini_manifest.py:42:5
   |
40 |                   if "## â­ï¸ Start Here Next" in line:
41 |                       return "".join(lines[i:i+10]).strip()
42 | /     except Exception:
43 | |         pass
   | |____________^
44 |       return "Could not parse next tasks."
   |

ANN201 Missing return type annotation for public function `update_manifest`
  --> src\tools\update_gemini_manifest.py:46:5
   |
44 |     return "Could not parse next tasks."
45 |
46 | def update_manifest():
   |     ^^^^^^^^^^^^^^^
47 |     # Robust root resolution: walk up until config.json or .git is found
48 |     current = os.path.dirname(os.path.abspath(__file__))
   |
help: Add return type annotation: `None`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\update_gemini_manifest.py:48:15
   |
46 | def update_manifest():
47 |     # Robust root resolution: walk up until config.json or .git is found
48 |     current = os.path.dirname(os.path.abspath(__file__))
   |               ^^^^^^^^^^^^^^^
49 |     root = current
50 |     while root != os.path.dirname(root):
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> src\tools\update_gemini_manifest.py:48:31
   |
46 | def update_manifest():
47 |     # Robust root resolution: walk up until config.json or .git is found
48 |     current = os.path.dirname(os.path.abspath(__file__))
   |                               ^^^^^^^^^^^^^^^
49 |     root = current
50 |     while root != os.path.dirname(root):
   |
help: Replace with `Path(...).resolve()`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\update_gemini_manifest.py:50:19
   |
48 |     current = os.path.dirname(os.path.abspath(__file__))
49 |     root = current
50 |     while root != os.path.dirname(root):
   |                   ^^^^^^^^^^^^^^^
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
52 |             break
   |
help: Replace with `Path(...).parent`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\update_gemini_manifest.py:51:12
   |
49 |     root = current
50 |     while root != os.path.dirname(root):
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
   |            ^^^^^^^^^^^^^^
52 |             break
53 |         root = os.path.dirname(root)
   |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\update_gemini_manifest.py:51:27
   |
49 |     root = current
50 |     while root != os.path.dirname(root):
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
   |                           ^^^^^^^^^^^^
52 |             break
53 |         root = os.path.dirname(root)
   |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\update_gemini_manifest.py:51:65
   |
49 |     root = current
50 |     while root != os.path.dirname(root):
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
   |                                                                 ^^^^^^^^^^^^^^
52 |             break
53 |         root = os.path.dirname(root)
   |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\update_gemini_manifest.py:51:80
   |
49 |     root = current
50 |     while root != os.path.dirname(root):
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
   |                                                                                ^^^^^^^^^^^^
52 |             break
53 |         root = os.path.dirname(root)
   |

E501 Line too long (107 > 100)
  --> src\tools\update_gemini_manifest.py:51:101
   |
49 |     root = current
50 |     while root != os.path.dirname(root):
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
   |                                                                                                     ^^^^^^^
52 |             break
53 |         root = os.path.dirname(root)
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> src\tools\update_gemini_manifest.py:53:16
   |
51 |         if os.path.exists(os.path.join(root, "config.json")) or os.path.exists(os.path.join(root, ".git")):
52 |             break
53 |         root = os.path.dirname(root)
   |                ^^^^^^^^^^^^^^^
54 |     
55 |     cpath = os.path.join(root, "config.json")
   |
help: Replace with `Path(...).parent`

W293 [*] Blank line contains whitespace
  --> src\tools\update_gemini_manifest.py:54:1
   |
52 |             break
53 |         root = os.path.dirname(root)
54 |     
   | ^^^^
55 |     cpath = os.path.join(root, "config.json")
56 |     mpath = os.path.join(root, "GEMINI.qmd")
   |
help: Remove whitespace from blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\update_gemini_manifest.py:55:13
   |
53 |         root = os.path.dirname(root)
54 |     
55 |     cpath = os.path.join(root, "config.json")
   |             ^^^^^^^^^^^^
56 |     mpath = os.path.join(root, "GEMINI.qmd")
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> src\tools\update_gemini_manifest.py:56:13
   |
55 |     cpath = os.path.join(root, "config.json")
56 |     mpath = os.path.join(root, "GEMINI.qmd")
   |             ^^^^^^^^^^^^
57 |     
58 |     config = {}
   |

W293 [*] Blank line contains whitespace
  --> src\tools\update_gemini_manifest.py:57:1
   |
55 |     cpath = os.path.join(root, "config.json")
56 |     mpath = os.path.join(root, "GEMINI.qmd")
57 |     
   | ^^^^
58 |     config = {}
59 |     if os.path.exists(cpath):
   |
help: Remove whitespace from blank line

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> src\tools\update_gemini_manifest.py:59:8
   |
58 |     config = {}
59 |     if os.path.exists(cpath):
   |        ^^^^^^^^^^^^^^
60 |         with open(cpath, "r") as f: config = json.load(f)
   |
help: Replace with `Path(...).exists()`

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\update_gemini_manifest.py:60:14
   |
58 |     config = {}
59 |     if os.path.exists(cpath):
60 |         with open(cpath, "r") as f: config = json.load(f)
   |              ^^^^
61 |     
62 |     persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |
help: Replace with `Path.open()`

UP015 [*] Unnecessary mode argument
  --> src\tools\update_gemini_manifest.py:60:26
   |
58 |     config = {}
59 |     if os.path.exists(cpath):
60 |         with open(cpath, "r") as f: config = json.load(f)
   |                          ^^^
61 |     
62 |     persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |
help: Remove mode argument

E701 Multiple statements on one line (colon)
  --> src\tools\update_gemini_manifest.py:60:35
   |
58 |     config = {}
59 |     if os.path.exists(cpath):
60 |         with open(cpath, "r") as f: config = json.load(f)
   |                                   ^
61 |     
62 |     persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |

W293 [*] Blank line contains whitespace
  --> src\tools\update_gemini_manifest.py:61:1
   |
59 |     if os.path.exists(cpath):
60 |         with open(cpath, "r") as f: config = json.load(f)
61 |     
   | ^^^^
62 |     persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\update_gemini_manifest.py:63:1
   |
62 |     persona = (config.get("persona") or config.get("Persona") or "ALFRED").upper()
63 |     
   | ^^^^
64 |     lines = [
65 |         f"# ðŸ’Ž GEMINI NEURAL MANIFEST\n",
   |
help: Remove whitespace from blank line

F541 [*] f-string without any placeholders
  --> src\tools\update_gemini_manifest.py:65:9
   |
64 |     lines = [
65 |         f"# ðŸ’Ž GEMINI NEURAL MANIFEST\n",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |         f"> **Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
67 |         f"> **Active Mind**: {persona}\n",
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> src\tools\update_gemini_manifest.py:71:9
   |
69 |         f"- **Project Root**: `{root}`",
70 |         f"- **Persona Strategy**: `personas.py -> {persona.lower()}`",
71 |         f"- **Framework Port**: 3000 (O.D.I.N. Dashboard)\n",
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |         "## â­ï¸ Priority Directives",
73 |         get_task_status(),
   |
help: Remove extraneous `f` prefix

W293 [*] Blank line contains whitespace
  --> src\tools\update_gemini_manifest.py:83:1
   |
81 |         "- **Operational Buffer**: STABLE"
82 |     ]
83 |     
   | ^^^^
84 |     with open(mpath, "w", encoding="utf-8") as f:
85 |         f.write("\n".join(lines))
   |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
  --> src\tools\update_gemini_manifest.py:84:10
   |
82 |     ]
83 |     
84 |     with open(mpath, "w", encoding="utf-8") as f:
   |          ^^^^
85 |         f.write("\n".join(lines))
86 |     print(f"Manifest updated: {mpath}")
   |
help: Replace with `Path.open()`

E501 Line too long (125 > 100)
  --> src\tools\utility_belt.py:8:101
   |
 7 | Targets highly complex functions.
 8 | Uses the Antigravity Bridge to request an exact logical equivalent that is broken down, type-hinted, and docstring-commented.
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
 9 | Mandates that pytest passes on the newly refactored code before committing.
10 | Mandates human-in-the-loop (diff review) before committing refactored code to the manor.
   |

F401 [*] `os` imported but unused
  --> src\tools\utility_belt.py:17:8
   |
15 | import json
16 | import logging
17 | import os
   |        ^^
18 | import subprocess
19 | import sys
   |
help: Remove unused import: `os`

F401 [*] `tempfile` imported but unused
  --> src\tools\utility_belt.py:20:8
   |
18 | import subprocess
19 | import sys
20 | import tempfile
   |        ^^^^^^^^
21 | from pathlib import Path
22 | from typing import Any, Optional
   |
help: Remove unused import: `tempfile`

F401 [*] `typing.Any` imported but unused
  --> src\tools\utility_belt.py:22:20
   |
20 | import tempfile
21 | from pathlib import Path
22 | from typing import Any, Optional
   |                    ^^^
23 |
24 | # Ensure UTF-8 output for box-drawing characters
   |
help: Remove unused import: `typing.Any`

E402 Module level import not at top of file
  --> src\tools\utility_belt.py:32:1
   |
30 |     sys.path.append(str(project_root))
31 |
32 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 | from src.cstar.core.uplink import query_bridge
   |

E402 Module level import not at top of file
  --> src\tools\utility_belt.py:33:1
   |
32 | from src.core.ui import HUD
33 | from src.cstar.core.uplink import query_bridge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |
35 | # Configure Logging
   |

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:49:1
   |
47 |         self.target_path = Path(target).resolve()
48 |         self.max_retries = max_retries
49 |         
   | ^^^^^^^^
50 |         # Enforce ALFRED persona
51 |         HUD.PERSONA = "ALFRED"
   |
help: Remove whitespace from blank line

UP045 [*] Use `X | None` for type annotations
  --> src\tools\utility_belt.py:53:56
   |
51 |         HUD.PERSONA = "ALFRED"
52 |
53 |     async def _refactor_code(self, file_path: Path) -> Optional[str]:
   |                                                        ^^^^^^^^^^^^^
54 |         """Queries the bridge to refactor the code."""
55 |         if not file_path.exists():
   |
help: Convert to `X | None`

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:58:1
   |
56 |             HUD.persona_log("ERROR", f"Target file not found: {file_path}")
57 |             return None
58 |             
   | ^^^^^^^^^^^^
59 |         code_content = file_path.read_text(encoding="utf-8")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:60:1
   |
59 |         code_content = file_path.read_text(encoding="utf-8")
60 |         
   | ^^^^^^^^
61 |         prompt = f"""
62 | [CRITICAL INSTRUCTION]
   |
help: Remove whitespace from blank line

E501 Line too long (112 > 100)
  --> src\tools\utility_belt.py:64:101
   |
62 | [CRITICAL INSTRUCTION]
63 | You are ALFRED, the elegant refactoring engine for the Corvus Star Manor.
64 | Your task is to refactor the following Python file for extreme elegance, readability, and the Linscott Standard.
   |                                                                                                     ^^^^^^^^^^^^
65 |
66 | TARGET FILE ({file_path.name}):
   |

E501 Line too long (107 > 100)
  --> src\tools\utility_belt.py:72:101
   |
71 | [MANDATORY REFACTORING CONSTRAINTS]
72 | 1. DO NOT alter the underlying logic or public API signatures. This code MUST pass its existing test suite.
   |                                                                                                     ^^^^^^^
73 | 2. Break down highly complex (cyclomatic complexity > C) functions into smaller, private helper functions.
74 | 3. Enforce rigorous Type Hints (e.g., `list[str]`, `dict[str, Any]`, `Optional[int]`).
   |

E501 Line too long (106 > 100)
  --> src\tools\utility_belt.py:73:101
   |
71 | [MANDATORY REFACTORING CONSTRAINTS]
72 | 1. DO NOT alter the underlying logic or public API signatures. This code MUST pass its existing test suite.
73 | 2. Break down highly complex (cyclomatic complexity > C) functions into smaller, private helper functions.
   |                                                                                                     ^^^^^^
74 | 3. Enforce rigorous Type Hints (e.g., `list[str]`, `dict[str, Any]`, `Optional[int]`).
75 | 4. Weave in missing Google-style Docstrings for all classes and functions.
   |

E501 Line too long (111 > 100)
  --> src\tools\utility_belt.py:76:101
   |
74 | 3. Enforce rigorous Type Hints (e.g., `list[str]`, `dict[str, Any]`, `Optional[int]`).
75 | 4. Weave in missing Google-style Docstrings for all classes and functions.
76 | 5. Output ONLY the raw, complete Python code for the refactored file. No markdown formatting, no explanations. 
   |                                                                                                     ^^^^^^^^^^^
77 | 6. Do not remove necessary imports.
   |

W291 Trailing whitespace
  --> src\tools\utility_belt.py:76:111
   |
74 | 3. Enforce rigorous Type Hints (e.g., `list[str]`, `dict[str, Any]`, `Optional[int]`).
75 | 4. Weave in missing Google-style Docstrings for all classes and functions.
76 | 5. Output ONLY the raw, complete Python code for the refactored file. No markdown formatting, no explanations. 
   |                                                                                                               ^
77 | 6. Do not remove necessary imports.
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:85:1
   |
83 |             "target_interface": str(file_path)
84 |         }
85 |         
   | ^^^^^^^^
86 |         HUD.persona_log("INFO", f"Bridging to Forge for refinement of {file_path.name}...")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:87:1
   |
86 |         HUD.persona_log("INFO", f"Bridging to Forge for refinement of {file_path.name}...")
87 |         
   | ^^^^^^^^
88 |         for attempt in range(self.max_retries):
89 |             try:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\utility_belt.py:93:1
   |
91 |                 if response and response.get("status") == "success":
92 |                     data = response.get("data", {})
93 |                     
   | ^^^^^^^^^^^^^^^^^^^^
94 |                     if isinstance(data, dict):
95 |                          if "code" in data:
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:103:1
    |
101 |                     else:
102 |                         code = str(data)
103 |                         
    | ^^^^^^^^^^^^^^^^^^^^^^^^
104 |                     return self._clean_markdown(code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:105:1
    |
104 |                     return self._clean_markdown(code)
105 |                     
    | ^^^^^^^^^^^^^^^^^^^^
106 |             except Exception as e:
107 |                 HUD.persona_log("WARN", f"Forge attempt {attempt+1} failed: {e}")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:109:1
    |
107 |                 HUD.persona_log("WARN", f"Forge attempt {attempt+1} failed: {e}")
108 |                 await asyncio.sleep(2)
109 |                 
    | ^^^^^^^^^^^^^^^^
110 |         HUD.persona_log("ERROR", "Max retries exceeded for refactoring.")
111 |         return None
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:127:1
    |
125 |         """Runs the test suite against the refactored code in a temporary environment."""
126 |         HUD.persona_log("INFO", "Initializing The Crucible (Verification Phase)...")
127 |         
    | ^^^^^^^^
128 |         # Determine the test file name heuristically based on conventions
129 |         test_filename = f"test_{target_file.name}"
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:131:1
    |
129 |         test_filename = f"test_{target_file.name}"
130 |         test_filepath = None
131 |         
    | ^^^^^^^^
132 |         search_dirs = [
133 |             project_root / "tests",
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:138:1
    |
136 |             project_root / "tests" / "empire_tests"
137 |         ]
138 |         
    | ^^^^^^^^
139 |         for sd in search_dirs:
140 |             potential_path = sd / test_filename
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:144:1
    |
142 |                 test_filepath = potential_path
143 |                 break
144 |                 
    | ^^^^^^^^^^^^^^^^
145 |         if not test_filepath:
146 |             HUD.persona_log("WARN", "CRUCIBLE ABORT: No corresponding test file found. Refactoring cannot proceed safely.")
    |
help: Remove whitespace from blank line

E501 Line too long (123 > 100)
   --> src\tools\utility_belt.py:146:101
    |
145 |         if not test_filepath:
146 |             HUD.persona_log("WARN", "CRUCIBLE ABORT: No corresponding test file found. Refactoring cannot proceed safely.")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^
147 |             return False
    |

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:151:1
    |
149 |         # We must test the refactored code without permanently destroying the original file.
150 |         # Approach: Backup original -> Write new -> Run Pytest -> Restore original
151 |         
    | ^^^^^^^^
152 |         backup_code = target_file.read_text(encoding="utf-8")
153 |         crucible_passed = False
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:154:1
    |
152 |         backup_code = target_file.read_text(encoding="utf-8")
153 |         crucible_passed = False
154 |         
    | ^^^^^^^^
155 |         try:
156 |             # Inject
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:158:1
    |
156 |             # Inject
157 |             target_file.write_text(refactored_code, encoding="utf-8")
158 |             
    | ^^^^^^^^^^^^
159 |             # Execute Pytest specifically on the target's test file
160 |             cmd = [sys.executable, "-m", "pytest", str(test_filepath), "-q", "--tb=short"]
    |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\utility_belt.py:161:22
    |
159 |             # Execute Pytest specifically on the target's test file
160 |             cmd = [sys.executable, "-m", "pytest", str(test_filepath), "-q", "--tb=short"]
161 |             result = subprocess.run(cmd, capture_output=True, text=True)
    |                      ^^^^^^^^^^^^^^
162 |             
163 |             if result.returncode == 0:
    |

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:162:1
    |
160 |             cmd = [sys.executable, "-m", "pytest", str(test_filepath), "-q", "--tb=short"]
161 |             result = subprocess.run(cmd, capture_output=True, text=True)
162 |             
    | ^^^^^^^^^^^^
163 |             if result.returncode == 0:
164 |                 HUD.persona_log("SUCCESS", "CRUCIBLE PASSED: Logic integrity maintained.")
    |
help: Remove whitespace from blank line

E501 Line too long (101 > 100)
   --> src\tools\utility_belt.py:170:101
    |
168 |                  # Print a snippet of the failure
169 |                  HUD.box_separator()
170 |                  HUD.box_row("TEST FAILURE", result.stdout[:200].replace('\n', ' ') + "...", HUD.RED)
    |                                                                                                     ^
171 |                  HUD.box_separator()
    |

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:172:1
    |
170 |                  HUD.box_row("TEST FAILURE", result.stdout[:200].replace('\n', ' ') + "...", HUD.RED)
171 |                  HUD.box_separator()
172 |                  
    | ^^^^^^^^^^^^^^^^^
173 |         finally:
174 |             # Always restore the original immediately during verification
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:176:1
    |
174 |             # Always restore the original immediately during verification
175 |             target_file.write_text(backup_code, encoding="utf-8")
176 |             
    | ^^^^^^^^^^^^
177 |         return crucible_passed
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:185:1
    |
183 |         HUD.box_row("TARGET", target_file.name, HUD.CYAN)
184 |         HUD.box_separator()
185 |         
    | ^^^^^^^^
186 |         lines = refactored_code.splitlines()
187 |         preview_lines = lines[:15]
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:190:1
    |
188 |         for line in preview_lines:
189 |              HUD.box_row("  ", line, HUD.CYAN, dim_label=True)
190 |              
    | ^^^^^^^^^^^^^
191 |         if len(lines) > 15:
192 |              HUD.box_row("  ", f"... (+ {len(lines)-15} more lines)", HUD.CYAN, dim_label=True)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:193:1
    |
191 |         if len(lines) > 15:
192 |              HUD.box_row("  ", f"... (+ {len(lines)-15} more lines)", HUD.CYAN, dim_label=True)
193 |              
    | ^^^^^^^^^^^^^
194 |         HUD.box_separator()
195 |         try:
    |
help: Remove whitespace from blank line

E501 Line too long (162 > 100)
   --> src\tools\utility_belt.py:196:101
    |
194 | â€¦
195 | â€¦
196 | â€¦ the forge glow subsides. Shall I commit this refinement to the main branch? (y/N): {HUD.RESET}")
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
197 | â€¦
198 | â€¦
    |

E501 Line too long (108 > 100)
   --> src\tools\utility_belt.py:205:101
    |
203 |         try:
204 |              target_file.write_text(refactored_code, encoding="utf-8")
205 |              HUD.persona_log("SUCCESS", f"Committed refinement to: {target_file.relative_to(project_root)}")
    |                                                                                                     ^^^^^^^^
206 |              return True
207 |         except Exception as e:
    |

ANN201 Missing return type annotation for public function `execute`
   --> src\tools\utility_belt.py:211:15
    |
209 |              return False
210 |
211 |     async def execute(self):
    |               ^^^^^^^
212 |         """Main execution sequence."""
213 |         HUD.box_top("[A] THE UTILITY BELT")
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:216:1
    |
214 |         HUD.box_row("DIRECTIVE", "ELEGANCE & REFACTORING", HUD.CYAN)
215 |         HUD.box_row("TARGET", str(self.target_path), HUD.YELLOW)
216 |         
    | ^^^^^^^^
217 |         if not self.target_path.exists() or not self.target_path.is_file():
218 |             HUD.box_row("STATUS", "Invalid target file.", HUD.RED)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:221:1
    |
219 |             HUD.box_bottom()
220 |             return
221 |             
    | ^^^^^^^^^^^^
222 |         HUD.box_separator()
223 |         HUD.persona_log("INFO", "Initializing Forge sequence...")
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:224:1
    |
222 |         HUD.box_separator()
223 |         HUD.persona_log("INFO", "Initializing Forge sequence...")
224 |         
    | ^^^^^^^^
225 |         refactored_code = await self._refactor_code(self.target_path)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:226:1
    |
225 |         refactored_code = await self._refactor_code(self.target_path)
226 |         
    | ^^^^^^^^
227 |         if not refactored_code:
228 |             HUD.box_row("RESULT", "Refactoring Failed. Check Bridge logs.", HUD.RED)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:231:1
    |
229 |             HUD.box_bottom()
230 |             return
231 |             
    | ^^^^^^^^^^^^
232 |         secure = self._verify_crucible(self.target_path, refactored_code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:233:1
    |
232 |         secure = self._verify_crucible(self.target_path, refactored_code)
233 |         
    | ^^^^^^^^
234 |         if not secure:
235 |              HUD.box_row("RESULT", "Refactoring discarded due to test failure.", HUD.RED)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:238:1
    |
236 |              HUD.box_bottom()
237 |              return
238 |                 
    | ^^^^^^^^^^^^^^^^
239 |         approved = self._human_review(self.target_path, refactored_code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:240:1
    |
239 |         approved = self._human_review(self.target_path, refactored_code)
240 |         
    | ^^^^^^^^
241 |         if approved:
242 |             self._commit_refactor(self.target_path, refactored_code)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\utility_belt.py:245:1
    |
243 |         else:
244 |             HUD.persona_log("INFO", "Refinement rejected by user. Discarding trace.")
245 |                 
    | ^^^^^^^^^^^^^^^^
246 |         HUD.box_bottom()
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\tools\utility_belt.py:248:5
    |
246 |         HUD.box_bottom()
247 |
248 | def main():
    |     ^^^^
249 |     parser = argparse.ArgumentParser(description="The Utility Belt - Refactoring Forge")
250 |     parser.add_argument("target", help="File to refactor")
    |
help: Add return type annotation: `int | None`

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\voice_check.py:7:1
   |
 5 |   sys.path.append(str(Path(__file__).parent.parent.parent))
 6 |
 7 | / from src.core.engine.dialogue import DialogueEngine
 8 | | from src.core.ui import HUD
   | |___________________________^
 9 |
10 |   def main():
   |
help: Organize imports

ANN201 Missing return type annotation for public function `main`
  --> src\tools\voice_check.py:10:5
   |
 8 | from src.core.ui import HUD
 9 |
10 | def main():
   |     ^^^^
11 |     hud = HUD()
12 |     engine = DialogueEngine("src/data/dialogue/phrases.yaml")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\voice_check.py:13:1
   |
11 |     hud = HUD()
12 |     engine = DialogueEngine("src/data/dialogue/phrases.yaml")
13 |     
   | ^^^^
14 |     if len(sys.argv) < 3:
15 |         hud.box_top("DIALOGUE VOICE CHECKER")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\voice_check.py:23:1
   |
21 |     intent = sys.argv[2].upper()
22 |     tags = sys.argv[3].split(",") if len(sys.argv) > 3 else []
23 |     
   | ^^^^
24 |     context = {"error_type": tags[0]} if tags else {}
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\voice_check.py:25:1
   |
24 |     context = {"error_type": tags[0]} if tags else {}
25 |     
   | ^^^^
26 |     hud.box_top(f"VOICE CHECK: {persona} [{intent}]")
27 |     hud.box_row("Context Tags", f"{tags}")
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\voice_check.py:28:1
   |
26 |     hud.box_top(f"VOICE CHECK: {persona} [{intent}]")
27 |     hud.box_row("Context Tags", f"{tags}")
28 |     
   | ^^^^
29 |     phrase = engine.get(persona, intent, context=context)
30 |     hud.box_row("Result", f"{phrase}")
   |
help: Remove whitespace from blank line

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\wrap_it_up.py:11:1
   |
 9 |   5. Git Commit & Push
10 |   """
11 | / import sys
12 | | import subprocess
13 | | import shutil
14 | | from pathlib import Path
15 | | from datetime import datetime
   | |_____________________________^
16 |
17 |   # Add project root to path
   |
help: Organize imports

F401 [*] `shutil` imported but unused
  --> src\tools\wrap_it_up.py:13:8
   |
11 | import sys
12 | import subprocess
13 | import shutil
   |        ^^^^^^
14 | from pathlib import Path
15 | from datetime import datetime
   |
help: Remove unused import: `shutil`

E402 Module level import not at top of file
  --> src\tools\wrap_it_up.py:23:1
   |
22 | # Core Imports
23 | from src.core.ui import HUD
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 | from src.core.sv_engine import SovereignEngine
25 | from src.tools import compile_session_traces
   |

I001 [*] Import block is un-sorted or un-formatted
  --> src\tools\wrap_it_up.py:23:1
   |
22 |   # Core Imports
23 | / from src.core.ui import HUD
24 | | from src.core.sv_engine import SovereignEngine
25 | | from src.tools import compile_session_traces
26 | | from src.tools.update_gemini_manifest import update_manifest
   | |____________________________________________________________^
27 |
28 |   class SovereignWrapper:
   |
help: Organize imports

E402 Module level import not at top of file
  --> src\tools\wrap_it_up.py:24:1
   |
22 | # Core Imports
23 | from src.core.ui import HUD
24 | from src.core.sv_engine import SovereignEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 | from src.tools import compile_session_traces
26 | from src.tools.update_gemini_manifest import update_manifest
   |

E402 Module level import not at top of file
  --> src\tools\wrap_it_up.py:25:1
   |
23 | from src.core.ui import HUD
24 | from src.core.sv_engine import SovereignEngine
25 | from src.tools import compile_session_traces
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 | from src.tools.update_gemini_manifest import update_manifest
   |

E402 Module level import not at top of file
  --> src\tools\wrap_it_up.py:26:1
   |
24 | from src.core.sv_engine import SovereignEngine
25 | from src.tools import compile_session_traces
26 | from src.tools.update_gemini_manifest import update_manifest
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |
28 | class SovereignWrapper:
   |

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:31:1
   |
29 |     def __init__(self):
30 |         self.root = PROJECT_ROOT
31 |         
   | ^^^^^^^^
32 |         # Enforce O.D.I.N. persona for the Wrap-Up Protocol
33 |         HUD.PERSONA = "O.D.I.N."
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `run_gungnir_gate`
  --> src\tools\wrap_it_up.py:36:9
   |
34 |         HUD._INITIALIZED = True # Prevent lazy-loading overwrites
35 |
36 |     def run_gungnir_gate(self):
   |         ^^^^^^^^^^^^^^^^
37 |         """Executes the Gungnir validation gate (Ruff + Pytest)."""
38 |         HUD.box_top("GUNGNIR GATE")
   |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:39:1
   |
37 |         """Executes the Gungnir validation gate (Ruff + Pytest)."""
38 |         HUD.box_top("GUNGNIR GATE")
39 |         
   | ^^^^^^^^
40 |         # 1. Ruff (Linting)
41 |         HUD.box_row("STEP 1", "Ruff Linting", HUD.CYAN)
   |
help: Remove whitespace from blank line

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\wrap_it_up.py:44:13
   |
42 |         try:
43 |             # Check for ruff
44 |             subprocess.run(
   |             ^^^^^^^^^^^^^^
45 |                 [sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], 
46 |                 cwd=str(self.root), 
   |

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:45:91
   |
43 |             # Check for ruff
44 |             subprocess.run(
45 |                 [sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], 
   |                                                                                           ^
46 |                 cwd=str(self.root), 
47 |                 check=True, 
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:46:36
   |
44 |             subprocess.run(
45 |                 [sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], 
46 |                 cwd=str(self.root), 
   |                                    ^
47 |                 check=True, 
48 |                 capture_output=True
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:47:28
   |
45 |                 [sys.executable, "-m", "ruff", "check", ".", "--select", "E9,F63,F7,F82"], 
46 |                 cwd=str(self.root), 
47 |                 check=True, 
   |                            ^
48 |                 capture_output=True
49 |             )
   |
help: Remove trailing whitespace

S603 `subprocess` call: check for execution of untrusted input
  --> src\tools\wrap_it_up.py:61:13
   |
59 |         HUD.box_row("STEP 2", "Pytest Suite", HUD.CYAN)
60 |         try:
61 |             subprocess.run(
   |             ^^^^^^^^^^^^^^
62 |                 [sys.executable, "-m", "pytest"], 
63 |                 cwd=str(self.root), 
   |

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:62:50
   |
60 |         try:
61 |             subprocess.run(
62 |                 [sys.executable, "-m", "pytest"], 
   |                                                  ^
63 |                 cwd=str(self.root), 
64 |                 check=True
   |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:63:36
   |
61 |             subprocess.run(
62 |                 [sys.executable, "-m", "pytest"], 
63 |                 cwd=str(self.root), 
   |                                    ^
64 |                 check=True
65 |             )
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:71:1
   |
69 |             HUD.persona_log("HEIMDALL", "BREACH: Unit tests failed. Commit aborted.")
70 |             sys.exit(1)
71 |             
   | ^^^^^^^^^^^^
72 |         HUD.box_bottom()
   |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `synchronize_state`
  --> src\tools\wrap_it_up.py:75:9
   |
75 |     def synchronize_state(self):
   |         ^^^^^^^^^^^^^^^^^
76 |         """Compiles traces, updates manifest, and syncs docs."""
77 |         HUD.persona_log("ALFRED", "Synchronizing neural state and compiled traces...")
   |
help: Add return type annotation

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:78:1
   |
76 |         """Compiles traces, updates manifest, and syncs docs."""
77 |         HUD.persona_log("ALFRED", "Synchronizing neural state and compiled traces...")
78 |         
   | ^^^^^^^^
79 |         # 1. Compile Traces
80 |         # compile_session_traces.compile_traces returns (raw_traces, stats)
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:82:1
   |
80 |         # compile_session_traces.compile_traces returns (raw_traces, stats)
81 |         _, stats = compile_session_traces.compile_traces()
82 |         
   | ^^^^^^^^
83 |         # 2. Update Manifest
84 |         update_manifest()
   |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:85:1
   |
83 |         # 2. Update Manifest
84 |         update_manifest()
85 |         
   | ^^^^^^^^
86 |         # 3. Dynamic Documentation (Edda)
87 |         self._edda_sync()
   |
help: Remove whitespace from blank line

W291 [*] Trailing whitespace
  --> src\tools\wrap_it_up.py:94:45
   |
92 |             engine = SovereignEngine(project_root=self.root)
93 |             # This implicitly calls build_index()
94 |             _ = engine._init_vector_engine() 
   |                                             ^
95 |         except Exception as e:
96 |             HUD.persona_log("HEIMDALL", f"BREACH: Vector Indexing failed. {e}")
   |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
  --> src\tools\wrap_it_up.py:98:1
   |
96 |             HUD.persona_log("HEIMDALL", f"BREACH: Vector Indexing failed. {e}")
97 |             sys.exit(1)
98 |             
   | ^^^^^^^^^^^^
99 |         return stats
   |
help: Remove whitespace from blank line

ANN202 Missing return type annotation for private function `_edda_sync`
   --> src\tools\wrap_it_up.py:101:9
    |
 99 |         return stats
100 |
101 |     def _edda_sync(self):
    |         ^^^^^^^^^^
102 |         """Updates walkthrough if new skills/workflows are detected (Dynamic Autosync)."""
103 |         # Scan for untracked/added files in relevant directories
    |
help: Add return type annotation: `None`

S607 Starting a process with a partial executable path
   --> src\tools\wrap_it_up.py:106:17
    |
104 |         try:
105 |             proc = subprocess.run(
106 |                 ["git", "status", "--porcelain"], 
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 |                 cwd=str(self.root), 
108 |                 capture_output=True, 
    |

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:106:50
    |
104 |         try:
105 |             proc = subprocess.run(
106 |                 ["git", "status", "--porcelain"], 
    |                                                  ^
107 |                 cwd=str(self.root), 
108 |                 capture_output=True, 
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:107:36
    |
105 |             proc = subprocess.run(
106 |                 ["git", "status", "--porcelain"], 
107 |                 cwd=str(self.root), 
    |                                    ^
108 |                 capture_output=True, 
109 |                 text=True
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:108:37
    |
106 |                 ["git", "status", "--porcelain"], 
107 |                 cwd=str(self.root), 
108 |                 capture_output=True, 
    |                                     ^
109 |                 text=True
110 |             )
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:112:1
    |
110 |             )
111 |             changes = proc.stdout.splitlines()
112 |             
    | ^^^^^^^^^^^^
113 |             # Filter for new (??) or added (A) files in skills/workflows
114 |             new_capabilities = []
    |
help: Remove whitespace from blank line

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src\tools\wrap_it_up.py:117:17
    |
115 |               for line in changes:
116 |                   status, path = line[:2], line[3:]
117 | /                 if status.strip() in ("??", "A"):
118 | |                     if "src/skills" in path or ".agent/workflows" in path:
    | |__________________________________________________________________________^
119 |                           new_capabilities.append(path)
    |
help: Combine `if` statements using `and`

E501 Line too long (124 > 100)
   --> src\tools\wrap_it_up.py:122:101
    |
121 |             if new_capabilities:
122 |                 HUD.persona_log("EDDA", f"Detected {len(new_capabilities)} new capabilities. Documenting in Walkthrough...")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
123 |                 
124 |                 wpath = self.root / "walkthrough.qmd"
    |

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:123:1
    |
121 |             if new_capabilities:
122 |                 HUD.persona_log("EDDA", f"Detected {len(new_capabilities)} new capabilities. Documenting in Walkthrough...")
123 |                 
    | ^^^^^^^^^^^^^^^^
124 |                 wpath = self.root / "walkthrough.qmd"
125 |                 if wpath.exists():
    |
help: Remove whitespace from blank line

PTH123 `open()` should be replaced by `Path.open()`
   --> src\tools\wrap_it_up.py:127:26
    |
125 |                 if wpath.exists():
126 |                     timestamp = datetime.now().strftime('%H:%M:%S')
127 |                     with open(wpath, "a", encoding="utf-8") as f:
    |                          ^^^^
128 |                         f.write(f"\n\n### âš¡ Dynamic Capabilities Forged ({timestamp})\n")
129 |                         for cap in new_capabilities:
    |
help: Replace with `Path.open()`

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:131:1
    |
129 |                         for cap in new_capabilities:
130 |                             f.write(f"- `{cap}`\n")
131 |                             
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
132 |         except Exception as e:
133 |             HUD.persona_log("EDDA", f"Warning: Auto-documentation failed. {e}")
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `sovereign_commit`
   --> src\tools\wrap_it_up.py:135:9
    |
133 |             HUD.persona_log("EDDA", f"Warning: Auto-documentation failed. {e}")
134 |
135 |     def sovereign_commit(self, stats):
    |         ^^^^^^^^^^^^^^^^
136 |         """Generates commit message and pushes."""
137 |         HUD.persona_log("O.D.I.N.", "Initiating Sovereign Commit Protocol...")
    |
help: Add return type annotation: `None`

ANN001 Missing type annotation for function argument `stats`
   --> src\tools\wrap_it_up.py:135:32
    |
133 |             HUD.persona_log("EDDA", f"Warning: Auto-documentation failed. {e}")
134 |
135 |     def sovereign_commit(self, stats):
    |                                ^^^^^
136 |         """Generates commit message and pushes."""
137 |         HUD.persona_log("O.D.I.N.", "Initiating Sovereign Commit Protocol...")
    |

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:138:1
    |
136 |         """Generates commit message and pushes."""
137 |         HUD.persona_log("O.D.I.N.", "Initiating Sovereign Commit Protocol...")
138 |         
    | ^^^^^^^^
139 |         # Check for clean state
140 |         proc = subprocess.run(
    |
help: Remove whitespace from blank line

S607 Starting a process with a partial executable path
   --> src\tools\wrap_it_up.py:141:13
    |
139 |         # Check for clean state
140 |         proc = subprocess.run(
141 |             ["git", "status", "--porcelain"], 
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
142 |             cwd=str(self.root), 
143 |             capture_output=True, 
    |

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:141:46
    |
139 |         # Check for clean state
140 |         proc = subprocess.run(
141 |             ["git", "status", "--porcelain"], 
    |                                              ^
142 |             cwd=str(self.root), 
143 |             capture_output=True, 
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:142:32
    |
140 |         proc = subprocess.run(
141 |             ["git", "status", "--porcelain"], 
142 |             cwd=str(self.root), 
    |                                ^
143 |             capture_output=True, 
144 |             text=True
    |
help: Remove trailing whitespace

W291 [*] Trailing whitespace
   --> src\tools\wrap_it_up.py:143:33
    |
141 |             ["git", "status", "--porcelain"], 
142 |             cwd=str(self.root), 
143 |             capture_output=True, 
    |                                 ^
144 |             text=True
145 |         )
    |
help: Remove trailing whitespace

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:153:1
    |
151 |         top_skill = stats.get('top_performer', 'N/A')
152 |         total_traces = stats.get('total', 0)
153 |         
    | ^^^^^^^^
154 |         # Check for critical failures in stats to note in commit
155 |         fails = len(stats.get('critical_fails', []))
    |
help: Remove whitespace from blank line

S607 Starting a process with a partial executable path
   --> src\tools\wrap_it_up.py:170:28
    |
168 |         # Execute Git Protocol
169 |         try:
170 |             subprocess.run(["git", "add", "."], cwd=str(self.root), check=True)
    |                            ^^^^^^^^^^^^^^^^^^^
171 |             subprocess.run(["git", "commit", "-m", commit_msg], cwd=str(self.root), check=True)
172 |             subprocess.run(["git", "push"], cwd=str(self.root), check=True)
    |

S603 `subprocess` call: check for execution of untrusted input
   --> src\tools\wrap_it_up.py:171:13
    |
169 |         try:
170 |             subprocess.run(["git", "add", "."], cwd=str(self.root), check=True)
171 |             subprocess.run(["git", "commit", "-m", commit_msg], cwd=str(self.root), check=True)
    |             ^^^^^^^^^^^^^^
172 |             subprocess.run(["git", "push"], cwd=str(self.root), check=True)
    |

S607 Starting a process with a partial executable path
   --> src\tools\wrap_it_up.py:171:28
    |
169 |         try:
170 |             subprocess.run(["git", "add", "."], cwd=str(self.root), check=True)
171 |             subprocess.run(["git", "commit", "-m", commit_msg], cwd=str(self.root), check=True)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
172 |             subprocess.run(["git", "push"], cwd=str(self.root), check=True)
    |

S607 Starting a process with a partial executable path
   --> src\tools\wrap_it_up.py:172:28
    |
170 |             subprocess.run(["git", "add", "."], cwd=str(self.root), check=True)
171 |             subprocess.run(["git", "commit", "-m", commit_msg], cwd=str(self.root), check=True)
172 |             subprocess.run(["git", "push"], cwd=str(self.root), check=True)
    |                            ^^^^^^^^^^^^^^^
173 |             
174 |             HUD.box_top("SOVEREIGN COMMIT")
    |

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:173:1
    |
171 |             subprocess.run(["git", "commit", "-m", commit_msg], cwd=str(self.root), check=True)
172 |             subprocess.run(["git", "push"], cwd=str(self.root), check=True)
173 |             
    | ^^^^^^^^^^^^
174 |             HUD.box_top("SOVEREIGN COMMIT")
175 |             HUD.box_row("STATUS", "PUSHED", HUD.GREEN)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:178:1
    |
176 |             HUD.box_row("HASH", "HEAD -> origin/main", HUD.CYAN)
177 |             HUD.box_bottom()
178 |             
    | ^^^^^^^^^^^^
179 |         except subprocess.CalledProcessError as e:
180 |             HUD.persona_log("HEIMDALL", f"BREACH: Git Protocol Failed. {e}")
    |
help: Remove whitespace from blank line

ANN201 Missing return type annotation for public function `main`
   --> src\tools\wrap_it_up.py:183:5
    |
181 |             sys.exit(1)
182 |
183 | def main():
    |     ^^^^
184 |     try:
185 |         wrapper = SovereignWrapper()
    |
help: Add return type annotation: `None`

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:186:1
    |
184 |     try:
185 |         wrapper = SovereignWrapper()
186 |         
    | ^^^^^^^^
187 |         # 1. Validation
188 |         wrapper.run_gungnir_gate()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:189:1
    |
187 |         # 1. Validation
188 |         wrapper.run_gungnir_gate()
189 |         
    | ^^^^^^^^
190 |         # 2. Sync State (Index, Docs, Traces)
191 |         stats = wrapper.synchronize_state()
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:192:1
    |
190 |         # 2. Sync State (Index, Docs, Traces)
191 |         stats = wrapper.synchronize_state()
192 |         
    | ^^^^^^^^
193 |         # 3. Commit
194 |         wrapper.sovereign_commit(stats)
    |
help: Remove whitespace from blank line

W293 [*] Blank line contains whitespace
   --> src\tools\wrap_it_up.py:195:1
    |
193 |         # 3. Commit
194 |         wrapper.sovereign_commit(stats)
195 |         
    | ^^^^^^^^
196 |     except KeyboardInterrupt:
197 |         print("\n[HEIMDALL] Protocol Interrupted by User.")
    |
help: Remove whitespace from blank line

Found 2684 errors.
[*] 1004 fixable with the `--fix` option (256 hidden fixes can be enabled with the `--unsafe-fixes` option).
